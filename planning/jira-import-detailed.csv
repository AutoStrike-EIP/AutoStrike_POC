Summary,Issue Type,Description,Labels
"EP-01: Infrastructure & Setup",Epic,"**Objectif:**
Mettre en place l'infrastructure de base du projet AutoStrike avec les trois composants principaux (Server Go, Agent Rust, Dashboard React) et la configuration DevOps complete.

**Scope:**
- Initialisation des 3 projets avec leur structure de repertoires
- Configuration de l'environnement de developpement (Docker, VS Code, IDE)
- Mise en place de la CI/CD (GitHub Actions)
- Configuration des linters et formatters (golangci-lint, clippy, eslint)
- Generation des certificats mTLS pour le developpement
- Scripts de build et de demarrage

**Architecture:**
```
autostrike/
├── server/          # Go 1.21+
│   ├── cmd/
│   ├── internal/
│   ├── go.mod
│   └── Makefile
├── agent/           # Rust 1.70+
│   ├── src/
│   ├── Cargo.toml
│   └── build.rs
├── dashboard/       # React 18+
│   ├── src/
│   ├── package.json
│   └── vite.config.ts
├── scripts/
│   └── generate-certs.sh
└── docker-compose.yml
```

**Livrables:**
- Repository Git structure avec les 3 projets
- docker-compose.yml fonctionnel pour dev
- Pipeline CI/CD avec build et tests
- Scripts de generation de certificats
- Documentation du setup local (README)

**Definition of Done:**
[ ] Les 3 projets compilent sans erreur
[ ] docker-compose up demarre tous les services
[ ] CI pipeline passe (build + lint)
[ ] Certificats mTLS generes et fonctionnels
[ ] README avec instructions de setup",infrastructure
"EP-02: Backend - Architecture Hexagonale",Epic,"**Objectif:**
Implementer le Control Server en Go avec une architecture hexagonale propre, separant clairement le domaine metier des adaptateurs techniques.

**Scope:**
- Structure des packages selon l'architecture hexagonale
- Definition des entites du domaine (Agent, Scenario, Technique, Result)
- Implementation des ports (interfaces inbound et outbound)
- Implementation des services applicatifs (Use Cases)
- Configuration de Gin comme framework HTTP
- Injection de dependances dans main.go

**Architecture:**
```
server/internal/
├── domain/
│   ├── entity/
│   │   ├── agent.go
│   │   ├── scenario.go
│   │   ├── technique.go
│   │   └── result.go
│   ├── service/
│   │   ├── orchestrator.go
│   │   ├── validator.go
│   │   └── score_calculator.go
│   ├── repository/     # Interfaces (ports outbound)
│   │   ├── agent_repo.go
│   │   ├── scenario_repo.go
│   │   └── result_repo.go
│   └── valueobject/
│       ├── tactic.go
│       └── status.go
├── application/        # Use cases (ports inbound)
│   ├── scenario_service.go
│   ├── agent_service.go
│   └── result_service.go
└── infrastructure/     # Adapters
    ├── persistence/
    ├── communication/
    └── api/
```

**Livrables:**
- Entites du domaine completes avec methodes metier
- Interfaces de repository definies
- Services applicatifs avec logique metier
- Injection de dependances fonctionnelle
- Tests unitaires du domain layer (>80% coverage)

**Definition of Done:**
[ ] Architecture hexagonale respectee (pas de dependance domain -> infra)
[ ] Toutes les entites definies avec leurs methodes
[ ] Interfaces repository definies
[ ] Services applicatifs implementes
[ ] Tests unitaires domain layer >80%
[ ] Code passe golangci-lint sans erreur",backend
"EP-03: Agent Rust - Core",Epic,"**Objectif:**
Developper l'agent AutoStrike en Rust avec les fonctionnalites de base: beaconing, communication securisee mTLS, et execution de commandes.

**Scope:**
- Structure du projet Rust avec modules
- Client HTTP avec support mTLS (reqwest + rustls)
- Systeme de beaconing avec jitter
- Trait Executor et implementations (PowerShell, CMD, Bash)
- Gestion de la configuration (CLI args, env vars)
- Collecte des informations systeme (hostname, platform, username)

**Architecture:**
```
agent/src/
├── main.rs              # Point d'entree, boucle beacon
├── config.rs            # Configuration (server, sleep, jitter)
├── beacon/
│   ├── mod.rs
│   ├── client.rs        # Client HTTP/mTLS
│   └── protocol.rs      # Structures JSON request/response
├── executor/
│   ├── mod.rs
│   ├── traits.rs        # Trait Executor
│   ├── powershell.rs    # Windows PowerShell
│   ├── cmd.rs           # Windows CMD
│   └── bash.rs          # Linux/macOS Bash
└── utils/
    ├── mod.rs
    ├── system.rs        # Info systeme
    └── crypto.rs        # Helpers crypto
```

**Livrables:**
- Agent qui compile pour Windows x64
- Beaconing fonctionnel vers le serveur
- Execution de commandes PowerShell/CMD
- Communication mTLS securisee
- Binaire optimise (<5MB)

**Definition of Done:**
[ ] Agent compile pour Windows x64
[ ] Beacon toutes les N secondes avec jitter
[ ] Execute les commandes recues du serveur
[ ] Retourne les resultats (stdout, stderr, exit code)
[ ] Communication mTLS fonctionnelle
[ ] Binaire release <5MB
[ ] Tests unitaires executors",agent
"EP-04: Dashboard React - Core",Epic,"**Objectif:**
Developper le dashboard React avec les composants de base: layout, navigation, composants UI reutilisables et routing.

**Scope:**
- Setup Vite + React 18 + TypeScript
- Configuration TailwindCSS
- Layout principal (Sidebar, Header, Content area)
- Routing avec React Router v6
- Composants UI de base (Button, Card, Modal, Loading, Badge)
- Configuration Zustand pour le state management
- Service API avec Axios et interceptors

**Architecture:**
```
dashboard/src/
├── components/
│   ├── Layout/
│   │   ├── Layout.tsx
│   │   ├── Sidebar.tsx
│   │   └── Header.tsx
│   └── common/
│       ├── Button.tsx
│       ├── Card.tsx
│       ├── Modal.tsx
│       ├── Loading.tsx
│       └── Badge.tsx
├── pages/
│   ├── Dashboard.tsx
│   ├── Matrix.tsx
│   ├── Agents.tsx
│   ├── Scenarios.tsx
│   └── Reports.tsx
├── services/
│   └── api.ts
├── store/
│   └── index.ts
├── types/
│   └── index.ts
├── App.tsx
└── index.tsx
```

**Livrables:**
- Application React fonctionnelle avec navigation
- Layout responsive (desktop + tablet)
- Composants UI documentes et reutilisables
- Service API configure avec gestion d'erreurs
- Pages placeholder pour chaque route

**Definition of Done:**
[ ] Application demarre sans erreur (vite dev)
[ ] Navigation entre toutes les pages fonctionne
[ ] Layout responsive (>768px)
[ ] Composants common exportes et documentes
[ ] TypeScript strict mode sans erreur
[ ] ESLint passe sans warning",dashboard
"EP-05: Systeme d'Authentification",Epic,"**Objectif:**
Implementer un systeme d'authentification securise avec JWT pour le dashboard et preparer l'authentification mTLS pour les agents.

**Scope:**
- Endpoint login/logout sur le backend
- Generation et validation des tokens JWT
- Middleware d'authentification Gin
- Refresh token avec rotation
- Stockage securise des mots de passe (bcrypt)
- Page de login sur le dashboard
- Interceptor Axios pour les tokens
- Protection des routes React

**Architecture:**
```
Backend:
- POST /api/v1/auth/login       # Login, retourne access + refresh token
- POST /api/v1/auth/refresh     # Refresh token
- POST /api/v1/auth/logout      # Invalidation token
- Middleware AuthRequired()     # Verification JWT sur routes protegees

Frontend:
- AuthContext pour l'etat d'authentification
- ProtectedRoute component
- useAuth() hook
- Stockage tokens (httpOnly cookie ou localStorage)
```

**Livrables:**
- Endpoints d'authentification fonctionnels
- Middleware JWT sur les routes protegees
- Page de login sur le dashboard
- Redirection automatique si non authentifie
- Gestion expiration et refresh automatique

**Definition of Done:**
[ ] Login/logout fonctionnel
[ ] JWT avec expiration 15min
[ ] Refresh token avec expiration 7j
[ ] Middleware protege les routes API
[ ] Dashboard redirige vers login si non auth
[ ] Mots de passe hashes avec bcrypt
[ ] Tests d'integration auth",security
"EP-06: Communication Agent-Server",Epic,"**Objectif:**
Implementer le protocole de communication complet entre les agents et le serveur: beaconing, dispatch des taches, et recuperation des resultats.

**Scope:**
- Endpoint beacon sur le serveur (POST /api/v1/agents/{paw}/beacon)
- Logique d'enregistrement des nouveaux agents
- Mise a jour du statut agent (online/offline basé sur last_seen)
- File d'attente des taches par agent (pending_tasks)
- Dispatch des instructions dans la reponse beacon
- Reception et stockage des resultats d'execution
- Heartbeat et detection agents offline

**Architecture:**
```
Protocole Beacon:

Agent -> Server:
POST /api/v1/agents/{paw}/beacon
{
  ""paw"": ""agent-uuid"",
  ""hostname"": ""PC-001"",
  ""platform"": ""windows"",
  ""executors"": [""psh"", ""cmd""],
  ""results"": [...]
}

Server -> Agent:
{
  ""paw"": ""agent-uuid"",
  ""sleep"": 5,
  ""instructions"": [
    {
      ""id"": ""task-001"",
      ""technique_id"": ""T1082"",
      ""executor"": ""psh"",
      ""command"": ""systeminfo"",
      ""timeout"": 30
    }
  ]
}
```

**Livrables:**
- Endpoint beacon complet
- Enregistrement automatique des agents
- Detection des agents offline (>3 beacons manques)
- Dispatch des taches aux agents
- Stockage des resultats en base
- UI liste des agents avec statut temps reel

**Definition of Done:**
[ ] Agent s'enregistre au premier beacon
[ ] Taches dispatched dans la reponse beacon
[ ] Resultats recus et stockes
[ ] Statut agent mis a jour automatiquement
[ ] Agent marque offline apres 3 beacons manques
[ ] UI affiche liste agents avec statut
[ ] Tests integration protocole beacon",communication
"EP-07: Techniques MITRE - Discovery",Epic,"**Objectif:**
Implementer les techniques MITRE ATT&CK de la tactique Discovery, qui sont les plus simples et les plus sures pour commencer.

**Scope:**
- T1082: System Information Discovery
- T1083: File and Directory Discovery
- T1057: Process Discovery
- T1016: System Network Configuration Discovery
- T1069: Permission Groups Discovery
- T1087: Account Discovery

**Architecture:**
```
Fichiers YAML (configs/techniques/):
├── T1082.yaml    # systeminfo, Get-ComputerInfo
├── T1083.yaml    # dir, ls, Get-ChildItem
├── T1057.yaml    # tasklist, ps, Get-Process
├── T1016.yaml    # ipconfig, ifconfig, Get-NetAdapter
├── T1069.yaml    # net localgroup, groups
└── T1087.yaml    # net user, whoami, id

Agent Rust (src/techniques/discovery/):
├── mod.rs
├── t1082_system_info.rs
├── t1083_file_discovery.rs
├── t1057_process_discovery.rs
├── t1016_network_config.rs
├── t1069_permission_groups.rs
└── t1087_account_discovery.rs
```

**Livrables:**
- 6 fichiers YAML de definition des techniques
- Parser YAML dans le serveur
- Implementations Rust pour Windows et Linux
- Tests d'execution sur machines de test
- Documentation des commandes executees

**Definition of Done:**
[ ] 6 techniques implementees (YAML + Rust)
[ ] Executables sur Windows (psh, cmd)
[ ] Executables sur Linux (bash)
[ ] Resultats retournes correctement au serveur
[ ] Flag is_safe = true sur toutes
[ ] Tests manuels valides sur VM
[ ] Documentation des indicateurs de detection","techniques;discovery"
"EP-08: Techniques MITRE - Execution",Epic,"**Objectif:**
Implementer les techniques MITRE ATT&CK de la tactique Execution, permettant de valider les capacites d'execution de commandes et scripts.

**Scope:**
- T1059.001: PowerShell
- T1059.003: Windows Command Shell (cmd.exe)
- T1059.004: Unix Shell (bash/sh)

**Architecture:**
```
Fichiers YAML (configs/techniques/):
├── T1059.001.yaml   # PowerShell execution
├── T1059.003.yaml   # CMD execution
└── T1059.004.yaml   # Bash/Sh execution

Chaque technique teste:
- Execution basique de commandes
- Verification du mode d'execution (LanguageMode pour PSH)
- Encodage de commandes
- Execution de scripts inline

Exemple T1059.001.yaml:
executors:
  - type: psh
    command: |
      $ExecutionContext.SessionState.LanguageMode
      Get-Process | Select-Object -First 5
    timeout: 30
```

**Livrables:**
- 3 fichiers YAML de definition
- Tests de differents modes d'execution
- Detection des restrictions (Constrained Language Mode, etc.)
- Rapport du mode d'execution dans les resultats

**Definition of Done:**
[ ] T1059.001 (PowerShell) implemente et teste
[ ] T1059.003 (CMD) implemente et teste
[ ] T1059.004 (Unix Shell) implemente et teste
[ ] Detecte les restrictions d'execution
[ ] Output capture correctement (stdout/stderr)
[ ] Timeout respecte
[ ] Documentation des variations de commandes","techniques;execution"
"EP-09: Techniques MITRE - Persistence",Epic,"**Objectif:**
Implementer les techniques MITRE ATT&CK de la tactique Persistence, avec un mode safe qui cree puis supprime immediatement les artefacts.

**Scope:**
- T1053.005: Scheduled Task/Job (Windows Task Scheduler)
- T1547.001: Registry Run Keys / Startup Folder
- T1136.001: Create Local Account

**Architecture:**
```
Mode Safe Persistence:
1. Creer l'artefact (scheduled task, registry key, account)
2. Verifier que la creation a fonctionne
3. Supprimer immediatement l'artefact
4. Verifier que la suppression a fonctionne
5. Retourner le resultat (created + cleaned)

Exemple T1053.005.yaml:
executors:
  - type: psh
    command: |
      # Create task
      schtasks /create /tn ""AutoStrikeTest"" /tr ""calc.exe"" /sc daily /st 00:00
      # Verify
      schtasks /query /tn ""AutoStrikeTest""
    cleanup: |
      schtasks /delete /tn ""AutoStrikeTest"" /f
    timeout: 30
```

**Livrables:**
- 3 fichiers YAML avec commandes et cleanup
- Implementation du cleanup automatique dans l'agent
- Verification que les artefacts sont bien supprimes
- Rapport detaille (created, verified, cleaned)

**Definition of Done:**
[ ] T1053.005 (Scheduled Task) avec cleanup
[ ] T1547.001 (Registry Run Keys) avec cleanup
[ ] T1136.001 (Local Account) avec cleanup
[ ] Cleanup execute systematiquement apres le test
[ ] Verification post-cleanup dans le rapport
[ ] Tests sur VM Windows
[ ] Flag is_safe = true si cleanup garantit","techniques;persistence"
"EP-10: Techniques MITRE - Defense Evasion",Epic,"**Objectif:**
Implementer les techniques MITRE ATT&CK de la tactique Defense Evasion, permettant de tester les capacites de detection d'activites d'evasion.

**Scope:**
- T1070.004: Indicator Removal - File Deletion
- T1027: Obfuscated Files or Information

**Architecture:**
```
T1070.004 - File Deletion:
- Creer un fichier temporaire (safe)
- Supprimer le fichier
- Verifier la suppression
- Tester differentes methodes de suppression (del, Remove-Item, rm)

T1027 - Obfuscation:
- Encoder une commande en Base64
- Executer la commande encodee
- Tester la detection de l'encodage

Exemple T1070.004.yaml:
executors:
  - type: psh
    command: |
      # Create test file
      $path = ""$env:TEMP\autostrike_test.txt""
      ""test content"" | Out-File $path
      # Delete and verify
      Remove-Item $path -Force
      Test-Path $path  # Should return False
    timeout: 30
```

**Livrables:**
- 2 fichiers YAML de techniques
- Tests de differentes methodes de suppression
- Tests d'encodage Base64 (PowerShell -EncodedCommand)
- Rapport des methodes testees et resultats

**Definition of Done:**
[ ] T1070.004 (File Deletion) implemente
[ ] T1027 (Obfuscation) implemente avec Base64
[ ] Plusieurs variantes de commandes testees
[ ] Aucun fichier residuel apres execution
[ ] Documentation des indicateurs de detection
[ ] Tests sur VM Windows et Linux","techniques;defense-evasion"
"EP-11: Gestion des Scenarios",Epic,"**Objectif:**
Implementer le systeme complet de gestion des scenarios d'attaque: CRUD, organisation en phases, selection des techniques, et preparation pour l'execution.

**Scope:**
- API CRUD scenarios sur le backend
- Modele de donnees Scenario avec Phases
- UI liste des scenarios
- UI creation/edition de scenario
- Selection des techniques par phase
- Validation de la compatibilite techniques/agents
- Scenarios predefinis (Basic Recon, APT29, etc.)

**Architecture:**
```
Backend API:
GET    /api/v1/scenarios           # Liste
POST   /api/v1/scenarios           # Creer
GET    /api/v1/scenarios/:id       # Detail
PUT    /api/v1/scenarios/:id       # Modifier
DELETE /api/v1/scenarios/:id       # Supprimer

Structure Scenario:
{
  ""id"": ""uuid"",
  ""name"": ""APT29 Emulation"",
  ""description"": ""..."",
  ""phases"": [
    {
      ""name"": ""Reconnaissance"",
      ""order"": 1,
      ""techniques"": [""T1082"", ""T1083"", ""T1057""]
    },
    {
      ""name"": ""Execution"",
      ""order"": 2,
      ""techniques"": [""T1059.001""]
    }
  ]
}
```

**Livrables:**
- API CRUD complete pour les scenarios
- UI liste et formulaire de scenario
- Drag & drop pour organiser les phases
- Selection des techniques avec filtres
- 3 scenarios predefinis importes
- Validation avant execution

**Definition of Done:**
[ ] API CRUD scenarios fonctionnelle
[ ] UI liste scenarios avec actions
[ ] UI creation scenario avec phases
[ ] Selection techniques par tactic
[ ] Validation compatibilite avant exec
[ ] 3 scenarios predefinis disponibles
[ ] Tests API scenarios",scenarios
"EP-12: Orchestrateur d'Attaques",Epic,"**Objectif:**
Implementer l'orchestrateur qui planifie et coordonne l'execution des scenarios sur les agents: planning, dispatch, gestion des timeouts, et collecte des resultats.

**Scope:**
- Service AttackOrchestrator dans le domain
- Planification des taches (matching technique/agent)
- Mise en file d'attente (pending_tasks)
- Gestion des timeouts par technique
- Gestion des erreurs et retry
- Calcul de progression
- Completion et rapport final

**Architecture:**
```
Orchestration Flow:
1. ExecuteScenario(scenarioId, agentPaws[])
2. PlanExecution() -> ExecutionPlan
   - Pour chaque phase, pour chaque technique
   - Trouver agent compatible
   - Creer PlannedTask
3. Pour chaque PlannedTask:
   - Ajouter a pending_tasks
   - Attendre beacon agent
   - Agent execute et retourne resultat
4. Collecter resultats
5. Marquer execution complete
6. Calculer score final

Domain Service:
type AttackOrchestrator struct {
    agentRepo    AgentRepository
    techRepo     TechniqueRepository
    resultRepo   ResultRepository
}

func (o *AttackOrchestrator) PlanExecution(
    scenario *Scenario,
    targetAgents []*Agent,
) (*ExecutionPlan, error)
```

**Livrables:**
- Service orchestrateur dans le domain
- Algorithme de matching technique/agent
- File d'attente persistee en base
- Gestion des timeouts (skip technique si timeout)
- Endpoint pour lancer une execution
- Endpoint pour stopper une execution

**Definition of Done:**
[ ] Orchestrateur planifie correctement les taches
[ ] Taches dispatched aux bons agents
[ ] Timeout respecte (skip si depasse)
[ ] Resultats collectes et stockes
[ ] Progression calculee en temps reel
[ ] Execution peut etre stoppee
[ ] Tests unitaires orchestrateur",orchestrator
"EP-13: Matrice ATT&CK Interactive",Epic,"**Objectif:**
Creer une visualisation interactive de la matrice MITRE ATT&CK avec D3.js, affichant l'etat de couverture en couleurs et permettant l'exploration des techniques.

**Scope:**
- Composant MitreMatrix avec D3.js
- Colonnes par tactic (14 tactics)
- Cellules par technique avec couleur selon statut
- Legende des couleurs (Blocked/Detected/Success/Untested)
- Zoom et pan sur la matrice
- Click sur technique -> detail panel
- Filtres par tactic, status, platform

**Architecture:**
```
Composants React:
├── MitreMatrix.tsx      # Container principal avec D3
├── TacticColumn.tsx     # Colonne d'une tactic
├── TechniqueCell.tsx    # Cellule technique cliquable
├── HeatmapLegend.tsx    # Legende des couleurs
└── TechniqueDetails.tsx # Panel de detail

Couleurs:
- #22c55e (vert)   = Blocked   (defense a bloque)
- #f59e0b (orange) = Detected  (execute mais alerte)
- #ef4444 (rouge)  = Success   (execute sans detection)
- #6b7280 (gris)   = Untested  (pas encore teste)

Statut d'une technique:
function getTechniqueStatus(results: Result[]): Status {
  if (results.some(r => r.status === 'success')) return 'success';
  if (results.some(r => r.status === 'detected')) return 'detected';
  if (results.some(r => r.status === 'blocked')) return 'blocked';
  return 'untested';
}
```

**Livrables:**
- Matrice complete avec les 14 tactics
- Couleurs basees sur les resultats reels
- Panel de detail au click
- Filtres fonctionnels
- Export de la matrice en PNG
- Responsive (scroll horizontal)

**Definition of Done:**
[ ] Matrice affiche toutes les tactics en colonnes
[ ] Techniques colorees selon resultats
[ ] Click ouvre panel de detail
[ ] Filtres par tactic/status fonctionnent
[ ] Tooltips sur hover
[ ] Performance OK avec 200+ techniques
[ ] Export PNG fonctionne","dashboard;d3"
"EP-14: WebSocket & Temps Reel",Epic,"**Objectif:**
Implementer la communication temps reel via WebSocket pour les notifications d'evenements: nouveaux agents, progression des executions, et logs live.

**Scope:**
- Serveur WebSocket avec Gorilla WebSocket
- Hub de gestion des connexions
- Types d'evenements (agent_connected, technique_completed, etc.)
- Authentification WebSocket (JWT dans query param)
- Hook useWebSocket dans le frontend
- Notifications toast pour les evenements
- Live logs pendant l'execution

**Architecture:**
```
Backend WebSocket:
/ws/live?token=jwt

Types d'evenements:
- agent_connected
- agent_disconnected
- execution_started
- technique_started
- technique_completed
- execution_completed
- error

Payload exemple:
{
  ""type"": ""technique_completed"",
  ""timestamp"": ""2026-01-29T10:30:15Z"",
  ""payload"": {
    ""execution_id"": ""exec-001"",
    ""technique_id"": ""T1082"",
    ""agent_paw"": ""agent-001"",
    ""status"": ""success"",
    ""duration_ms"": 1523
  }
}

Frontend:
const { lastMessage, connectionStatus } = useWebSocket(
  'wss://localhost:8443/ws/live'
);
```

**Livrables:**
- Serveur WebSocket fonctionnel
- Hub avec gestion des subscriptions
- Broadcast des evenements en temps reel
- Hook React useWebSocket
- Composant de notification toast
- Indicateur de connexion WebSocket
- Live logs pendant execution

**Definition of Done:**
[ ] WebSocket server accepte connexions
[ ] Authentification JWT validee
[ ] Evenements broadcast a tous les clients
[ ] useWebSocket hook fonctionne
[ ] Notifications toast affichees
[ ] Live logs pendant execution
[ ] Reconnexion automatique si deconnexion",websocket
"EP-15: Rapports & Score",Epic,"**Objectif:**
Implementer le systeme de reporting avec calcul du score de securite, rapports de couverture, et export PDF.

**Scope:**
- Calcul du score de securite (formule: blocked*100 + detected*50 / total*100)
- Composant SecurityScore avec gauge visuelle
- Rapport de couverture par tactic
- Historique des scores (tendance)
- Export PDF du rapport
- Export JSON des resultats

**Architecture:**
```
Calcul du Score:
Score = (blocked * 100 + detected * 50) / (total_tested * 100) * 100

Exemple:
- 45 blocked -> 4500 points
- 12 detected -> 600 points
- 8 success -> 0 points
- Total: 65 techniques testees
Score = (4500 + 600) / (65 * 100) = 78%

Composants:
├── SecurityScore.tsx     # Gauge circulaire avec score
├── CoverageReport.tsx    # Couverture par tactic
├── TrendChart.tsx        # Evolution du score
├── TechniqueReport.tsx   # Detail par technique
└── ExportPDF.tsx         # Generation PDF

API Endpoints:
GET /api/v1/reports/score                 # Score actuel
GET /api/v1/reports/coverage              # Couverture par tactic
GET /api/v1/reports/history?days=30       # Historique
GET /api/v1/reports/export/pdf            # Export PDF
GET /api/v1/reports/export/json           # Export JSON
```

**Livrables:**
- API de calcul du score
- Composant gauge de score
- Rapport de couverture par tactic (bar chart)
- Graphique de tendance (line chart)
- Export PDF avec wkhtmltopdf ou puppeteer
- Export JSON des donnees

**Definition of Done:**
[ ] Score calcule selon la formule
[ ] Gauge visuelle du score
[ ] Rapport couverture par tactic
[ ] Graphique tendance sur 30 jours
[ ] Export PDF genere correctement
[ ] Export JSON complet
[ ] Tests calcul du score",reports
"EP-16: Agent Linux",Epic,"**Objectif:**
Adapter l'agent Rust pour fonctionner sur Linux (Ubuntu 20+, Debian 11+) avec les executors bash/sh et les techniques adaptees.

**Scope:**
- Cross-compilation Linux (x86_64, aarch64)
- Executor Bash fonctionnel
- Executor Sh (fallback)
- Adaptation des techniques Discovery pour Linux
- Detection de la distribution (Ubuntu, Debian, CentOS)
- Tests sur VMs Linux
- Script d'installation Linux

**Architecture:**
```
Cross-compilation targets:
- x86_64-unknown-linux-gnu      # Linux x64
- aarch64-unknown-linux-gnu     # Linux ARM64 (Raspberry Pi, etc.)

Executor Linux:
pub struct BashExecutor;

impl Executor for BashExecutor {
    fn execute(&self, command: &str, timeout: Duration) -> Result<Output> {
        Command::new(""/bin/bash"")
            .args(&[""-c"", command])
            .output()
    }
}

Techniques adaptees:
T1082 Linux: uname -a; cat /etc/os-release; hostnamectl
T1057 Linux: ps aux; top -bn1
T1016 Linux: ip addr; cat /etc/resolv.conf
T1087 Linux: cat /etc/passwd; id; groups
```

**Livrables:**
- Agent compile pour Linux x64 et ARM64
- Executor bash fonctionnel
- 6 techniques Discovery adaptees Linux
- Script d'installation one-liner Linux
- Tests sur Ubuntu 20.04 et Debian 11

**Definition of Done:**
[ ] Agent compile pour Linux x64
[ ] Agent compile pour Linux ARM64
[ ] Beacon fonctionne sur Linux
[ ] Techniques Discovery executent sur Linux
[ ] Binaire <5MB
[ ] Script install.sh fonctionne
[ ] Tests sur Ubuntu et Debian","agent;linux"
"EP-17: Profils Adversaires",Epic,"**Objectif:**
Implementer les profils adversaires (APT groups) predefinies avec leur mapping de techniques MITRE, permettant de simuler des attaquants specifiques.

**Scope:**
- Modele AdversaryProfile avec techniques associees
- Import des profils depuis MITRE ATT&CK
- API CRUD profils adversaires
- UI liste et detail des profils
- Creation de scenario depuis un profil
- 5 profils predefinis (APT29, APT28, FIN7, Lazarus, Wizard Spider)

**Architecture:**
```
Modele:
type AdversaryProfile struct {
    ID          string
    Name        string      // ""APT29 - Cozy Bear""
    Description string
    Techniques  []string    // [""T1059.001"", ""T1082"", ...]
    Country     string      // ""Russia""
    Targets     []string    // [""Government"", ""Energy""]
    References  []string    // URLs MITRE
}

Profils predefinis:
├── APT29 (Cozy Bear)    - Russia - Government targeting
├── APT28 (Fancy Bear)   - Russia - Political targeting
├── FIN7 (Carbanak)      - Financial crime
├── Lazarus Group        - North Korea - Financial
└── Wizard Spider        - Ransomware (Ryuk, Conti)

API:
GET    /api/v1/adversaries           # Liste
GET    /api/v1/adversaries/:id       # Detail avec techniques
POST   /api/v1/scenarios/from-adversary/:id  # Creer scenario
```

**Livrables:**
- Modele et table adversary_profiles
- 5 profils predefinis avec techniques reelles
- API de listing et detail
- UI avec cards des profils
- Bouton ""Creer scenario depuis ce profil""
- Lien vers la page MITRE de chaque profil

**Definition of Done:**
[ ] 5 profils predefinis en base
[ ] API listing et detail fonctionnelle
[ ] UI affiche les profils avec logo/description
[ ] Detail affiche les techniques du profil
[ ] Creation scenario depuis profil fonctionne
[ ] Techniques du profil validees avec MITRE
[ ] References MITRE incluses",adversaries
"EP-18: Tests & Qualite",Epic,"**Objectif:**
Mettre en place une suite de tests complete (unitaires, integration, E2E) avec une couverture minimale de 70% sur le code critique.

**Scope:**
- Tests unitaires Go (domain, application)
- Tests unitaires Rust (executors, beacon)
- Tests unitaires React (composants, hooks)
- Tests d'integration API (endpoints)
- Tests E2E avec Playwright
- Configuration coverage reports
- Integration dans CI/CD

**Architecture:**
```
Structure des tests:

Server (Go):
├── internal/domain/entity/*_test.go
├── internal/domain/service/*_test.go
├── internal/application/*_test.go
└── internal/infrastructure/api/rest/handlers/*_test.go

Agent (Rust):
└── src/
    ├── executor/*_test.rs
    ├── beacon/*_test.rs
    └── lib.rs (integration tests)

Dashboard (React):
├── src/components/**/*.test.tsx
├── src/hooks/*.test.ts
└── e2e/*.spec.ts (Playwright)

Coverage targets:
- Go domain layer: >80%
- Go application layer: >70%
- Rust core: >70%
- React components: >60%
- Overall: >70%
```

**Livrables:**
- Tests unitaires pour chaque composant
- Tests d'integration API
- Tests E2E scenarios critiques (login, execute scenario)
- Rapport de coverage genere par CI
- Badge coverage dans README

**Definition of Done:**
[ ] Tests Go domain >80% coverage
[ ] Tests Go application >70% coverage
[ ] Tests Rust executors couverts
[ ] Tests React composants critiques
[ ] Tests E2E login et execution scenario
[ ] CI genere rapport coverage
[ ] Coverage global >70%
[ ] Tous les tests passent en CI",tests
"EP-19: Documentation",Epic,"**Objectif:**
Creer une documentation complete: technique (API, architecture), utilisateur (guides), et developpeur (contribution).

**Scope:**
- Documentation API avec OpenAPI/Swagger
- Guide d'installation et deploiement
- Guide utilisateur (fonctionnalites)
- Guide developpeur (contribution, architecture)
- Documentation des techniques MITRE implementees
- Schemas d'architecture (diagrams)
- Changelog et release notes

**Architecture:**
```
docs/
├── api/
│   └── openapi.yaml         # Spec OpenAPI 3.0
├── architecture/
│   ├── overview.md          # Vue d'ensemble
│   ├── hexagonal.md         # Architecture hexagonale
│   └── diagrams/            # Schemas PlantUML/Mermaid
├── deployment/
│   ├── docker.md            # Deploiement Docker
│   ├── kubernetes.md        # Deploiement K8s (optionnel)
│   └── production.md        # Checklist production
├── user-guide/
│   ├── getting-started.md   # Premier pas
│   ├── scenarios.md         # Creer et executer scenarios
│   ├── agents.md            # Deployer et gerer agents
│   └── reports.md           # Comprendre les rapports
├── developer/
│   ├── contributing.md      # Guide contribution
│   ├── coding-standards.md  # Standards de code
│   └── testing.md           # Ecrire des tests
└── techniques/
    └── implementation.md    # Ajouter une technique
```

**Livrables:**
- Spec OpenAPI complete et validee
- Swagger UI accessible (/api/docs)
- Guide utilisateur 10+ pages
- Guide developpeur avec exemples
- Schemas d'architecture a jour
- README principal complet

**Definition of Done:**
[ ] OpenAPI spec couvre toutes les routes
[ ] Swagger UI fonctionne
[ ] Guide utilisateur couvre tous les use cases
[ ] Guide installation step by step
[ ] Guide contribution avec PR template
[ ] Schemas architecture a jour
[ ] README badges et quick start",docs
"EP-20: Docker & Deploiement",Epic,"**Objectif:**
Conteneuriser tous les composants et fournir une solution de deploiement complete avec Docker et docker-compose.

**Scope:**
- Dockerfile pour le Server Go (multi-stage)
- Dockerfile pour le Dashboard (nginx)
- docker-compose.yml complet (server, dashboard, db)
- Configuration nginx reverse proxy
- Variables d'environnement documentees
- Scripts de deploiement
- Health checks et restart policies

**Architecture:**
```
deployments/docker/
├── Dockerfile.server        # Multi-stage Go build
├── Dockerfile.dashboard     # Build React + nginx
├── docker-compose.yml       # Orchestration complete
├── nginx.conf               # Reverse proxy config
└── .env.example             # Variables d'environnement

docker-compose.yml:
services:
  server:
    build:
      context: ../../server
      dockerfile: ../deployments/docker/Dockerfile.server
    environment:
      - DATABASE_URL=sqlite:///data/autostrike.db
      - JWT_SECRET=${JWT_SECRET}
    volumes:
      - data:/data
    healthcheck:
      test: [""CMD"", ""curl"", ""-f"", ""http://localhost:8080/health""]

  dashboard:
    build:
      context: ../../dashboard
      dockerfile: ../deployments/docker/Dockerfile.dashboard
    depends_on:
      - server

  nginx:
    image: nginx:alpine
    ports:
      - ""443:443""
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./certs:/etc/nginx/certs
```

**Livrables:**
- Dockerfiles optimises (multi-stage, small images)
- docker-compose.yml fonctionnel
- Configuration nginx avec SSL
- Scripts start.sh et stop.sh
- Documentation deploiement
- Health checks configures

**Definition of Done:**
[ ] docker-compose up demarre tout
[ ] Server image <100MB
[ ] Dashboard image <50MB
[ ] HTTPS fonctionne via nginx
[ ] Health checks passent
[ ] Volumes persistent data
[ ] Documentation deploiement complete
[ ] .env.example documente","devops;docker"
"[US-001] Visualiser couverture MITRE ATT&CK",Story,"En tant qu'analyste SOC, je veux visualiser la couverture MITRE ATT&CK de mon SI pour identifier rapidement les lacunes de detection et prioriser les ameliorations de mes regles.

**Criteres d'acceptation:**
- [ ] La matrice MITRE ATT&CK est affichee avec toutes les tactiques (colonnes) et techniques (lignes)
- [ ] Chaque cellule est coloree selon le status: vert (bloque), jaune (detecte), rouge (non detecte), gris (non teste)
- [ ] Une legende explicative des couleurs est visible en permanence
- [ ] Au survol d'une technique, un tooltip affiche: nom, ID MITRE, description, derniere date de test
- [ ] La navigation permet zoom in/out et pan (drag) fluide
- [ ] La matrice est responsive et s'adapte aux ecrans (min 1024px)
- [ ] Le temps de chargement initial est < 3 secondes

**Regles de gestion associees:**
- RG-003: Agent heartbeat - Les donnees refletent l'etat des agents online uniquement
- RG-006: Logs immuables - L'historique des resultats ne peut etre modifie
- RG-007: Score calculation - Le score affiche utilise la formule (blocked*100 + detected*50) / (total*100)

**Definition of Done:**
- [ ] Code review approuvee par au moins 1 pair
- [ ] Tests unitaires couvrant >80% du composant
- [ ] Tests E2E validant la navigation et l'affichage
- [ ] Documentation technique du composant
- [ ] Accessibilite WCAG AA verifiee (contraste, navigation clavier, aria-labels)
- [ ] Performance testee avec >500 techniques",mvp;us;frontend
"[US-002] Score de securite global",Story,"En tant que RSSI, je veux disposer d'un score de securite global pour presenter l'etat de securite de l'entreprise a la direction et justifier les investissements.

**Criteres d'acceptation:**
- [ ] Score affiche de 0 a 100 avec indicateur visuel (jauge ou cercle de progression)
- [ ] La formule appliquee est: (blocked*100 + detected*50) / (total*100)
- [ ] Un graphique historique montre l'evolution du score sur les 30/90/365 derniers jours
- [ ] La comparaison avec le score precedent est visible (fleche up/down + delta)
- [ ] Un code couleur indique le niveau: rouge (<40), orange (40-70), vert (>70)
- [ ] Le score se rafraichit automatiquement apres chaque execution de scenario

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Seuls les utilisateurs authentifies voient le score
- RG-006: Logs immuables - L'historique des scores est conserve et non modifiable
- RG-007: Score calculation - Formule standardisee pour tous les calculs

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du calcul de score (cas nominaux et limites)
- [ ] Tests d'integration avec les donnees de resultats
- [ ] Documentation de la formule et des seuils
- [ ] Validation metier par le Product Owner
- [ ] Export des donnees possible pour reporting externe",mvp;us;dashboard
"[US-003] Lancer un scenario predefini",Story,"En tant qu'operateur, je veux lancer un scenario predefini en 1 clic pour tester rapidement mes defenses sans configuration complexe.

**Criteres d'acceptation:**
- [ ] La liste des scenarios disponibles s'affiche avec: nom, description, nombre de techniques, duree estimee
- [ ] L'operateur peut selectionner un ou plusieurs agents cibles via checkboxes
- [ ] Une modale de confirmation affiche le resume avant execution: scenario, agents, techniques
- [ ] L'execution demarre et redirige automatiquement vers la page de monitoring
- [ ] Un message d'erreur s'affiche si aucun agent n'est disponible ou compatible
- [ ] L'operateur peut annuler a tout moment (avant confirmation)

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role ""Operator"" minimum requis
- RG-003: Agent heartbeat - Seuls les agents online sont selectionnables
- RG-004: Technique safe only - En mode production, seules les techniques safe sont executees
- RG-005: Cleanup obligatoire - Le scenario doit inclure le nettoyage automatique

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires des validations (agents, permissions)
- [ ] Tests E2E du flow complet: selection -> confirmation -> redirection
- [ ] Documentation utilisateur du processus
- [ ] Gestion des erreurs et messages explicites
- [ ] Logs d'audit generes pour chaque execution",mvp;us;scenarios
"[US-004] Deployer un agent facilement",Story,"En tant qu'administrateur IT, je veux deployer un agent facilement pour ajouter rapidement des machines au perimetre de test sans processus complexe.

**Criteres d'acceptation:**
- [ ] La page affiche les options de deploiement par plateforme (Windows/Linux)
- [ ] Une commande one-liner est generee avec token d'authentification unique
- [ ] La commande est copiable en 1 clic (bouton copier avec feedback visuel)
- [ ] L'agent s'installe automatiquement et s'enregistre aupres du serveur
- [ ] Le nouvel agent apparait dans la liste < 30 secondes apres installation
- [ ] Les informations collectees incluent: hostname, IP, OS, version, username

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role ""Admin"" requis pour generer les commandes
- RG-003: Agent heartbeat - Le nouvel agent commence a envoyer des heartbeats immediatement
- Token d'installation expire apres 24h pour securite

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Scripts de deploiement testes sur Windows 10/11 et Ubuntu 20.04/22.04
- [ ] Tests d'integration de l'enregistrement automatique
- [ ] Documentation des prerequis et troubleshooting
- [ ] Securisation du token de deploiement (chiffrement, expiration)
- [ ] Logs d'audit des deploiements",mvp;us;agents
"[US-005] Voir resultats en temps reel",Story,"En tant qu'utilisateur, je veux voir les resultats en temps reel pour suivre l'execution des tests et reagir immediatement si necessaire.

**Criteres d'acceptation:**
- [ ] La connexion WebSocket est etablie automatiquement a l'ouverture de la page
- [ ] Une barre de progression indique l'avancement global (X/Y techniques)
- [ ] Les logs s'affichent en direct avec horodatage et niveau (info, warning, error)
- [ ] Chaque technique affiche son status en temps reel: pending, running, success, failed
- [ ] L'interface permet de filtrer les logs par niveau ou par technique
- [ ] En cas de deconnexion WebSocket, une reconnexion automatique est tentee

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Token JWT valide requis pour WebSocket
- RG-002: Timeout session - Deconnexion WebSocket apres 30 min d'inactivite
- RG-006: Logs immuables - Tous les logs sont persistes et non modifiables

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du parsing des messages WebSocket
- [ ] Tests d'integration WebSocket avec scenarios de reconnexion
- [ ] Performance validee: <100ms de latence pour les updates
- [ ] Documentation du protocole WebSocket
- [ ] Gestion gracieuse des erreurs de connexion",mvp;us;realtime
"[US-006] Voir liste des agents",Story,"En tant qu'operateur, je veux voir la liste des agents connectes pour connaitre mon perimetre de test et leur disponibilite.

**Criteres d'acceptation:**
- [ ] La liste affiche tous les agents avec colonnes: hostname, IP, OS, username, status, derniere connexion
- [ ] Le status est clairement visible: badge vert (online), rouge (offline), orange (heartbeat manque)
- [ ] Les actions disponibles par agent: voir details, supprimer (avec confirmation)
- [ ] Des filtres permettent de trier par: status (online/offline), plateforme (Windows/Linux)
- [ ] Une barre de recherche permet de filtrer par hostname ou IP
- [ ] Le refresh automatique met a jour les status toutes les 30 secondes

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role ""Operator"" minimum requis
- RG-003: Agent heartbeat - Agent offline apres 3 beacons manques (90 secondes)
- La suppression d'un agent est definitive et tracee

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires des filtres et de la recherche
- [ ] Tests E2E de la pagination et du tri
- [ ] Documentation des etats d'agent
- [ ] Accessibilite du tableau (navigation clavier, lecteur d'ecran)
- [ ] Performance avec >100 agents affichable sans degradation",mvp;us;agents
"[US-007] Me connecter au dashboard",Story,"En tant qu'utilisateur, je veux me connecter au dashboard pour acceder aux fonctionnalites selon mon role et mes permissions.

**Criteres d'acceptation:**
- [ ] La page de login affiche un formulaire avec champs email et mot de passe
- [ ] La validation cote client verifie le format email et la presence du mot de passe
- [ ] En cas de succes, un token JWT est stocke et l'utilisateur est redirige vers le dashboard
- [ ] En cas d'echec, un message d'erreur generique s'affiche (securite: pas de detail)
- [ ] Le token est rafraichi automatiquement avant expiration (refresh token)
- [ ] Un bouton ""Mot de passe oublie"" permet la reinitialisation (V2)

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Toute page (sauf login) requiert un token valide
- RG-002: Timeout session - Session expire apres 30 min d'inactivite
- Maximum 5 tentatives de connexion avant blocage temporaire (15 min)
- Mot de passe: minimum 12 caracteres, 1 majuscule, 1 chiffre, 1 special

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires de validation des champs
- [ ] Tests d'integration de l'authentification JWT
- [ ] Tests de securite: injection SQL, XSS, brute force
- [ ] Documentation du flow d'authentification
- [ ] Conformite RGPD: pas de logs des mots de passe",mvp;us;auth
"[US-010] Creer scenarios custom",Story,"En tant que pentester, je veux creer des scenarios custom pour tester des cas specifiques correspondant a mes missions Red Team.

**Criteres d'acceptation:**
- [ ] Une interface wizard guide la creation: nom, description, phases, techniques
- [ ] L'ajout de phases permet de structurer le scenario (Reconnaissance, Initial Access, etc.)
- [ ] Un catalogue de techniques MITRE est disponible avec recherche et filtres par tactic
- [ ] Le drag-and-drop permet de reordonner les phases et techniques
- [ ] La sauvegarde en brouillon permet de reprendre la creation plus tard
- [ ] L'edition d'un scenario existant est possible (sauf si en cours d'execution)
- [ ] Un bouton ""Dupliquer"" permet de creer une variante d'un scenario existant

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role ""Pentester"" ou ""Admin"" requis
- RG-004: Technique safe only - Un warning s'affiche pour les techniques non-safe
- RG-005: Cleanup obligatoire - Le scenario doit inclure des etapes de cleanup
- Validation: au moins 1 technique par scenario

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires de la validation du schema de scenario
- [ ] Tests E2E du flow de creation complet
- [ ] Documentation utilisateur avec exemples
- [ ] UX testee avec des utilisateurs pentesters
- [ ] Import/Export de scenarios en JSON",should-have;us;scenarios
"[US-011] Exporter rapport PDF",Story,"En tant que RSSI, je veux exporter un rapport PDF pour les audits externes et les presentations a la direction.

**Criteres d'acceptation:**
- [ ] Un bouton ""Exporter PDF"" est accessible depuis le dashboard et les resultats
- [ ] Le rapport inclut un resume executif (1 page) avec score, tendance, points cles
- [ ] Une section detaillee liste chaque technique testee avec resultat et recommandation
- [ ] La matrice MITRE est incluse en version imprimable (couleurs adaptees)
- [ ] Le rapport est genere cote serveur et telechargeable (lien temporaire 24h)
- [ ] Les options d'export permettent de selectionner la periode et le niveau de detail

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role ""RSSI"" ou ""Admin"" pour export complet
- RG-006: Logs immuables - Le rapport reflete les donnees exactes au moment de l'export
- Watermark avec date de generation et nom de l'utilisateur

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires de la generation PDF
- [ ] Tests d'integration avec differents volumes de donnees
- [ ] Template PDF valide par le Product Owner
- [ ] Performance: generation < 30 secondes pour 1000 techniques
- [ ] Accessibilite: PDF tagge pour lecteurs d'ecran",should-have;us;reporting
"[US-012] Filtrer matrice par tactic/technique",Story,"En tant qu'analyste SOC, je veux filtrer la matrice par tactic ou technique pour analyser des domaines specifiques et me concentrer sur les priorites.

**Criteres d'acceptation:**
- [ ] Un panneau lateral ou dropdown permet de selectionner les tactiques a afficher
- [ ] Une barre de recherche permet de trouver une technique par nom ou ID MITRE
- [ ] Des filtres par status (bloque/detecte/non detecte/non teste) sont disponibles
- [ ] Les filtres sont combinables (AND): tactic + status + recherche
- [ ] Un bouton ""Reset filtres"" remet la vue par defaut
- [ ] L'URL reflette les filtres actifs (partage de vue possible)

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Tout utilisateur authentifie peut filtrer
- Les filtres sont persistes dans le localStorage pour conserver les preferences
- La matrice filtrée affiche le nombre de resultats correspondants

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires de chaque type de filtre
- [ ] Tests E2E des combinaisons de filtres
- [ ] Performance: filtrage < 200ms pour 500 techniques
- [ ] Documentation des options de filtrage
- [ ] Accessibilite: filtres utilisables au clavier",should-have;us;frontend
"[US-020] Utiliser profils adversaires APT",Story,"En tant qu'utilisateur, je veux utiliser des profils adversaires APT predefinis pour simuler des attaques realistes basees sur des groupes connus.

**Criteres d'acceptation:**
- [ ] Une liste de profils APT est disponible: APT29, APT28, Lazarus, FIN7, etc.
- [ ] Chaque profil affiche: nom, description, pays d'origine, secteurs cibles
- [ ] Les techniques MITRE associees au profil sont listees avec sources (MITRE ATT&CK)
- [ ] Un bouton ""Generer scenario"" cree automatiquement un scenario depuis le profil
- [ ] Le scenario genere est editable avant execution
- [ ] Les profils sont mis a jour periodiquement depuis les sources MITRE

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role ""Operator"" minimum requis
- RG-004: Technique safe only - Warning si le profil inclut des techniques non-safe
- Les profils sont en lecture seule (source MITRE), seuls les scenarios generes sont editables

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires de la generation de scenario depuis profil
- [ ] Donnees APT synchronisees depuis MITRE ATT&CK (API ou fichiers)
- [ ] Documentation des profils disponibles
- [ ] UX validee: flow profil -> scenario -> execution
- [ ] Au moins 10 profils APT disponibles au lancement",could-have;us;scenarios
"[SETUP] Initialiser repository Git - structure, .gitignore, README",Task,"## Objectif
Initialiser le repository Git AutoStrike avec la structure de projet complète, les fichiers de configuration essentiels et la documentation de base.

## Contexte
AutoStrike est une plateforme de Breach and Attack Simulation (BAS) composee de 3 composants principaux:
- **server/** : Control Server en Go (Gin, architecture hexagonale)
- **agent/** : Agent en Rust (execution techniques MITRE)
- **dashboard/** : Frontend React + TypeScript + TailwindCSS

## Fichiers et Configuration

### Structure des repertoires
\`\`\`
autostrike/
├── server/
│   ├── cmd/autostrike/
│   ├── internal/
│   │   ├── domain/
│   │   ├── application/
│   │   └── infrastructure/
│   ├── pkg/
│   ├── configs/
│   ├── go.mod
│   └── Makefile
├── agent/
│   ├── src/
│   ├── Cargo.toml
│   └── build.rs
├── dashboard/
│   ├── src/
│   ├── public/
│   ├── package.json
│   └── vite.config.ts
├── docs/
├── deployments/
│   ├── docker/
│   └── kubernetes/
├── scripts/
├── .github/
│   └── workflows/
├── .gitignore
├── README.md
├── LICENSE
└── Makefile
\`\`\`

### .gitignore
\`\`\`gitignore
# Go
server/bin/
server/*.exe
*.test
*.out
vendor/

# Rust
agent/target/
agent/**/*.rs.bk

# Node/React
dashboard/node_modules/
dashboard/dist/
dashboard/build/
dashboard/.env.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Secrets
*.pem
*.key
.env
.env.*
!.env.example

# Database
*.db
*.sqlite

# Logs
*.log
logs/
\`\`\`

### README.md
- Presentation projet AutoStrike (BAS platform)
- Stack technologique (Go, Rust, React)
- Badges CI/CD, SonarCloud, License
- Quick start guide
- Lien vers documentation MkDocs

## Definition of Done
- [ ] Repository initialise avec structure complete
- [ ] .gitignore couvre Go, Rust, Node, IDE, secrets
- [ ] README.md avec presentation, badges, quick start
- [ ] LICENSE MIT presente
- [ ] Makefile racine avec targets: build, test, lint, clean
- [ ] Branch main protegee (apres PR merge)
- [ ] Premier commit signe et pushe","setup;documentation;infrastructure"
"[SETUP] Configurer GitHub Actions CI - workflows build/test/lint Go, React, Rust",Task,"## Objectif
Mettre en place les pipelines CI/CD GitHub Actions pour automatiser le build, les tests et le linting des 3 composants du projet AutoStrike.

## Contexte
AutoStrike utilise 3 technologies differentes necessitant des workflows CI separes:
- **Go** (server): build, test, golangci-lint
- **React/TypeScript** (dashboard): build, test, ESLint
- **Rust** (agent): build, test, clippy, cross-compilation Windows/Linux

## Fichiers et Configuration

### .github/workflows/server.yml
\`\`\`yaml
name: Server CI

on:
  push:
    branches: [main, develop]
    paths: ['server/**']
  pull_request:
    branches: [main]
    paths: ['server/**']

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: server
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.21'
          cache-dependency-path: server/go.sum
      - name: Build
        run: go build -v ./...
      - name: Test
        run: go test -v -race -coverprofile=coverage.out ./...
      - name: Upload coverage
        uses: codecov/codecov-action@v4

  lint:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: server
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      - uses: golangci/golangci-lint-action@v4
        with:
          version: latest
          working-directory: server
\`\`\`

### .github/workflows/dashboard.yml
\`\`\`yaml
name: Dashboard CI

on:
  push:
    branches: [main, develop]
    paths: ['dashboard/**']
  pull_request:
    branches: [main]
    paths: ['dashboard/**']

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: dashboard
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: dashboard/package-lock.json
      - run: npm ci
      - run: npm run lint
      - run: npm run build
      - run: npm test -- --coverage
\`\`\`

### .github/workflows/agent.yml
\`\`\`yaml
name: Agent CI

on:
  push:
    branches: [main, develop]
    paths: ['agent/**']
  pull_request:
    branches: [main]
    paths: ['agent/**']

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: agent
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt
      - uses: Swatinem/rust-cache@v2
        with:
          workspaces: agent
      - name: Check format
        run: cargo fmt --check
      - name: Clippy
        run: cargo clippy -- -D warnings
      - name: Build
        run: cargo build --release
      - name: Test
        run: cargo test

  cross-compile:
    runs-on: ubuntu-latest
    needs: build
    strategy:
      matrix:
        target: [x86_64-pc-windows-gnu, x86_64-unknown-linux-gnu]
    defaults:
      run:
        working-directory: agent
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: \${{ matrix.target }}
      - name: Install cross-compilation deps
        run: sudo apt-get install -y mingw-w64
        if: contains(matrix.target, 'windows')
      - name: Build
        run: cargo build --release --target \${{ matrix.target }}
\`\`\`

## Definition of Done
- [ ] Workflow server.yml: build Go 1.21, tests avec coverage, golangci-lint
- [ ] Workflow dashboard.yml: npm ci, ESLint, build Vite, tests Jest
- [ ] Workflow agent.yml: cargo build/test, clippy, rustfmt check
- [ ] Cross-compilation agent Windows/Linux fonctionnelle
- [ ] Workflows declenchent sur push main/develop et PR
- [ ] Path filtering actif (chaque workflow reagit a son dossier)
- [ ] Cache dependencies configure (Go, npm, Cargo)
- [ ] Badges CI ajoutees au README","setup;ci-cd;automation"
"[SETUP] Configurer SonarCloud - token, sonar-project.properties",Task,"## Objectif
Integrer SonarCloud pour l'analyse statique de code, le suivi de la qualite et la detection des vulnerabilites sur les 3 composants AutoStrike.

## Contexte
SonarCloud analysera:
- **Go** (server): bugs, code smells, security hotspots
- **TypeScript/React** (dashboard): qualite code, duplications
- **Rust** (agent): via sonar-scanner generique

## Fichiers et Configuration

### sonar-project.properties (racine)
\`\`\`properties
sonar.projectKey=autostrike_autostrike
sonar.organization=autostrike

sonar.projectName=AutoStrike
sonar.projectVersion=1.0.0

# Sources multi-modules
sonar.sources=server,dashboard/src,agent/src
sonar.exclusions=**/node_modules/**,**/vendor/**,**/target/**,**/*_test.go,**/*.spec.ts

# Go coverage
sonar.go.coverage.reportPaths=server/coverage.out

# TypeScript/JavaScript
sonar.typescript.lcov.reportPaths=dashboard/coverage/lcov.info
sonar.javascript.lcov.reportPaths=dashboard/coverage/lcov.info

# Tests
sonar.tests=server,dashboard/src,agent/src
sonar.test.inclusions=**/*_test.go,**/*.spec.ts,**/*.test.ts,**/*_test.rs

# Quality Gate
sonar.qualitygate.wait=true
\`\`\`

### .github/workflows/sonarcloud.yml
\`\`\`yaml
name: SonarCloud Analysis

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  sonarcloud:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Build Go et generer coverage
      - uses: actions/setup-go@v5
        with:
          go-version: '1.21'
      - name: Go tests with coverage
        working-directory: server
        run: go test -coverprofile=coverage.out ./...

      # Build React et generer coverage
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - name: Install and test dashboard
        working-directory: dashboard
        run: |
          npm ci
          npm test -- --coverage

      # SonarCloud scan
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: \${{ secrets.SONAR_TOKEN }}
\`\`\`

### Configuration secrets GitHub
1. Creer projet sur sonarcloud.io
2. Generer SONAR_TOKEN dans SonarCloud > My Account > Security
3. Ajouter secret dans GitHub > Settings > Secrets > SONAR_TOKEN

### Quality Gate recommande
- Coverage minimum: 60%
- Duplications maximum: 3%
- Maintainability Rating: A
- Reliability Rating: A
- Security Rating: A
- Security Hotspots reviewed: 100%

## Definition of Done
- [ ] Projet cree sur sonarcloud.io avec organization
- [ ] sonar-project.properties configure multi-modules
- [ ] Secret SONAR_TOKEN ajoute dans GitHub
- [ ] Workflow sonarcloud.yml execute avec succes
- [ ] Coverage Go et TypeScript remonte correctement
- [ ] Quality Gate configure avec seuils definis
- [ ] Badge SonarCloud ajoute au README
- [ ] PR decoration active (commentaires SonarCloud sur PR)","setup;quality;security"
"[SETUP] Configurer Dependabot - dependances Go, npm, Cargo",Task,"## Objectif
Configurer Dependabot pour automatiser les mises a jour de securite et de maintenance des dependances sur les 3 ecosystemes du projet AutoStrike.

## Contexte
AutoStrike utilise 3 gestionnaires de packages:
- **Go modules** (server/go.mod)
- **npm** (dashboard/package.json)
- **Cargo** (agent/Cargo.toml)

## Fichiers et Configuration

### .github/dependabot.yml
\`\`\`yaml
version: 2
updates:
  # Go dependencies
  - package-ecosystem: ""gomod""
    directory: ""/server""
    schedule:
      interval: ""weekly""
      day: ""monday""
      time: ""09:00""
      timezone: ""Europe/Paris""
    open-pull-requests-limit: 5
    reviewers:
      - ""autostrike/backend-team""
    labels:
      - ""dependencies""
      - ""go""
    commit-message:
      prefix: ""deps(go):""
    groups:
      go-minor:
        patterns:
          - ""*""
        update-types:
          - ""minor""
          - ""patch""

  # npm dependencies
  - package-ecosystem: ""npm""
    directory: ""/dashboard""
    schedule:
      interval: ""weekly""
      day: ""monday""
      time: ""09:00""
      timezone: ""Europe/Paris""
    open-pull-requests-limit: 5
    reviewers:
      - ""autostrike/frontend-team""
    labels:
      - ""dependencies""
      - ""npm""
    commit-message:
      prefix: ""deps(npm):""
    groups:
      react-ecosystem:
        patterns:
          - ""react*""
          - ""@types/react*""
      dev-dependencies:
        dependency-type: ""development""
        patterns:
          - ""*""
    ignore:
      # Major versions review manuellement
      - dependency-name: ""*""
        update-types: [""version-update:semver-major""]

  # Cargo dependencies
  - package-ecosystem: ""cargo""
    directory: ""/agent""
    schedule:
      interval: ""weekly""
      day: ""monday""
      time: ""09:00""
      timezone: ""Europe/Paris""
    open-pull-requests-limit: 5
    reviewers:
      - ""autostrike/agent-team""
    labels:
      - ""dependencies""
      - ""rust""
    commit-message:
      prefix: ""deps(rust):""
    groups:
      rust-minor:
        patterns:
          - ""*""
        update-types:
          - ""minor""
          - ""patch""

  # GitHub Actions
  - package-ecosystem: ""github-actions""
    directory: ""/""
    schedule:
      interval: ""weekly""
    labels:
      - ""dependencies""
      - ""ci-cd""
    commit-message:
      prefix: ""deps(actions):""
\`\`\`

### Strategie de grouping
- **Minor/Patch**: groupes ensemble pour reduire le bruit
- **Major**: PR separees pour review approfondi
- **Dev dependencies**: groupees separement
- **GitHub Actions**: updates automatiques

### Workflow auto-merge (optionnel)
\`\`\`yaml
# .github/workflows/dependabot-automerge.yml
name: Dependabot Auto-merge

on: pull_request

permissions:
  contents: write
  pull-requests: write

jobs:
  automerge:
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    steps:
      - uses: dependabot/fetch-metadata@v2
        id: metadata
      - name: Auto-merge minor/patch updates
        if: steps.metadata.outputs.update-type == 'version-update:semver-minor' || steps.metadata.outputs.update-type == 'version-update:semver-patch'
        run: gh pr merge --auto --squash ""$PR_URL""
        env:
          PR_URL: \${{github.event.pull_request.html_url}}
          GH_TOKEN: \${{secrets.GITHUB_TOKEN}}
\`\`\`

## Definition of Done
- [ ] Fichier .github/dependabot.yml cree et valide
- [ ] Configuration gomod pour server/
- [ ] Configuration npm pour dashboard/
- [ ] Configuration cargo pour agent/
- [ ] Configuration github-actions pour workflows
- [ ] Schedule weekly lundi 9h Paris
- [ ] Grouping minor/patch configure
- [ ] Labels automatiques (dependencies, go/npm/rust)
- [ ] Reviewers assignes par ecosysteme
- [ ] Premiere execution Dependabot reussie","setup;security;dependencies"
"[SETUP] Configurer MkDocs - Material theme, GitHub Pages",Task,"## Objectif
Deployer une documentation technique complete avec MkDocs Material theme, hebergee sur GitHub Pages, couvrant l'architecture, les APIs et les guides d'utilisation AutoStrike.

## Contexte
La documentation AutoStrike doit couvrir:
- Architecture hexagonale du serveur Go
- API REST OpenAPI specification
- Guide de deploiement Docker/Kubernetes
- Guide d'implementation des techniques MITRE

## Fichiers et Configuration

### Structure docs/
\`\`\`
docs/
├── index.md
├── getting-started/
│   ├── installation.md
│   ├── quick-start.md
│   └── configuration.md
├── architecture/
│   ├── overview.md
│   ├── hexagonal.md
│   ├── server.md
│   ├── agent.md
│   └── dashboard.md
├── api/
│   ├── rest-api.md
│   └── websocket.md
├── techniques/
│   ├── mitre-mapping.md
│   └── implementation-guide.md
├── deployment/
│   ├── docker.md
│   └── kubernetes.md
├── contributing/
│   ├── code-style.md
│   └── pull-requests.md
└── assets/
    ├── images/
    └── diagrams/
\`\`\`

### mkdocs.yml (racine)
\`\`\`yaml
site_name: AutoStrike Documentation
site_url: https://autostrike.github.io/autostrike
site_description: Breach and Attack Simulation Platform
site_author: AutoStrike Team

repo_name: autostrike/autostrike
repo_url: https://github.com/autostrike/autostrike
edit_uri: edit/main/docs/

theme:
  name: material
  language: fr
  palette:
    - media: ""(prefers-color-scheme: light)""
      scheme: default
      primary: indigo
      accent: deep purple
      toggle:
        icon: material/brightness-7
        name: Mode sombre
    - media: ""(prefers-color-scheme: dark)""
      scheme: slate
      primary: indigo
      accent: deep purple
      toggle:
        icon: material/brightness-4
        name: Mode clair
  features:
    - navigation.tabs
    - navigation.sections
    - navigation.expand
    - navigation.top
    - search.suggest
    - search.highlight
    - content.code.copy
    - content.action.edit
  icon:
    repo: fontawesome/brands/github

plugins:
  - search:
      lang: fr
  - minify:
      minify_html: true

markdown_extensions:
  - admonition
  - pymdownx.details
  - pymdownx.superfences:
      custom_fences:
        - name: mermaid
          class: mermaid
          format: !!python/name:pymdownx.superfences.fence_code_format
  - pymdownx.tabbed:
      alternate_style: true
  - pymdownx.highlight:
      anchor_linenums: true
  - pymdownx.inlinehilite
  - pymdownx.snippets
  - attr_list
  - md_in_html
  - tables
  - toc:
      permalink: true

nav:
  - Accueil: index.md
  - Demarrage:
    - Installation: getting-started/installation.md
    - Quick Start: getting-started/quick-start.md
    - Configuration: getting-started/configuration.md
  - Architecture:
    - Vue d'ensemble: architecture/overview.md
    - Architecture Hexagonale: architecture/hexagonal.md
    - Control Server: architecture/server.md
    - Agent: architecture/agent.md
    - Dashboard: architecture/dashboard.md
  - API:
    - REST API: api/rest-api.md
    - WebSocket: api/websocket.md
  - Techniques MITRE:
    - Mapping: techniques/mitre-mapping.md
    - Implementation: techniques/implementation-guide.md
  - Deploiement:
    - Docker: deployment/docker.md
    - Kubernetes: deployment/kubernetes.md
  - Contribuer:
    - Code Style: contributing/code-style.md
    - Pull Requests: contributing/pull-requests.md

extra:
  social:
    - icon: fontawesome/brands/github
      link: https://github.com/autostrike
  version:
    provider: mike

copyright: Copyright 2026 AutoStrike Team - MIT License
\`\`\`

### .github/workflows/docs.yml
\`\`\`yaml
name: Deploy Documentation

on:
  push:
    branches: [main]
    paths: ['docs/**', 'mkdocs.yml']
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install MkDocs
        run: |
          pip install mkdocs-material
          pip install mkdocs-minify-plugin
          pip install pymdown-extensions
      - name: Build docs
        run: mkdocs build --strict
      - uses: actions/upload-pages-artifact@v3
        with:
          path: site

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: \${{ steps.deployment.outputs.page_url }}
    steps:
      - uses: actions/deploy-pages@v4
        id: deployment
\`\`\`

### Configuration GitHub Pages
1. Settings > Pages > Source: GitHub Actions
2. Custom domain (optionnel): docs.autostrike.io

## Definition of Done
- [ ] Structure docs/ creee avec fichiers .md initiaux
- [ ] mkdocs.yml configure avec Material theme
- [ ] Dark/Light mode toggle fonctionnel
- [ ] Navigation par onglets configure
- [ ] Workflow docs.yml deploie sur GitHub Pages
- [ ] Search fonctionnel en francais
- [ ] Syntax highlighting pour Go, Rust, TypeScript
- [ ] Diagrammes Mermaid supportes
- [ ] Lien documentation ajoute au README
- [ ] Site accessible sur github.io","setup;documentation;automation"
"[SETUP] Configurer branch protection - PR reviews, status checks",Task,"## Objectif
Mettre en place les regles de protection de branche pour garantir la qualite du code et la securite du workflow de developpement sur le repository AutoStrike.

## Contexte
Protection requise pour:
- **main**: branche de production, protection maximale
- **develop**: branche d'integration, protection standard

## Configuration

### Protection branche main

#### Regles via GitHub UI (Settings > Branches > Add rule)

**Branch name pattern**: \`main\`

**Protect matching branches**:
- [x] Require a pull request before merging
  - [x] Require approvals: 1
  - [x] Dismiss stale pull request approvals when new commits are pushed
  - [x] Require review from Code Owners
  - [x] Require approval of the most recent reviewable push
- [x] Require status checks to pass before merging
  - [x] Require branches to be up to date before merging
  - Required status checks:
    - \`Server CI / build\`
    - \`Server CI / lint\`
    - \`Dashboard CI / build\`
    - \`Agent CI / build\`
    - \`SonarCloud Analysis / sonarcloud\`
- [x] Require conversation resolution before merging
- [x] Require signed commits
- [x] Require linear history
- [ ] Include administrators (desactiver pour urgences)
- [x] Restrict who can push to matching branches
  - Only allow: autostrike/maintainers

**Rules applied to everyone including administrators**:
- [x] Allow force pushes: Disabled
- [x] Allow deletions: Disabled

### Protection branche develop

**Branch name pattern**: \`develop\`

- [x] Require a pull request before merging
  - [x] Require approvals: 1
- [x] Require status checks to pass before merging
  - Required status checks (selon les fichiers modifies):
    - \`Server CI / build\`
    - \`Dashboard CI / build\`
    - \`Agent CI / build\`
- [x] Require conversation resolution before merging
- [ ] Require signed commits (optionnel)
- [x] Allow force pushes: Disabled
- [x] Allow deletions: Disabled

### CODEOWNERS file

\`\`\`
# .github/CODEOWNERS

# Global owners
* @autostrike/maintainers

# Server (Go)
/server/ @autostrike/backend-team

# Dashboard (React)
/dashboard/ @autostrike/frontend-team

# Agent (Rust)
/agent/ @autostrike/agent-team

# CI/CD
/.github/ @autostrike/devops-team

# Documentation
/docs/ @autostrike/docs-team
/mkdocs.yml @autostrike/docs-team

# Security-sensitive files
/server/pkg/crypto/ @autostrike/security-team
/agent/src/techniques/ @autostrike/security-team
\`\`\`

### Configuration via GitHub CLI (optionnel)

\`\`\`bash
# Protection main branch
gh api repos/{owner}/{repo}/branches/main/protection -X PUT \\
  -H ""Accept: application/vnd.github+json"" \\
  -f required_status_checks='{ ""strict"": true, ""contexts"": [""Server CI / build"", ""Dashboard CI / build"", ""Agent CI / build"", ""SonarCloud Analysis / sonarcloud""] }' \\
  -f enforce_admins=false \\
  -f required_pull_request_reviews='{ ""dismiss_stale_reviews"": true, ""require_code_owner_reviews"": true, ""required_approving_review_count"": 1 }' \\
  -f restrictions=null \\
  -f required_linear_history=true \\
  -f allow_force_pushes=false \\
  -f allow_deletions=false
\`\`\`

### Teams a creer
1. **@autostrike/maintainers** - Acces admin complet
2. **@autostrike/backend-team** - Owners server/
3. **@autostrike/frontend-team** - Owners dashboard/
4. **@autostrike/agent-team** - Owners agent/
5. **@autostrike/devops-team** - Owners .github/
6. **@autostrike/security-team** - Review code sensible

## Definition of Done
- [ ] Branch protection main configuree avec toutes les regles
- [ ] Branch protection develop configuree
- [ ] Fichier CODEOWNERS cree avec ownership par composant
- [ ] Teams GitHub crees et membres ajoutes
- [ ] Status checks requis correspondent aux workflows CI
- [ ] Signed commits requis sur main
- [ ] Linear history active (pas de merge commits)
- [ ] Force push et delete branches desactives
- [ ] Test: PR sans approval est bloquee
- [ ] Test: PR avec CI failing est bloquee","setup;security;workflow"
"BE-01: Init projet Go avec Gin",Task,"**Objectif**
Initialiser le projet Go pour le Control Server AutoStrike avec le framework Gin et l'architecture hexagonale.

**Code Go exemple**
\`\`\`go
// cmd/autostrike/main.go
package main

import (
    ""log""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/infrastructure/api/rest""
)

func main() {
    // Initialiser Gin
    r := gin.Default()

    // Setup routes
    rest.SetupRouter(r)

    // Demarrer le serveur
    log.Println(""AutoStrike Server starting on :8443"")
    if err := r.Run("":8443""); err != nil {
        log.Fatal(""Failed to start server:"", err)
    }
}
\`\`\`

\`\`\`go
// internal/infrastructure/api/rest/router.go
package rest

import ""github.com/gin-gonic/gin""

func SetupRouter(r *gin.Engine) {
    api := r.Group(""/api/v1"")
    {
        api.GET(""/health"", healthHandler)
    }
}

func healthHandler(c *gin.Context) {
    c.JSON(200, gin.H{""status"": ""ok""})
}
\`\`\`

**Fichiers**
- server/cmd/autostrike/main.go
- server/internal/infrastructure/api/rest/router.go
- server/go.mod
- server/go.sum
- server/Makefile

**Definition of Done**
- [ ] Structure de repertoires hexagonale creee (cmd/, internal/domain/, internal/application/, internal/infrastructure/)
- [ ] go.mod initialise avec module autostrike
- [ ] Dependance Gin ajoutee (github.com/gin-gonic/gin)
- [ ] Point d'entree main.go fonctionnel
- [ ] Route /api/v1/health retourne 200 OK
- [ ] Makefile avec targets build, run, test
- [ ] go build sans erreurs",backend;go;setup;hexagonal
"BE-02: Configurer Viper (config.yaml et env vars)",Task,"**Objectif**
Configurer Viper pour gerer la configuration de l'application via fichier YAML et variables d'environnement.

**Code Go exemple**
\`\`\`go
// internal/infrastructure/config/config.go
package config

import (
    ""github.com/spf13/viper""
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Agent    AgentConfig
}

type ServerConfig struct {
    Port     int    \`mapstructure:""port""\`
    Host     string \`mapstructure:""host""\`
    TLSCert  string \`mapstructure:""tls_cert""\`
    TLSKey   string \`mapstructure:""tls_key""\`
}

type DatabaseConfig struct {
    Driver string \`mapstructure:""driver""\`
    DSN    string \`mapstructure:""dsn""\`
}

type AgentConfig struct {
    BeaconTimeout int \`mapstructure:""beacon_timeout""\`
    MaxAgents     int \`mapstructure:""max_agents""\`
}

func Load() (*Config, error) {
    viper.SetConfigName(""config"")
    viper.SetConfigType(""yaml"")
    viper.AddConfigPath(""./configs"")
    viper.AddConfigPath(""."")

    // Variables d'environnement
    viper.SetEnvPrefix(""AUTOSTRIKE"")
    viper.AutomaticEnv()

    // Valeurs par defaut
    viper.SetDefault(""server.port"", 8443)
    viper.SetDefault(""server.host"", ""0.0.0.0"")
    viper.SetDefault(""database.driver"", ""sqlite"")
    viper.SetDefault(""database.dsn"", ""autostrike.db"")
    viper.SetDefault(""agent.beacon_timeout"", 30)
    viper.SetDefault(""agent.max_agents"", 100)

    if err := viper.ReadInConfig(); err != nil {
        if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
            return nil, err
        }
    }

    var cfg Config
    if err := viper.Unmarshal(&cfg); err != nil {
        return nil, err
    }

    return &cfg, nil
}
\`\`\`

**Fichiers**
- server/internal/infrastructure/config/config.go
- server/configs/config.yaml
- server/configs/config.example.yaml

**Definition of Done**
- [ ] Dependance Viper ajoutee (github.com/spf13/viper)
- [ ] Struct Config avec sous-structs Server, Database, Agent
- [ ] Fichier config.yaml avec valeurs par defaut
- [ ] Support des variables d'environnement (prefixe AUTOSTRIKE_)
- [ ] Fonction Load() retourne Config ou erreur
- [ ] Tests unitaires pour Load()
- [ ] config.example.yaml documente",backend;go;config;viper
"BE-03: Configurer logger Zap",Task,"**Objectif**
Configurer le logger Zap pour une journalisation structuree et performante dans l'application.

**Code Go exemple**
\`\`\`go
// internal/infrastructure/logger/logger.go
package logger

import (
    ""os""
    ""go.uber.org/zap""
    ""go.uber.org/zap/zapcore""
)

var Log *zap.Logger

func Init(env string) error {
    var config zap.Config

    if env == ""production"" {
        config = zap.NewProductionConfig()
        config.EncoderConfig.TimeKey = ""timestamp""
        config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
    } else {
        config = zap.NewDevelopmentConfig()
        config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
    }

    config.OutputPaths = []string{""stdout""}
    if logFile := os.Getenv(""AUTOSTRIKE_LOG_FILE""); logFile != """" {
        config.OutputPaths = append(config.OutputPaths, logFile)
    }

    var err error
    Log, err = config.Build()
    if err != nil {
        return err
    }

    return nil
}

func Info(msg string, fields ...zap.Field) {
    Log.Info(msg, fields...)
}

func Error(msg string, fields ...zap.Field) {
    Log.Error(msg, fields...)
}

func Debug(msg string, fields ...zap.Field) {
    Log.Debug(msg, fields...)
}

func Warn(msg string, fields ...zap.Field) {
    Log.Warn(msg, fields...)
}

func WithContext(fields ...zap.Field) *zap.Logger {
    return Log.With(fields...)
}

func Sync() {
    _ = Log.Sync()
}
\`\`\`

\`\`\`go
// internal/infrastructure/api/rest/middleware/logging.go
package middleware

import (
    ""time""
    ""github.com/gin-gonic/gin""
    ""go.uber.org/zap""
    ""autostrike/internal/infrastructure/logger""
)

func LoggingMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        path := c.Request.URL.Path

        c.Next()

        logger.Info(""HTTP Request"",
            zap.String(""method"", c.Request.Method),
            zap.String(""path"", path),
            zap.Int(""status"", c.Writer.Status()),
            zap.Duration(""latency"", time.Since(start)),
            zap.String(""ip"", c.ClientIP()),
        )
    }
}
\`\`\`

**Fichiers**
- server/internal/infrastructure/logger/logger.go
- server/internal/infrastructure/api/rest/middleware/logging.go

**Definition of Done**
- [ ] Dependance Zap ajoutee (go.uber.org/zap)
- [ ] Logger global initialise au demarrage
- [ ] Mode development avec couleurs
- [ ] Mode production avec JSON structure
- [ ] Middleware Gin pour logger les requetes HTTP
- [ ] Fonctions helper (Info, Error, Debug, Warn)
- [ ] Support fichier de log optionnel
- [ ] Tests unitaires",backend;go;logging;zap
"BE-04: Creer entity Agent",Task,"**Objectif**
Creer l'entite Agent du domaine metier representant un agent deploye sur une machine cible.

**Code Go exemple**
\`\`\`go
// internal/domain/entity/agent.go
package entity

import ""time""

type AgentStatus string

const (
    AgentOnline    AgentStatus = ""online""
    AgentOffline   AgentStatus = ""offline""
    AgentBusy      AgentStatus = ""busy""
    AgentUntrusted AgentStatus = ""untrusted""
)

type Agent struct {
    Paw       string            \`json:""paw""\`        // Identifiant unique
    Hostname  string            \`json:""hostname""\`
    Platform  string            \`json:""platform""\`   // ""windows"", ""linux"", ""darwin""
    Username  string            \`json:""username""\`
    Executors []string          \`json:""executors""\`  // [""psh"", ""cmd"", ""bash""]
    Status    AgentStatus       \`json:""status""\`
    LastSeen  time.Time         \`json:""last_seen""\`
    IPAddress string            \`json:""ip_address""\`
    OSVersion string            \`json:""os_version""\`
    Metadata  map[string]string \`json:""metadata""\`
    CreatedAt time.Time         \`json:""created_at""\`
    UpdatedAt time.Time         \`json:""updated_at""\`
}

func NewAgent(paw, hostname, platform, username string) *Agent {
    now := time.Now()
    return &Agent{
        Paw:       paw,
        Hostname:  hostname,
        Platform:  platform,
        Username:  username,
        Executors: []string{},
        Status:    AgentOnline,
        LastSeen:  now,
        Metadata:  make(map[string]string),
        CreatedAt: now,
        UpdatedAt: now,
    }
}

func (a *Agent) IsOnline() bool {
    return a.Status == AgentOnline
}

func (a *Agent) UpdateLastSeen() {
    a.LastSeen = time.Now()
    a.UpdatedAt = time.Now()
}

func (a *Agent) SetStatus(status AgentStatus) {
    a.Status = status
    a.UpdatedAt = time.Now()
}

func (a *Agent) HasExecutor(executor string) bool {
    for _, e := range a.Executors {
        if e == executor {
            return true
        }
    }
    return false
}

func (a *Agent) IsCompatibleWith(technique *Technique) bool {
    for _, platform := range technique.Platforms {
        if platform == a.Platform {
            for _, executor := range technique.Executors {
                if a.HasExecutor(executor.Type) {
                    return true
                }
            }
        }
    }
    return false
}
\`\`\`

**Fichiers**
- server/internal/domain/entity/agent.go
- server/internal/domain/entity/agent_test.go

**Definition of Done**
- [ ] Struct Agent avec tous les champs documentes
- [ ] Type AgentStatus avec constantes (online, offline, busy, untrusted)
- [ ] Constructeur NewAgent()
- [ ] Methode IsOnline()
- [ ] Methode UpdateLastSeen()
- [ ] Methode SetStatus()
- [ ] Methode HasExecutor()
- [ ] Methode IsCompatibleWith()
- [ ] Tests unitaires couvrant toutes les methodes
- [ ] Tags JSON sur tous les champs",backend;go;domain;entity
"BE-05: Creer entity Technique",Task,"**Objectif**
Creer l'entite Technique du domaine representant une technique MITRE ATT&CK executable.

**Code Go exemple**
\`\`\`go
// internal/domain/entity/technique.go
package entity

type TacticType string

const (
    TacticReconnaissance      TacticType = ""reconnaissance""
    TacticResourceDevelopment TacticType = ""resource-development""
    TacticInitialAccess       TacticType = ""initial-access""
    TacticExecution           TacticType = ""execution""
    TacticPersistence         TacticType = ""persistence""
    TacticPrivilegeEscalation TacticType = ""privilege-escalation""
    TacticDefenseEvasion      TacticType = ""defense-evasion""
    TacticCredentialAccess    TacticType = ""credential-access""
    TacticDiscovery           TacticType = ""discovery""
    TacticLateralMovement     TacticType = ""lateral-movement""
    TacticCollection          TacticType = ""collection""
    TacticCommandAndControl   TacticType = ""command-and-control""
    TacticExfiltration        TacticType = ""exfiltration""
    TacticImpact              TacticType = ""impact""
)

type Technique struct {
    ID          string     \`json:""id""\`          // ""T1059.001""
    Name        string     \`json:""name""\`        // ""PowerShell""
    Tactic      TacticType \`json:""tactic""\`
    Description string     \`json:""description""\`
    Platforms   []string   \`json:""platforms""\`   // [""windows"", ""linux""]
    Executors   []Executor \`json:""executors""\`
    Detection   []Detection \`json:""detection""\`
    References  []string   \`json:""references""\`
    IsSafe      bool       \`json:""is_safe""\`     // Ne cause pas de dommages
}

type Executor struct {
    Type    string \`json:""type""\`    // ""psh"", ""cmd"", ""bash""
    Command string \`json:""command""\`
    Cleanup string \`json:""cleanup""\` // Commande de nettoyage
    Timeout int    \`json:""timeout""\` // Secondes
}

type Detection struct {
    Source    string \`json:""source""\`    // ""Process Creation"", ""File Creation""
    Indicator string \`json:""indicator""\` // Pattern de detection attendu
}

func NewTechnique(id, name string, tactic TacticType) *Technique {
    return &Technique{
        ID:        id,
        Name:      name,
        Tactic:    tactic,
        Platforms: []string{},
        Executors: []Executor{},
        Detection: []Detection{},
        References: []string{},
        IsSafe:    true,
    }
}

func (t *Technique) SupportsPlatform(platform string) bool {
    for _, p := range t.Platforms {
        if p == platform {
            return true
        }
    }
    return false
}

func (t *Technique) GetExecutorForType(execType string) *Executor {
    for i, e := range t.Executors {
        if e.Type == execType {
            return &t.Executors[i]
        }
    }
    return nil
}

func (t *Technique) AddExecutor(executor Executor) {
    t.Executors = append(t.Executors, executor)
}
\`\`\`

**Fichiers**
- server/internal/domain/entity/technique.go
- server/internal/domain/entity/technique_test.go

**Definition of Done**
- [ ] Struct Technique avec ID MITRE, Name, Tactic, Description
- [ ] Type TacticType avec les 14 tactics MITRE ATT&CK
- [ ] Struct Executor (Type, Command, Cleanup, Timeout)
- [ ] Struct Detection (Source, Indicator)
- [ ] Constructeur NewTechnique()
- [ ] Methode SupportsPlatform()
- [ ] Methode GetExecutorForType()
- [ ] Methode AddExecutor()
- [ ] Champ IsSafe pour mode production
- [ ] Tests unitaires",backend;go;domain;entity;mitre
"BE-06: Creer entity Scenario",Task,"**Objectif**
Creer l'entite Scenario du domaine representant un scenario d'attaque compose de phases et techniques.

**Code Go exemple**
\`\`\`go
// internal/domain/entity/scenario.go
package entity

import (
    ""time""
    ""github.com/google/uuid""
)

type Scenario struct {
    ID          string    \`json:""id""\`
    Name        string    \`json:""name""\`
    Description string    \`json:""description""\`
    Phases      []Phase   \`json:""phases""\`
    Tags        []string  \`json:""tags""\`
    Author      string    \`json:""author""\`
    CreatedAt   time.Time \`json:""created_at""\`
    UpdatedAt   time.Time \`json:""updated_at""\`
}

type Phase struct {
    Name        string   \`json:""name""\`
    Description string   \`json:""description""\`
    Techniques  []string \`json:""techniques""\` // IDs des techniques
    Order       int      \`json:""order""\`
}

func NewScenario(name, description string) *Scenario {
    now := time.Now()
    return &Scenario{
        ID:          uuid.New().String(),
        Name:        name,
        Description: description,
        Phases:      []Phase{},
        Tags:        []string{},
        CreatedAt:   now,
        UpdatedAt:   now,
    }
}

func (s *Scenario) AddPhase(phase Phase) {
    phase.Order = len(s.Phases)
    s.Phases = append(s.Phases, phase)
    s.UpdatedAt = time.Now()
}

func (s *Scenario) RemovePhase(index int) {
    if index < 0 || index >= len(s.Phases) {
        return
    }
    s.Phases = append(s.Phases[:index], s.Phases[index+1:]...)
    // Reordonner
    for i := range s.Phases {
        s.Phases[i].Order = i
    }
    s.UpdatedAt = time.Now()
}

func (s *Scenario) GetAllTechniqueIDs() []string {
    ids := make([]string, 0)
    for _, phase := range s.Phases {
        ids = append(ids, phase.Techniques...)
    }
    return ids
}

func (s *Scenario) TotalTechniques() int {
    count := 0
    for _, phase := range s.Phases {
        count += len(phase.Techniques)
    }
    return count
}

func (s *Scenario) Validate() error {
    if s.Name == """" {
        return ErrScenarioNameRequired
    }
    if len(s.Phases) == 0 {
        return ErrScenarioNoPhases
    }
    return nil
}

var (
    ErrScenarioNameRequired = fmt.Errorf(""scenario name is required"")
    ErrScenarioNoPhases     = fmt.Errorf(""scenario must have at least one phase"")
)
\`\`\`

**Fichiers**
- server/internal/domain/entity/scenario.go
- server/internal/domain/entity/scenario_test.go

**Definition of Done**
- [ ] Struct Scenario avec ID, Name, Description, Phases
- [ ] Struct Phase avec Name, Description, Techniques, Order
- [ ] Constructeur NewScenario() avec UUID genere
- [ ] Methode AddPhase() avec ordre automatique
- [ ] Methode RemovePhase() avec reordonnancement
- [ ] Methode GetAllTechniqueIDs()
- [ ] Methode TotalTechniques()
- [ ] Methode Validate() avec erreurs metier
- [ ] Tests unitaires",backend;go;domain;entity
"BE-07: Creer entity ExecutionResult",Task,"**Objectif**
Creer l'entite ExecutionResult du domaine representant le resultat d'execution d'une technique sur un agent.

**Code Go exemple**
\`\`\`go
// internal/domain/entity/result.go
package entity

import ""time""

type ResultStatus string

const (
    StatusSuccess  ResultStatus = ""success""   // Executee, non detectee
    StatusBlocked  ResultStatus = ""blocked""   // Bloquee par defense
    StatusDetected ResultStatus = ""detected""  // Executee mais alertee
    StatusFailed   ResultStatus = ""failed""    // Erreur technique
    StatusSkipped  ResultStatus = ""skipped""   // Non executee
    StatusPending  ResultStatus = ""pending""   // En attente
    StatusRunning  ResultStatus = ""running""   // En cours
)

type ExecutionResult struct {
    ID           string        \`json:""id""\`
    ExecutionID  string        \`json:""execution_id""\`  // ID de l'execution globale
    TechniqueID  string        \`json:""technique_id""\`
    AgentPaw     string        \`json:""agent_paw""\`
    Status       ResultStatus  \`json:""status""\`
    Output       string        \`json:""output""\`        // Output encode base64
    Stderr       string        \`json:""stderr""\`
    ExitCode     int           \`json:""exit_code""\`
    DetectedBy   string        \`json:""detected_by""\`   // ""Windows Defender"", ""CrowdStrike""
    StartedAt    time.Time     \`json:""started_at""\`
    CompletedAt  *time.Time    \`json:""completed_at""\`
    Duration     time.Duration \`json:""duration""\`
}

func NewExecutionResult(executionID, techniqueID, agentPaw string) *ExecutionResult {
    return &ExecutionResult{
        ID:          uuid.New().String(),
        ExecutionID: executionID,
        TechniqueID: techniqueID,
        AgentPaw:    agentPaw,
        Status:      StatusPending,
        StartedAt:   time.Now(),
    }
}

func (r *ExecutionResult) Start() {
    r.Status = StatusRunning
    r.StartedAt = time.Now()
}

func (r *ExecutionResult) Complete(status ResultStatus, output, stderr string, exitCode int) {
    now := time.Now()
    r.Status = status
    r.Output = output
    r.Stderr = stderr
    r.ExitCode = exitCode
    r.CompletedAt = &now
    r.Duration = now.Sub(r.StartedAt)
}

func (r *ExecutionResult) MarkAsBlocked(detectedBy string) {
    r.Status = StatusBlocked
    r.DetectedBy = detectedBy
    now := time.Now()
    r.CompletedAt = &now
    r.Duration = now.Sub(r.StartedAt)
}

func (r *ExecutionResult) MarkAsDetected(detectedBy string) {
    r.Status = StatusDetected
    r.DetectedBy = detectedBy
}

func (r *ExecutionResult) IsFinished() bool {
    return r.Status != StatusPending && r.Status != StatusRunning
}

func (r *ExecutionResult) WasSuccessful() bool {
    return r.Status == StatusSuccess
}
\`\`\`

**Fichiers**
- server/internal/domain/entity/result.go
- server/internal/domain/entity/result_test.go

**Definition of Done**
- [ ] Struct ExecutionResult avec tous les champs
- [ ] Type ResultStatus avec constantes (success, blocked, detected, failed, skipped, pending, running)
- [ ] Constructeur NewExecutionResult()
- [ ] Methode Start()
- [ ] Methode Complete()
- [ ] Methode MarkAsBlocked()
- [ ] Methode MarkAsDetected()
- [ ] Methode IsFinished()
- [ ] Methode WasSuccessful()
- [ ] Champ Duration calcule
- [ ] Tests unitaires",backend;go;domain;entity
"BE-08: Creer entity Execution",Task,"**Objectif**
Creer l'entite Execution du domaine representant une execution complete d'un scenario sur des agents.

**Code Go exemple**
\`\`\`go
// internal/domain/entity/execution.go
package entity

import (
    ""time""
    ""github.com/google/uuid""
)

type ExecutionStatus string

const (
    ExecutionPending   ExecutionStatus = ""pending""
    ExecutionRunning   ExecutionStatus = ""running""
    ExecutionCompleted ExecutionStatus = ""completed""
    ExecutionFailed    ExecutionStatus = ""failed""
    ExecutionCancelled ExecutionStatus = ""cancelled""
)

type Execution struct {
    ID          string            \`json:""id""\`
    ScenarioID  string            \`json:""scenario_id""\`
    ScenarioName string           \`json:""scenario_name""\`
    AgentPaws   []string          \`json:""agent_paws""\`
    Status      ExecutionStatus   \`json:""status""\`
    SafeMode    bool              \`json:""safe_mode""\`
    Progress    ExecutionProgress \`json:""progress""\`
    StartedAt   time.Time         \`json:""started_at""\`
    CompletedAt *time.Time        \`json:""completed_at""\`
    Results     []ExecutionResult \`json:""results""\`
    Error       string            \`json:""error,omitempty""\`
    CreatedBy   string            \`json:""created_by""\`
}

type ExecutionProgress struct {
    Current int \`json:""current""\`
    Total   int \`json:""total""\`
    Percent int \`json:""percent""\`
}

func NewExecution(scenarioID, scenarioName string, agentPaws []string, safeMode bool, createdBy string) *Execution {
    return &Execution{
        ID:           uuid.New().String(),
        ScenarioID:   scenarioID,
        ScenarioName: scenarioName,
        AgentPaws:    agentPaws,
        Status:       ExecutionPending,
        SafeMode:     safeMode,
        Progress:     ExecutionProgress{Current: 0, Total: 0, Percent: 0},
        StartedAt:    time.Now(),
        Results:      []ExecutionResult{},
        CreatedBy:    createdBy,
    }
}

func (e *Execution) Start(totalTasks int) {
    e.Status = ExecutionRunning
    e.Progress.Total = totalTasks
    e.StartedAt = time.Now()
}

func (e *Execution) UpdateProgress(current int) {
    e.Progress.Current = current
    if e.Progress.Total > 0 {
        e.Progress.Percent = (current * 100) / e.Progress.Total
    }
}

func (e *Execution) Complete() {
    e.Status = ExecutionCompleted
    now := time.Now()
    e.CompletedAt = &now
    e.Progress.Percent = 100
}

func (e *Execution) Fail(err string) {
    e.Status = ExecutionFailed
    e.Error = err
    now := time.Now()
    e.CompletedAt = &now
}

func (e *Execution) Cancel() {
    e.Status = ExecutionCancelled
    now := time.Now()
    e.CompletedAt = &now
}

func (e *Execution) AddResult(result ExecutionResult) {
    e.Results = append(e.Results, result)
    e.UpdateProgress(len(e.Results))
}

func (e *Execution) IsFinished() bool {
    return e.Status == ExecutionCompleted ||
           e.Status == ExecutionFailed ||
           e.Status == ExecutionCancelled
}

func (e *Execution) Duration() time.Duration {
    if e.CompletedAt != nil {
        return e.CompletedAt.Sub(e.StartedAt)
    }
    return time.Since(e.StartedAt)
}

func (e *Execution) GetScore() float64 {
    if len(e.Results) == 0 {
        return 0
    }
    blocked := 0
    detected := 0
    for _, r := range e.Results {
        switch r.Status {
        case StatusBlocked:
            blocked++
        case StatusDetected:
            detected++
        }
    }
    // Score = (blocked*100 + detected*50) / (total*100)
    return float64(blocked*100+detected*50) / float64(len(e.Results)*100)
}
\`\`\`

**Fichiers**
- server/internal/domain/entity/execution.go
- server/internal/domain/entity/execution_test.go

**Definition of Done**
- [ ] Struct Execution avec tous les champs
- [ ] Type ExecutionStatus avec constantes
- [ ] Struct ExecutionProgress (Current, Total, Percent)
- [ ] Constructeur NewExecution()
- [ ] Methode Start()
- [ ] Methode UpdateProgress()
- [ ] Methode Complete()
- [ ] Methode Fail()
- [ ] Methode Cancel()
- [ ] Methode AddResult()
- [ ] Methode IsFinished()
- [ ] Methode Duration()
- [ ] Methode GetScore() pour calcul score securite
- [ ] Tests unitaires",backend;go;domain;entity
"BE-09: Creer interface AgentRepository",Task,"**Objectif**
Creer l'interface AgentRepository (port sortant) dans le domaine pour abstraire la persistance des agents.

**Code Go exemple**
\`\`\`go
// internal/domain/repository/agent_repository.go
package repository

import (
    ""context""
    ""autostrike/internal/domain/entity""
)

// AgentRepository definit les operations de persistance pour les agents
// C'est un port sortant (driven port) de l'architecture hexagonale
type AgentRepository interface {
    // Create persiste un nouvel agent
    Create(ctx context.Context, agent *entity.Agent) error

    // Update met a jour un agent existant
    Update(ctx context.Context, agent *entity.Agent) error

    // FindByPaw recupere un agent par son identifiant unique
    FindByPaw(ctx context.Context, paw string) (*entity.Agent, error)

    // FindAll recupere tous les agents avec pagination optionnelle
    FindAll(ctx context.Context, opts *FindOptions) ([]*entity.Agent, error)

    // FindByStatus recupere les agents par status
    FindByStatus(ctx context.Context, status entity.AgentStatus) ([]*entity.Agent, error)

    // FindByPlatform recupere les agents par plateforme
    FindByPlatform(ctx context.Context, platform string) ([]*entity.Agent, error)

    // Delete supprime un agent par son paw
    Delete(ctx context.Context, paw string) error

    // UpdateStatus met a jour uniquement le status d'un agent
    UpdateStatus(ctx context.Context, paw string, status entity.AgentStatus) error

    // UpdateLastSeen met a jour le timestamp last_seen
    UpdateLastSeen(ctx context.Context, paw string) error

    // Count retourne le nombre total d'agents
    Count(ctx context.Context) (int64, error)

    // CountByStatus retourne le nombre d'agents par status
    CountByStatus(ctx context.Context, status entity.AgentStatus) (int64, error)
}

// FindOptions contient les options de recherche/pagination
type FindOptions struct {
    Limit  int
    Offset int
    SortBy string
    Order  string // ""asc"" ou ""desc""
}

// NewFindOptions cree des options par defaut
func NewFindOptions() *FindOptions {
    return &FindOptions{
        Limit:  100,
        Offset: 0,
        SortBy: ""created_at"",
        Order:  ""desc"",
    }
}

// Erreurs du repository
var (
    ErrAgentNotFound      = fmt.Errorf(""agent not found"")
    ErrAgentAlreadyExists = fmt.Errorf(""agent already exists"")
    ErrInvalidPaw         = fmt.Errorf(""invalid agent paw"")
)
\`\`\`

**Fichiers**
- server/internal/domain/repository/agent_repository.go
- server/internal/domain/repository/errors.go
- server/internal/domain/repository/options.go

**Definition of Done**
- [ ] Interface AgentRepository definie dans domain/repository
- [ ] Methodes CRUD: Create, Update, Delete, FindByPaw
- [ ] Methodes de recherche: FindAll, FindByStatus, FindByPlatform
- [ ] Methodes utilitaires: UpdateStatus, UpdateLastSeen, Count
- [ ] Struct FindOptions pour pagination
- [ ] Erreurs metier definies (ErrAgentNotFound, etc.)
- [ ] Contexte Go sur toutes les methodes
- [ ] Documentation godoc sur l'interface",backend;go;domain;repository;hexagonal
"BE-10: Creer interface TechniqueRepository",Task,"**Objectif**
Creer l'interface TechniqueRepository (port sortant) pour abstraire l'acces aux techniques MITRE ATT&CK.

**Code Go exemple**
\`\`\`go
// internal/domain/repository/technique_repository.go
package repository

import (
    ""context""
    ""autostrike/internal/domain/entity""
)

// TechniqueRepository definit les operations d'acces aux techniques MITRE
type TechniqueRepository interface {
    // FindByID recupere une technique par son ID MITRE (ex: ""T1059.001"")
    FindByID(ctx context.Context, id string) (*entity.Technique, error)

    // FindAll recupere toutes les techniques
    FindAll(ctx context.Context) ([]*entity.Technique, error)

    // FindByTactic recupere les techniques d'une tactic specifique
    FindByTactic(ctx context.Context, tactic entity.TacticType) ([]*entity.Technique, error)

    // FindByPlatform recupere les techniques supportant une plateforme
    FindByPlatform(ctx context.Context, platform string) ([]*entity.Technique, error)

    // FindSafe recupere uniquement les techniques marquees safe
    FindSafe(ctx context.Context) ([]*entity.Technique, error)

    // Search recherche des techniques par nom ou description
    Search(ctx context.Context, query string) ([]*entity.Technique, error)

    // FindByIDs recupere plusieurs techniques par leurs IDs
    FindByIDs(ctx context.Context, ids []string) ([]*entity.Technique, error)

    // Create ajoute une nouvelle technique
    Create(ctx context.Context, technique *entity.Technique) error

    // Update met a jour une technique existante
    Update(ctx context.Context, technique *entity.Technique) error

    // Delete supprime une technique
    Delete(ctx context.Context, id string) error

    // Count retourne le nombre total de techniques
    Count(ctx context.Context) (int64, error)

    // CountByTactic retourne le nombre de techniques par tactic
    CountByTactic(ctx context.Context, tactic entity.TacticType) (int64, error)

    // GetTactics retourne la liste des tactics avec leur nombre de techniques
    GetTactics(ctx context.Context) ([]TacticCount, error)
}

// TacticCount represente une tactic avec son nombre de techniques
type TacticCount struct {
    Tactic entity.TacticType \`json:""tactic""\`
    Count  int64             \`json:""count""\`
}

// Erreurs du repository
var (
    ErrTechniqueNotFound      = fmt.Errorf(""technique not found"")
    ErrTechniqueAlreadyExists = fmt.Errorf(""technique already exists"")
    ErrInvalidTechniqueID     = fmt.Errorf(""invalid technique ID format"")
)
\`\`\`

**Fichiers**
- server/internal/domain/repository/technique_repository.go

**Definition of Done**
- [ ] Interface TechniqueRepository definie
- [ ] Methode FindByID pour ID MITRE
- [ ] Methode FindByTactic pour filtrer par tactic
- [ ] Methode FindByPlatform pour filtrer par OS
- [ ] Methode FindSafe pour mode production
- [ ] Methode Search pour recherche textuelle
- [ ] Methode FindByIDs pour recuperation en lot
- [ ] Methodes CRUD: Create, Update, Delete
- [ ] Struct TacticCount pour statistiques
- [ ] Erreurs metier definies
- [ ] Documentation godoc",backend;go;domain;repository;hexagonal;mitre
"BE-11: Creer interface ScenarioRepository",Task,"**Objectif**
Creer l'interface ScenarioRepository (port sortant) pour abstraire la persistance des scenarios d'attaque.

**Code Go exemple**
\`\`\`go
// internal/domain/repository/scenario_repository.go
package repository

import (
    ""context""
    ""autostrike/internal/domain/entity""
)

// ScenarioRepository definit les operations de persistance pour les scenarios
type ScenarioRepository interface {
    // Create persiste un nouveau scenario
    Create(ctx context.Context, scenario *entity.Scenario) error

    // Update met a jour un scenario existant
    Update(ctx context.Context, scenario *entity.Scenario) error

    // FindByID recupere un scenario par son ID
    FindByID(ctx context.Context, id string) (*entity.Scenario, error)

    // FindAll recupere tous les scenarios avec pagination
    FindAll(ctx context.Context, opts *FindOptions) ([]*entity.Scenario, error)

    // FindByName recherche un scenario par nom exact
    FindByName(ctx context.Context, name string) (*entity.Scenario, error)

    // Search recherche des scenarios par nom ou description
    Search(ctx context.Context, query string, opts *FindOptions) ([]*entity.Scenario, error)

    // FindByTag recupere les scenarios ayant un tag specifique
    FindByTag(ctx context.Context, tag string) ([]*entity.Scenario, error)

    // FindByTechniqueID recupere les scenarios utilisant une technique
    FindByTechniqueID(ctx context.Context, techniqueID string) ([]*entity.Scenario, error)

    // Delete supprime un scenario
    Delete(ctx context.Context, id string) error

    // Count retourne le nombre total de scenarios
    Count(ctx context.Context) (int64, error)

    // GetTags retourne la liste de tous les tags utilises
    GetTags(ctx context.Context) ([]string, error)

    // AddPhase ajoute une phase a un scenario
    AddPhase(ctx context.Context, scenarioID string, phase entity.Phase) error

    // RemovePhase supprime une phase d'un scenario
    RemovePhase(ctx context.Context, scenarioID string, phaseIndex int) error

    // UpdatePhases met a jour toutes les phases d'un scenario
    UpdatePhases(ctx context.Context, scenarioID string, phases []entity.Phase) error
}

// Erreurs du repository
var (
    ErrScenarioNotFound      = fmt.Errorf(""scenario not found"")
    ErrScenarioAlreadyExists = fmt.Errorf(""scenario with this name already exists"")
    ErrInvalidScenarioID     = fmt.Errorf(""invalid scenario ID"")
    ErrPhaseIndexOutOfRange  = fmt.Errorf(""phase index out of range"")
)
\`\`\`

**Fichiers**
- server/internal/domain/repository/scenario_repository.go

**Definition of Done**
- [ ] Interface ScenarioRepository definie
- [ ] Methodes CRUD: Create, Update, Delete, FindByID
- [ ] Methode FindAll avec pagination
- [ ] Methode FindByName pour nom exact
- [ ] Methode Search pour recherche textuelle
- [ ] Methode FindByTag pour filtrer par tags
- [ ] Methode FindByTechniqueID pour retrouver les usages
- [ ] Methodes de gestion des phases: AddPhase, RemovePhase, UpdatePhases
- [ ] Methode GetTags pour liste des tags
- [ ] Erreurs metier definies
- [ ] Documentation godoc",backend;go;domain;repository;hexagonal
"BE-12: Creer interface ResultRepository",Task,"**Objectif**
Creer l'interface ResultRepository (port sortant) pour abstraire la persistance des resultats d'execution.

**Code Go exemple**
\`\`\`go
// internal/domain/repository/result_repository.go
package repository

import (
    ""context""
    ""time""
    ""autostrike/internal/domain/entity""
)

// ResultRepository definit les operations de persistance pour les resultats
type ResultRepository interface {
    // CreateExecution cree une nouvelle execution
    CreateExecution(ctx context.Context, execution *entity.Execution) error

    // UpdateExecution met a jour une execution
    UpdateExecution(ctx context.Context, execution *entity.Execution) error

    // FindExecutionByID recupere une execution par son ID
    FindExecutionByID(ctx context.Context, id string) (*entity.Execution, error)

    // FindExecutions recupere les executions avec filtres
    FindExecutions(ctx context.Context, filter *ExecutionFilter, opts *FindOptions) ([]*entity.Execution, error)

    // CreateResult cree un resultat d'execution de technique
    CreateResult(ctx context.Context, result *entity.ExecutionResult) error

    // UpdateResult met a jour un resultat
    UpdateResult(ctx context.Context, result *entity.ExecutionResult) error

    // FindResultByID recupere un resultat par son ID
    FindResultByID(ctx context.Context, id string) (*entity.ExecutionResult, error)

    // FindResultsByExecutionID recupere tous les resultats d'une execution
    FindResultsByExecutionID(ctx context.Context, executionID string) ([]*entity.ExecutionResult, error)

    // FindResultsByAgentPaw recupere les resultats par agent
    FindResultsByAgentPaw(ctx context.Context, agentPaw string, opts *FindOptions) ([]*entity.ExecutionResult, error)

    // FindResultsByTechniqueID recupere les resultats par technique
    FindResultsByTechniqueID(ctx context.Context, techniqueID string, opts *FindOptions) ([]*entity.ExecutionResult, error)

    // GetCoverageStats retourne les statistiques de couverture MITRE
    GetCoverageStats(ctx context.Context) (*CoverageStats, error)

    // GetTechniqueStats retourne les stats d'une technique specifique
    GetTechniqueStats(ctx context.Context, techniqueID string) (*TechniqueStats, error)

    // CountExecutions compte les executions avec filtres
    CountExecutions(ctx context.Context, filter *ExecutionFilter) (int64, error)

    // DeleteExecution supprime une execution et ses resultats (soft delete pour audit)
    DeleteExecution(ctx context.Context, id string) error
}

// ExecutionFilter contient les filtres pour rechercher des executions
type ExecutionFilter struct {
    ScenarioID *string
    AgentPaw   *string
    Status     *entity.ExecutionStatus
    StartDate  *time.Time
    EndDate    *time.Time
}

// CoverageStats contient les statistiques de couverture globale
type CoverageStats struct {
    TotalTechniques  int64                       \`json:""total_techniques""\`
    TestedTechniques int64                       \`json:""tested_techniques""\`
    CoveragePercent  float64                     \`json:""coverage_percent""\`
    ByTactic         map[entity.TacticType]TacticCoverage \`json:""by_tactic""\`
    ByStatus         map[entity.ResultStatus]int64 \`json:""by_status""\`
}

// TacticCoverage contient la couverture d'une tactic
type TacticCoverage struct {
    Total   int64   \`json:""total""\`
    Tested  int64   \`json:""tested""\`
    Percent float64 \`json:""percent""\`
}

// TechniqueStats contient les stats d'une technique
type TechniqueStats struct {
    TechniqueID    string  \`json:""technique_id""\`
    TotalRuns      int64   \`json:""total_runs""\`
    SuccessRate    float64 \`json:""success_rate""\`
    DetectionRate  float64 \`json:""detection_rate""\`
    BlockRate      float64 \`json:""block_rate""\`
    LastTestedAt   *time.Time \`json:""last_tested_at""\`
}

// Erreurs du repository
var (
    ErrExecutionNotFound = fmt.Errorf(""execution not found"")
    ErrResultNotFound    = fmt.Errorf(""result not found"")
)
\`\`\`

**Fichiers**
- server/internal/domain/repository/result_repository.go

**Definition of Done**
- [ ] Interface ResultRepository definie
- [ ] Methodes pour Execution: Create, Update, FindByID, FindExecutions
- [ ] Methodes pour ExecutionResult: Create, Update, FindByID
- [ ] Methodes de recherche: FindResultsByExecutionID, FindResultsByAgentPaw, FindResultsByTechniqueID
- [ ] Struct ExecutionFilter pour filtres de recherche
- [ ] Methode GetCoverageStats pour matrice MITRE
- [ ] Struct CoverageStats et TacticCoverage
- [ ] Methode GetTechniqueStats pour statistiques par technique
- [ ] Struct TechniqueStats
- [ ] Erreurs metier definies
- [ ] Documentation godoc",backend;go;domain;repository;hexagonal
"BE-13: Implementer SQLite AgentRepository",Task,"**Objectif**
Implementer l'interface AgentRepository avec SQLite comme adaptateur de persistance.

**Code Go exemple**
\`\`\`go
// internal/infrastructure/persistence/sqlite/agent_repository.go
package sqlite

import (
    ""context""
    ""database/sql""
    ""time""

    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
    _ ""github.com/mattn/go-sqlite3""
)

type AgentRepository struct {
    db *sql.DB
}

func NewAgentRepository(db *sql.DB) *AgentRepository {
    return &AgentRepository{db: db}
}

func (r *AgentRepository) Create(ctx context.Context, agent *entity.Agent) error {
    query := \`
        INSERT INTO agents (paw, hostname, platform, username, executors, status, last_seen, ip_address, os_version, metadata, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    \`

    executorsJSON, _ := json.Marshal(agent.Executors)
    metadataJSON, _ := json.Marshal(agent.Metadata)

    _, err := r.db.ExecContext(ctx, query,
        agent.Paw,
        agent.Hostname,
        agent.Platform,
        agent.Username,
        string(executorsJSON),
        string(agent.Status),
        agent.LastSeen,
        agent.IPAddress,
        agent.OSVersion,
        string(metadataJSON),
        agent.CreatedAt,
        agent.UpdatedAt,
    )

    if err != nil {
        if isUniqueConstraintError(err) {
            return repository.ErrAgentAlreadyExists
        }
        return err
    }

    return nil
}

func (r *AgentRepository) FindByPaw(ctx context.Context, paw string) (*entity.Agent, error) {
    query := \`
        SELECT paw, hostname, platform, username, executors, status, last_seen, ip_address, os_version, metadata, created_at, updated_at
        FROM agents
        WHERE paw = ?
    \`

    var agent entity.Agent
    var executorsJSON, metadataJSON string
    var status string

    err := r.db.QueryRowContext(ctx, query, paw).Scan(
        &agent.Paw,
        &agent.Hostname,
        &agent.Platform,
        &agent.Username,
        &executorsJSON,
        &status,
        &agent.LastSeen,
        &agent.IPAddress,
        &agent.OSVersion,
        &metadataJSON,
        &agent.CreatedAt,
        &agent.UpdatedAt,
    )

    if err == sql.ErrNoRows {
        return nil, repository.ErrAgentNotFound
    }
    if err != nil {
        return nil, err
    }

    agent.Status = entity.AgentStatus(status)
    json.Unmarshal([]byte(executorsJSON), &agent.Executors)
    json.Unmarshal([]byte(metadataJSON), &agent.Metadata)

    return &agent, nil
}

func (r *AgentRepository) Update(ctx context.Context, agent *entity.Agent) error {
    query := \`
        UPDATE agents
        SET hostname = ?, platform = ?, username = ?, executors = ?, status = ?, last_seen = ?, ip_address = ?, os_version = ?, metadata = ?, updated_at = ?
        WHERE paw = ?
    \`

    executorsJSON, _ := json.Marshal(agent.Executors)
    metadataJSON, _ := json.Marshal(agent.Metadata)

    result, err := r.db.ExecContext(ctx, query,
        agent.Hostname,
        agent.Platform,
        agent.Username,
        string(executorsJSON),
        string(agent.Status),
        agent.LastSeen,
        agent.IPAddress,
        agent.OSVersion,
        string(metadataJSON),
        time.Now(),
        agent.Paw,
    )

    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return repository.ErrAgentNotFound
    }

    return nil
}

func (r *AgentRepository) FindAll(ctx context.Context, opts *repository.FindOptions) ([]*entity.Agent, error) {
    if opts == nil {
        opts = repository.NewFindOptions()
    }

    query := fmt.Sprintf(\`
        SELECT paw, hostname, platform, username, executors, status, last_seen, ip_address, os_version, metadata, created_at, updated_at
        FROM agents
        ORDER BY %s %s
        LIMIT ? OFFSET ?
    \`, opts.SortBy, opts.Order)

    rows, err := r.db.QueryContext(ctx, query, opts.Limit, opts.Offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    agents := make([]*entity.Agent, 0)
    for rows.Next() {
        agent, err := r.scanAgent(rows)
        if err != nil {
            return nil, err
        }
        agents = append(agents, agent)
    }

    return agents, nil
}

func (r *AgentRepository) FindByStatus(ctx context.Context, status entity.AgentStatus) ([]*entity.Agent, error) {
    query := \`
        SELECT paw, hostname, platform, username, executors, status, last_seen, ip_address, os_version, metadata, created_at, updated_at
        FROM agents
        WHERE status = ?
        ORDER BY last_seen DESC
    \`

    rows, err := r.db.QueryContext(ctx, query, string(status))
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanAgents(rows)
}

func (r *AgentRepository) Delete(ctx context.Context, paw string) error {
    result, err := r.db.ExecContext(ctx, ""DELETE FROM agents WHERE paw = ?"", paw)
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return repository.ErrAgentNotFound
    }

    return nil
}

func (r *AgentRepository) UpdateLastSeen(ctx context.Context, paw string) error {
    result, err := r.db.ExecContext(ctx,
        ""UPDATE agents SET last_seen = ?, updated_at = ? WHERE paw = ?"",
        time.Now(), time.Now(), paw,
    )
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return repository.ErrAgentNotFound
    }

    return nil
}

func (r *AgentRepository) Count(ctx context.Context) (int64, error) {
    var count int64
    err := r.db.QueryRowContext(ctx, ""SELECT COUNT(*) FROM agents"").Scan(&count)
    return count, err
}
\`\`\`

\`\`\`sql
-- migrations/001_create_agents.sql
CREATE TABLE IF NOT EXISTS agents (
    paw TEXT PRIMARY KEY,
    hostname TEXT NOT NULL,
    platform TEXT NOT NULL,
    username TEXT NOT NULL,
    executors TEXT NOT NULL DEFAULT '[]',
    status TEXT NOT NULL DEFAULT 'offline',
    last_seen DATETIME NOT NULL,
    ip_address TEXT,
    os_version TEXT,
    metadata TEXT DEFAULT '{}',
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL
);

CREATE INDEX idx_agents_status ON agents(status);
CREATE INDEX idx_agents_platform ON agents(platform);
CREATE INDEX idx_agents_last_seen ON agents(last_seen);
\`\`\`

**Fichiers**
- server/internal/infrastructure/persistence/sqlite/agent_repository.go
- server/internal/infrastructure/persistence/sqlite/agent_repository_test.go
- server/internal/infrastructure/persistence/sqlite/migrations/001_create_agents.sql

**Definition of Done**
- [ ] Struct AgentRepository implementant l'interface
- [ ] Constructeur NewAgentRepository(db)
- [ ] Methode Create avec gestion erreur doublon
- [ ] Methode FindByPaw avec ErrAgentNotFound
- [ ] Methode Update avec verification existence
- [ ] Methode FindAll avec pagination
- [ ] Methode FindByStatus
- [ ] Methode FindByPlatform
- [ ] Methode Delete
- [ ] Methode UpdateLastSeen
- [ ] Methode Count et CountByStatus
- [ ] Migration SQL pour table agents avec indexes
- [ ] Tests d'integration avec SQLite in-memory
- [ ] Serialisation JSON pour executors et metadata",backend;go;infrastructure;sqlite;repository
"BE-14: Implementer SQLite TechniqueRepository",Task,"**Objectif**
Implementer l'interface TechniqueRepository avec SQLite et support du chargement depuis fichiers YAML.

**Code Go exemple**
\`\`\`go
// internal/infrastructure/persistence/sqlite/technique_repository.go
package sqlite

import (
    ""context""
    ""database/sql""
    ""encoding/json""

    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
)

type TechniqueRepository struct {
    db *sql.DB
}

func NewTechniqueRepository(db *sql.DB) *TechniqueRepository {
    return &TechniqueRepository{db: db}
}

func (r *TechniqueRepository) Create(ctx context.Context, technique *entity.Technique) error {
    query := \`
        INSERT INTO techniques (id, name, tactic, description, platforms, executors, detection, references, is_safe)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    \`

    platformsJSON, _ := json.Marshal(technique.Platforms)
    executorsJSON, _ := json.Marshal(technique.Executors)
    detectionJSON, _ := json.Marshal(technique.Detection)
    referencesJSON, _ := json.Marshal(technique.References)

    _, err := r.db.ExecContext(ctx, query,
        technique.ID,
        technique.Name,
        string(technique.Tactic),
        technique.Description,
        string(platformsJSON),
        string(executorsJSON),
        string(detectionJSON),
        string(referencesJSON),
        technique.IsSafe,
    )

    if err != nil {
        if isUniqueConstraintError(err) {
            return repository.ErrTechniqueAlreadyExists
        }
        return err
    }

    return nil
}

func (r *TechniqueRepository) FindByID(ctx context.Context, id string) (*entity.Technique, error) {
    query := \`
        SELECT id, name, tactic, description, platforms, executors, detection, references, is_safe
        FROM techniques
        WHERE id = ?
    \`

    technique, err := r.scanTechnique(r.db.QueryRowContext(ctx, query, id))
    if err == sql.ErrNoRows {
        return nil, repository.ErrTechniqueNotFound
    }

    return technique, err
}

func (r *TechniqueRepository) FindAll(ctx context.Context) ([]*entity.Technique, error) {
    query := \`
        SELECT id, name, tactic, description, platforms, executors, detection, references, is_safe
        FROM techniques
        ORDER BY id ASC
    \`

    rows, err := r.db.QueryContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanTechniques(rows)
}

func (r *TechniqueRepository) FindByTactic(ctx context.Context, tactic entity.TacticType) ([]*entity.Technique, error) {
    query := \`
        SELECT id, name, tactic, description, platforms, executors, detection, references, is_safe
        FROM techniques
        WHERE tactic = ?
        ORDER BY id ASC
    \`

    rows, err := r.db.QueryContext(ctx, query, string(tactic))
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanTechniques(rows)
}

func (r *TechniqueRepository) FindByPlatform(ctx context.Context, platform string) ([]*entity.Technique, error) {
    query := \`
        SELECT id, name, tactic, description, platforms, executors, detection, references, is_safe
        FROM techniques
        WHERE platforms LIKE ?
        ORDER BY id ASC
    \`

    rows, err := r.db.QueryContext(ctx, query, ""%""+platform+""%"")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanTechniques(rows)
}

func (r *TechniqueRepository) FindSafe(ctx context.Context) ([]*entity.Technique, error) {
    query := \`
        SELECT id, name, tactic, description, platforms, executors, detection, references, is_safe
        FROM techniques
        WHERE is_safe = 1
        ORDER BY id ASC
    \`

    rows, err := r.db.QueryContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanTechniques(rows)
}

func (r *TechniqueRepository) Search(ctx context.Context, query string) ([]*entity.Technique, error) {
    sqlQuery := \`
        SELECT id, name, tactic, description, platforms, executors, detection, references, is_safe
        FROM techniques
        WHERE name LIKE ? OR description LIKE ? OR id LIKE ?
        ORDER BY id ASC
    \`

    searchPattern := ""%"" + query + ""%""
    rows, err := r.db.QueryContext(ctx, sqlQuery, searchPattern, searchPattern, searchPattern)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanTechniques(rows)
}

func (r *TechniqueRepository) FindByIDs(ctx context.Context, ids []string) ([]*entity.Technique, error) {
    if len(ids) == 0 {
        return []*entity.Technique{}, nil
    }

    placeholders := make([]string, len(ids))
    args := make([]interface{}, len(ids))
    for i, id := range ids {
        placeholders[i] = ""?""
        args[i] = id
    }

    query := fmt.Sprintf(\`
        SELECT id, name, tactic, description, platforms, executors, detection, references, is_safe
        FROM techniques
        WHERE id IN (%s)
        ORDER BY id ASC
    \`, strings.Join(placeholders, "",""))

    rows, err := r.db.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanTechniques(rows)
}

func (r *TechniqueRepository) GetTactics(ctx context.Context) ([]repository.TacticCount, error) {
    query := \`
        SELECT tactic, COUNT(*) as count
        FROM techniques
        GROUP BY tactic
        ORDER BY tactic
    \`

    rows, err := r.db.QueryContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    tactics := make([]repository.TacticCount, 0)
    for rows.Next() {
        var tc repository.TacticCount
        var tactic string
        if err := rows.Scan(&tactic, &tc.Count); err != nil {
            return nil, err
        }
        tc.Tactic = entity.TacticType(tactic)
        tactics = append(tactics, tc)
    }

    return tactics, nil
}

func (r *TechniqueRepository) scanTechnique(row *sql.Row) (*entity.Technique, error) {
    var t entity.Technique
    var tactic string
    var platformsJSON, executorsJSON, detectionJSON, referencesJSON string

    err := row.Scan(
        &t.ID,
        &t.Name,
        &tactic,
        &t.Description,
        &platformsJSON,
        &executorsJSON,
        &detectionJSON,
        &referencesJSON,
        &t.IsSafe,
    )
    if err != nil {
        return nil, err
    }

    t.Tactic = entity.TacticType(tactic)
    json.Unmarshal([]byte(platformsJSON), &t.Platforms)
    json.Unmarshal([]byte(executorsJSON), &t.Executors)
    json.Unmarshal([]byte(detectionJSON), &t.Detection)
    json.Unmarshal([]byte(referencesJSON), &t.References)

    return &t, nil
}
\`\`\`

\`\`\`sql
-- migrations/002_create_techniques.sql
CREATE TABLE IF NOT EXISTS techniques (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    tactic TEXT NOT NULL,
    description TEXT,
    platforms TEXT NOT NULL DEFAULT '[]',
    executors TEXT NOT NULL DEFAULT '[]',
    detection TEXT DEFAULT '[]',
    references TEXT DEFAULT '[]',
    is_safe INTEGER NOT NULL DEFAULT 1
);

CREATE INDEX idx_techniques_tactic ON techniques(tactic);
CREATE INDEX idx_techniques_is_safe ON techniques(is_safe);
\`\`\`

**Fichiers**
- server/internal/infrastructure/persistence/sqlite/technique_repository.go
- server/internal/infrastructure/persistence/sqlite/technique_repository_test.go
- server/internal/infrastructure/persistence/sqlite/migrations/002_create_techniques.sql

**Definition of Done**
- [ ] Struct TechniqueRepository implementant l'interface
- [ ] Methode Create avec gestion doublon
- [ ] Methode FindByID
- [ ] Methode FindAll
- [ ] Methode FindByTactic
- [ ] Methode FindByPlatform
- [ ] Methode FindSafe
- [ ] Methode Search avec LIKE
- [ ] Methode FindByIDs pour requete en lot
- [ ] Methode GetTactics pour statistiques
- [ ] Migration SQL avec indexes
- [ ] Serialisation JSON pour champs complexes
- [ ] Tests d'integration",backend;go;infrastructure;sqlite;repository;mitre
"BE-15: Implementer SQLite ScenarioRepository",Task,"**Objectif**
Implementer l'interface ScenarioRepository avec SQLite pour persister les scenarios d'attaque.

**Code Go exemple**
\`\`\`go
// internal/infrastructure/persistence/sqlite/scenario_repository.go
package sqlite

import (
    ""context""
    ""database/sql""
    ""encoding/json""
    ""time""

    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
)

type ScenarioRepository struct {
    db *sql.DB
}

func NewScenarioRepository(db *sql.DB) *ScenarioRepository {
    return &ScenarioRepository{db: db}
}

func (r *ScenarioRepository) Create(ctx context.Context, scenario *entity.Scenario) error {
    query := \`
        INSERT INTO scenarios (id, name, description, phases, tags, author, created_at, updated_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    \`

    phasesJSON, _ := json.Marshal(scenario.Phases)
    tagsJSON, _ := json.Marshal(scenario.Tags)

    _, err := r.db.ExecContext(ctx, query,
        scenario.ID,
        scenario.Name,
        scenario.Description,
        string(phasesJSON),
        string(tagsJSON),
        scenario.Author,
        scenario.CreatedAt,
        scenario.UpdatedAt,
    )

    if err != nil {
        if isUniqueConstraintError(err) {
            return repository.ErrScenarioAlreadyExists
        }
        return err
    }

    return nil
}

func (r *ScenarioRepository) Update(ctx context.Context, scenario *entity.Scenario) error {
    query := \`
        UPDATE scenarios
        SET name = ?, description = ?, phases = ?, tags = ?, updated_at = ?
        WHERE id = ?
    \`

    phasesJSON, _ := json.Marshal(scenario.Phases)
    tagsJSON, _ := json.Marshal(scenario.Tags)

    result, err := r.db.ExecContext(ctx, query,
        scenario.Name,
        scenario.Description,
        string(phasesJSON),
        string(tagsJSON),
        time.Now(),
        scenario.ID,
    )

    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return repository.ErrScenarioNotFound
    }

    return nil
}

func (r *ScenarioRepository) FindByID(ctx context.Context, id string) (*entity.Scenario, error) {
    query := \`
        SELECT id, name, description, phases, tags, author, created_at, updated_at
        FROM scenarios
        WHERE id = ?
    \`

    scenario, err := r.scanScenario(r.db.QueryRowContext(ctx, query, id))
    if err == sql.ErrNoRows {
        return nil, repository.ErrScenarioNotFound
    }

    return scenario, err
}

func (r *ScenarioRepository) FindAll(ctx context.Context, opts *repository.FindOptions) ([]*entity.Scenario, error) {
    if opts == nil {
        opts = repository.NewFindOptions()
    }

    query := fmt.Sprintf(\`
        SELECT id, name, description, phases, tags, author, created_at, updated_at
        FROM scenarios
        ORDER BY %s %s
        LIMIT ? OFFSET ?
    \`, opts.SortBy, opts.Order)

    rows, err := r.db.QueryContext(ctx, query, opts.Limit, opts.Offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanScenarios(rows)
}

func (r *ScenarioRepository) FindByName(ctx context.Context, name string) (*entity.Scenario, error) {
    query := \`
        SELECT id, name, description, phases, tags, author, created_at, updated_at
        FROM scenarios
        WHERE name = ?
    \`

    scenario, err := r.scanScenario(r.db.QueryRowContext(ctx, query, name))
    if err == sql.ErrNoRows {
        return nil, repository.ErrScenarioNotFound
    }

    return scenario, err
}

func (r *ScenarioRepository) Search(ctx context.Context, query string, opts *repository.FindOptions) ([]*entity.Scenario, error) {
    if opts == nil {
        opts = repository.NewFindOptions()
    }

    sqlQuery := fmt.Sprintf(\`
        SELECT id, name, description, phases, tags, author, created_at, updated_at
        FROM scenarios
        WHERE name LIKE ? OR description LIKE ?
        ORDER BY %s %s
        LIMIT ? OFFSET ?
    \`, opts.SortBy, opts.Order)

    searchPattern := ""%"" + query + ""%""
    rows, err := r.db.QueryContext(ctx, sqlQuery, searchPattern, searchPattern, opts.Limit, opts.Offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanScenarios(rows)
}

func (r *ScenarioRepository) FindByTag(ctx context.Context, tag string) ([]*entity.Scenario, error) {
    query := \`
        SELECT id, name, description, phases, tags, author, created_at, updated_at
        FROM scenarios
        WHERE tags LIKE ?
        ORDER BY name ASC
    \`

    rows, err := r.db.QueryContext(ctx, query, ""%\""""+tag+""\"""%"")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanScenarios(rows)
}

func (r *ScenarioRepository) FindByTechniqueID(ctx context.Context, techniqueID string) ([]*entity.Scenario, error) {
    query := \`
        SELECT id, name, description, phases, tags, author, created_at, updated_at
        FROM scenarios
        WHERE phases LIKE ?
        ORDER BY name ASC
    \`

    rows, err := r.db.QueryContext(ctx, query, ""%\""""+techniqueID+""\"""%"")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    return r.scanScenarios(rows)
}

func (r *ScenarioRepository) Delete(ctx context.Context, id string) error {
    result, err := r.db.ExecContext(ctx, ""DELETE FROM scenarios WHERE id = ?"", id)
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return repository.ErrScenarioNotFound
    }

    return nil
}

func (r *ScenarioRepository) GetTags(ctx context.Context) ([]string, error) {
    query := \`SELECT DISTINCT tags FROM scenarios\`

    rows, err := r.db.QueryContext(ctx, query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    tagSet := make(map[string]bool)
    for rows.Next() {
        var tagsJSON string
        if err := rows.Scan(&tagsJSON); err != nil {
            continue
        }
        var tags []string
        json.Unmarshal([]byte(tagsJSON), &tags)
        for _, tag := range tags {
            tagSet[tag] = true
        }
    }

    result := make([]string, 0, len(tagSet))
    for tag := range tagSet {
        result = append(result, tag)
    }
    sort.Strings(result)

    return result, nil
}

func (r *ScenarioRepository) UpdatePhases(ctx context.Context, scenarioID string, phases []entity.Phase) error {
    phasesJSON, _ := json.Marshal(phases)

    result, err := r.db.ExecContext(ctx,
        ""UPDATE scenarios SET phases = ?, updated_at = ? WHERE id = ?"",
        string(phasesJSON), time.Now(), scenarioID,
    )
    if err != nil {
        return err
    }

    rows, _ := result.RowsAffected()
    if rows == 0 {
        return repository.ErrScenarioNotFound
    }

    return nil
}

func (r *ScenarioRepository) scanScenario(row *sql.Row) (*entity.Scenario, error) {
    var s entity.Scenario
    var phasesJSON, tagsJSON string

    err := row.Scan(
        &s.ID,
        &s.Name,
        &s.Description,
        &phasesJSON,
        &tagsJSON,
        &s.Author,
        &s.CreatedAt,
        &s.UpdatedAt,
    )
    if err != nil {
        return nil, err
    }

    json.Unmarshal([]byte(phasesJSON), &s.Phases)
    json.Unmarshal([]byte(tagsJSON), &s.Tags)

    return &s, nil
}

func (r *ScenarioRepository) Count(ctx context.Context) (int64, error) {
    var count int64
    err := r.db.QueryRowContext(ctx, ""SELECT COUNT(*) FROM scenarios"").Scan(&count)
    return count, err
}
\`\`\`

\`\`\`sql
-- migrations/003_create_scenarios.sql
CREATE TABLE IF NOT EXISTS scenarios (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    phases TEXT NOT NULL DEFAULT '[]',
    tags TEXT DEFAULT '[]',
    author TEXT,
    created_at DATETIME NOT NULL,
    updated_at DATETIME NOT NULL
);

CREATE INDEX idx_scenarios_name ON scenarios(name);
CREATE INDEX idx_scenarios_created_at ON scenarios(created_at);
\`\`\`

**Fichiers**
- server/internal/infrastructure/persistence/sqlite/scenario_repository.go
- server/internal/infrastructure/persistence/sqlite/scenario_repository_test.go
- server/internal/infrastructure/persistence/sqlite/migrations/003_create_scenarios.sql

**Definition of Done**
- [ ] Struct ScenarioRepository implementant l'interface
- [ ] Methode Create avec contrainte nom unique
- [ ] Methode Update
- [ ] Methode FindByID
- [ ] Methode FindAll avec pagination
- [ ] Methode FindByName
- [ ] Methode Search
- [ ] Methode FindByTag (recherche JSON)
- [ ] Methode FindByTechniqueID (recherche dans phases)
- [ ] Methode Delete
- [ ] Methode GetTags (extraction tags uniques)
- [ ] Methode UpdatePhases
- [ ] Methode Count
- [ ] Migration SQL avec indexes
- [ ] Serialisation JSON pour phases et tags
- [ ] Tests d'integration",backend;go;infrastructure;sqlite;repository
"BE-16: Implementer SQLite ResultRepository",Story,"**Objectif:**
Implementer l'adaptateur SQLite pour le ResultRepository, permettant la persistance des resultats d'execution des techniques MITRE ATT&CK dans la base de donnees SQLite.

**Code Go exemple:**
```go
// internal/infrastructure/persistence/sqlite/result_repo.go
package sqlite

import (
    ""database/sql""
    ""time""
    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
)

type SQLiteResultRepository struct {
    db *sql.DB
}

func NewSQLiteResultRepository(db *sql.DB) repository.ResultRepository {
    return &SQLiteResultRepository{db: db}
}

func (r *SQLiteResultRepository) Save(result *entity.ExecutionResult) error {
    query := `
        INSERT INTO execution_results
        (id, execution_id, technique_id, agent_paw, status, output, stderr, exit_code, detected_by, started_at, completed_at, duration_ms)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `
    _, err := r.db.Exec(query,
        result.ID,
        result.ExecutionID,
        result.TechniqueID,
        result.AgentPaw,
        result.Status,
        result.Output,
        result.Stderr,
        result.ExitCode,
        result.DetectedBy,
        result.StartedAt,
        result.CompletedAt,
        result.Duration.Milliseconds(),
    )
    return err
}

func (r *SQLiteResultRepository) FindByExecutionID(executionID string) ([]*entity.ExecutionResult, error) {
    query := `SELECT id, execution_id, technique_id, agent_paw, status, output, stderr, exit_code, detected_by, started_at, completed_at, duration_ms FROM execution_results WHERE execution_id = ?`
    rows, err := r.db.Query(query, executionID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var results []*entity.ExecutionResult
    for rows.Next() {
        result := &entity.ExecutionResult{}
        var durationMs int64
        err := rows.Scan(&result.ID, &result.ExecutionID, &result.TechniqueID, &result.AgentPaw, &result.Status, &result.Output, &result.Stderr, &result.ExitCode, &result.DetectedBy, &result.StartedAt, &result.CompletedAt, &durationMs)
        if err != nil {
            return nil, err
        }
        result.Duration = time.Duration(durationMs) * time.Millisecond
        results = append(results, result)
    }
    return results, nil
}

func (r *SQLiteResultRepository) FindByTechniqueID(techniqueID string) ([]*entity.ExecutionResult, error) {
    query := `SELECT id, execution_id, technique_id, agent_paw, status, output, stderr, exit_code, detected_by, started_at, completed_at, duration_ms FROM execution_results WHERE technique_id = ?`
    rows, err := r.db.Query(query, techniqueID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var results []*entity.ExecutionResult
    for rows.Next() {
        result := &entity.ExecutionResult{}
        var durationMs int64
        err := rows.Scan(&result.ID, &result.ExecutionID, &result.TechniqueID, &result.AgentPaw, &result.Status, &result.Output, &result.Stderr, &result.ExitCode, &result.DetectedBy, &result.StartedAt, &result.CompletedAt, &durationMs)
        if err != nil {
            return nil, err
        }
        result.Duration = time.Duration(durationMs) * time.Millisecond
        results = append(results, result)
    }
    return results, nil
}

func (r *SQLiteResultRepository) GetStatsByStatus() (map[entity.ResultStatus]int, error) {
    query := `SELECT status, COUNT(*) FROM execution_results GROUP BY status`
    rows, err := r.db.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    stats := make(map[entity.ResultStatus]int)
    for rows.Next() {
        var status entity.ResultStatus
        var count int
        if err := rows.Scan(&status, &count); err != nil {
            return nil, err
        }
        stats[status] = count
    }
    return stats, nil
}
```

**Fichiers:**
- server/internal/infrastructure/persistence/sqlite/result_repo.go
- server/internal/infrastructure/persistence/sqlite/result_repo_test.go

**Definition of Done:**
- [ ] Implementation complete de ResultRepository interface
- [ ] Methodes Save, FindByExecutionID, FindByTechniqueID, GetStatsByStatus implementees
- [ ] Tests unitaires avec couverture > 80%
- [ ] Tests d'integration avec base SQLite en memoire
- [ ] Gestion des erreurs SQL appropriee
- [ ] Documentation du code","backend;database;sqlite;repository;mvp"
"BE-17: Creer schema BDD SQLite (tables agents, techniques, scenarios, phases, executions, results)",Story,"**Objectif:**
Definir le schema complet de la base de donnees SQLite avec toutes les tables necessaires pour AutoStrike: agents, techniques, scenarios, phases, executions, execution_results, pending_tasks et adversary_profiles.

**Code Go exemple:**
```go
// internal/infrastructure/persistence/sqlite/schema.go
package sqlite

const Schema = `
-- Agents
CREATE TABLE IF NOT EXISTS agents (
    paw TEXT PRIMARY KEY,
    hostname TEXT NOT NULL,
    platform TEXT NOT NULL,
    username TEXT,
    ip_address TEXT,
    os_version TEXT,
    executors TEXT, -- JSON array
    status TEXT DEFAULT 'offline',
    last_seen DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_agents_status ON agents(status);
CREATE INDEX IF NOT EXISTS idx_agents_platform ON agents(platform);

-- Techniques
CREATE TABLE IF NOT EXISTS techniques (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    tactic TEXT NOT NULL,
    description TEXT,
    platforms TEXT, -- JSON array
    executors TEXT, -- JSON array
    detection TEXT, -- JSON array
    is_safe BOOLEAN DEFAULT 1,
    references_json TEXT, -- JSON array
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_techniques_tactic ON techniques(tactic);
CREATE INDEX IF NOT EXISTS idx_techniques_is_safe ON techniques(is_safe);

-- Scenarios
CREATE TABLE IF NOT EXISTS scenarios (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    phases TEXT NOT NULL, -- JSON array
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Adversary Profiles
CREATE TABLE IF NOT EXISTS adversary_profiles (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    techniques TEXT NOT NULL, -- JSON array
    references_json TEXT, -- JSON array
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Executions
CREATE TABLE IF NOT EXISTS executions (
    id TEXT PRIMARY KEY,
    scenario_id TEXT REFERENCES scenarios(id),
    status TEXT DEFAULT 'pending',
    started_at DATETIME,
    completed_at DATETIME,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_executions_status ON executions(status);
CREATE INDEX IF NOT EXISTS idx_executions_scenario ON executions(scenario_id);

-- Execution Results
CREATE TABLE IF NOT EXISTS execution_results (
    id TEXT PRIMARY KEY,
    execution_id TEXT REFERENCES executions(id),
    technique_id TEXT REFERENCES techniques(id),
    agent_paw TEXT REFERENCES agents(paw),
    status TEXT NOT NULL,
    output TEXT,
    stderr TEXT,
    exit_code INTEGER,
    detected_by TEXT,
    started_at DATETIME,
    completed_at DATETIME,
    duration_ms INTEGER
);

CREATE INDEX IF NOT EXISTS idx_results_execution ON execution_results(execution_id);
CREATE INDEX IF NOT EXISTS idx_results_technique ON execution_results(technique_id);
CREATE INDEX IF NOT EXISTS idx_results_status ON execution_results(status);
CREATE INDEX IF NOT EXISTS idx_results_agent ON execution_results(agent_paw);

-- Pending Tasks
CREATE TABLE IF NOT EXISTS pending_tasks (
    id TEXT PRIMARY KEY,
    agent_paw TEXT REFERENCES agents(paw),
    execution_id TEXT REFERENCES executions(id),
    technique_id TEXT REFERENCES techniques(id),
    command TEXT NOT NULL,
    timeout INTEGER DEFAULT 30,
    status TEXT DEFAULT 'pending',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_pending_agent ON pending_tasks(agent_paw, status);
`

func InitSchema(db *sql.DB) error {
    _, err := db.Exec(Schema)
    return err
}
```

**Fichiers:**
- server/internal/infrastructure/persistence/sqlite/schema.go
- server/internal/infrastructure/persistence/sqlite/schema_test.go

**Definition of Done:**
- [ ] Schema SQL complet avec toutes les tables definies
- [ ] Index optimises pour les requetes frequentes
- [ ] Contraintes de cles etrangeres definies
- [ ] Fonction InitSchema pour initialiser la base
- [ ] Tests de creation de schema
- [ ] Documentation des colonnes JSON
- [ ] Validation du schema avec SQLite3","backend;database;sqlite;schema;mvp"
"BE-18: Creer migrations BDD (up/down, versioning)",Story,"**Objectif:**
Implementer un systeme de migrations de base de donnees avec support up/down et versioning, permettant une evolution controlee du schema de la base de donnees AutoStrike.

**Code Go exemple:**
```go
// internal/infrastructure/persistence/sqlite/migrations/migrator.go
package migrations

import (
    ""database/sql""
    ""fmt""
    ""sort""
    ""time""
)

type Migration struct {
    Version     int
    Name        string
    Up          string
    Down        string
    AppliedAt   *time.Time
}

type Migrator struct {
    db         *sql.DB
    migrations []Migration
}

func NewMigrator(db *sql.DB) *Migrator {
    return &Migrator{
        db:         db,
        migrations: GetAllMigrations(),
    }
}

func (m *Migrator) Init() error {
    query := `
        CREATE TABLE IF NOT EXISTS schema_migrations (
            version INTEGER PRIMARY KEY,
            name TEXT NOT NULL,
            applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `
    _, err := m.db.Exec(query)
    return err
}

func (m *Migrator) Up() error {
    if err := m.Init(); err != nil {
        return err
    }

    applied, err := m.getAppliedVersions()
    if err != nil {
        return err
    }

    sort.Slice(m.migrations, func(i, j int) bool {
        return m.migrations[i].Version < m.migrations[j].Version
    })

    for _, migration := range m.migrations {
        if _, ok := applied[migration.Version]; ok {
            continue
        }

        tx, err := m.db.Begin()
        if err != nil {
            return err
        }

        if _, err := tx.Exec(migration.Up); err != nil {
            tx.Rollback()
            return fmt.Errorf(""migration %d (%s) failed: %w"", migration.Version, migration.Name, err)
        }

        if _, err := tx.Exec(""INSERT INTO schema_migrations (version, name) VALUES (?, ?)"", migration.Version, migration.Name); err != nil {
            tx.Rollback()
            return err
        }

        if err := tx.Commit(); err != nil {
            return err
        }
    }

    return nil
}

func (m *Migrator) Down(steps int) error {
    applied, err := m.getAppliedVersions()
    if err != nil {
        return err
    }

    var versions []int
    for v := range applied {
        versions = append(versions, v)
    }
    sort.Sort(sort.Reverse(sort.IntSlice(versions)))

    if steps > len(versions) {
        steps = len(versions)
    }

    for i := 0; i < steps; i++ {
        version := versions[i]
        var migration *Migration
        for _, m := range m.migrations {
            if m.Version == version {
                migration = &m
                break
            }
        }

        if migration == nil {
            continue
        }

        tx, err := m.db.Begin()
        if err != nil {
            return err
        }

        if _, err := tx.Exec(migration.Down); err != nil {
            tx.Rollback()
            return fmt.Errorf(""rollback %d (%s) failed: %w"", migration.Version, migration.Name, err)
        }

        if _, err := tx.Exec(""DELETE FROM schema_migrations WHERE version = ?"", version); err != nil {
            tx.Rollback()
            return err
        }

        if err := tx.Commit(); err != nil {
            return err
        }
    }

    return nil
}

func (m *Migrator) getAppliedVersions() (map[int]bool, error) {
    rows, err := m.db.Query(""SELECT version FROM schema_migrations"")
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    applied := make(map[int]bool)
    for rows.Next() {
        var version int
        if err := rows.Scan(&version); err != nil {
            return nil, err
        }
        applied[version] = true
    }
    return applied, nil
}

func (m *Migrator) Status() ([]Migration, error) {
    applied, err := m.getAppliedVersions()
    if err != nil {
        return nil, err
    }

    status := make([]Migration, len(m.migrations))
    copy(status, m.migrations)

    for i := range status {
        if _, ok := applied[status[i].Version]; ok {
            now := time.Now()
            status[i].AppliedAt = &now
        }
    }

    return status, nil
}
```

```go
// internal/infrastructure/persistence/sqlite/migrations/001_initial.go
package migrations

var Migration001 = Migration{
    Version: 1,
    Name:    ""initial_schema"",
    Up: `
        CREATE TABLE agents (...);
        CREATE TABLE techniques (...);
        CREATE TABLE scenarios (...);
        CREATE TABLE executions (...);
        CREATE TABLE execution_results (...);
        CREATE TABLE pending_tasks (...);
    `,
    Down: `
        DROP TABLE IF EXISTS pending_tasks;
        DROP TABLE IF EXISTS execution_results;
        DROP TABLE IF EXISTS executions;
        DROP TABLE IF EXISTS scenarios;
        DROP TABLE IF EXISTS techniques;
        DROP TABLE IF EXISTS agents;
    `,
}

func GetAllMigrations() []Migration {
    return []Migration{
        Migration001,
    }
}
```

**Fichiers:**
- server/internal/infrastructure/persistence/sqlite/migrations/migrator.go
- server/internal/infrastructure/persistence/sqlite/migrations/001_initial.go
- server/internal/infrastructure/persistence/sqlite/migrations/migrator_test.go

**Definition of Done:**
- [ ] Systeme de migration avec table schema_migrations
- [ ] Support Up() pour appliquer toutes les migrations pending
- [ ] Support Down(steps) pour rollback
- [ ] Transactions pour chaque migration
- [ ] Fonction Status() pour voir l'etat des migrations
- [ ] Tests unitaires couvrant up/down/status
- [ ] CLI commande pour executer les migrations","backend;database;sqlite;migrations;mvp"
"BE-19: Creer AgentService (application) - Register, Heartbeat, GetAll, Delete",Story,"**Objectif:**
Implementer le service applicatif AgentService qui gere le cycle de vie des agents AutoStrike: enregistrement, heartbeat/beacon, listing et suppression.

**Code Go exemple:**
```go
// internal/application/agent_service.go
package application

import (
    ""context""
    ""time""
    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
    ""autostrike/internal/application/dto""
)

type AgentService struct {
    agentRepo     repository.AgentRepository
    taskRepo      repository.TaskRepository
    heartbeatTTL  time.Duration
}

func NewAgentService(agentRepo repository.AgentRepository, taskRepo repository.TaskRepository) *AgentService {
    return &AgentService{
        agentRepo:    agentRepo,
        taskRepo:     taskRepo,
        heartbeatTTL: 3 * time.Minute, // Agent offline apres 3 beacons manques
    }
}

func (s *AgentService) Register(ctx context.Context, req dto.RegisterAgentRequest) (*dto.AgentResponse, error) {
    agent := &entity.Agent{
        Paw:       req.Paw,
        Hostname:  req.Hostname,
        Platform:  req.Platform,
        Username:  req.Username,
        Executors: req.Executors,
        IPAddress: req.IPAddress,
        OSVersion: req.OSVersion,
        Status:    entity.AgentOnline,
        LastSeen:  time.Now(),
    }

    existing, err := s.agentRepo.FindByPaw(ctx, req.Paw)
    if err == nil && existing != nil {
        // Update existing agent
        agent.Paw = existing.Paw
        if err := s.agentRepo.Update(ctx, agent); err != nil {
            return nil, err
        }
    } else {
        // Create new agent
        if err := s.agentRepo.Create(ctx, agent); err != nil {
            return nil, err
        }
    }

    return dto.AgentToResponse(agent), nil
}

func (s *AgentService) Heartbeat(ctx context.Context, req dto.HeartbeatRequest) (*dto.HeartbeatResponse, error) {
    agent, err := s.agentRepo.FindByPaw(ctx, req.Paw)
    if err != nil {
        return nil, err
    }

    // Update agent info
    agent.LastSeen = time.Now()
    agent.Status = entity.AgentOnline
    agent.Hostname = req.Hostname
    agent.Executors = req.Executors

    if err := s.agentRepo.Update(ctx, agent); err != nil {
        return nil, err
    }

    // Process results from previous instructions
    for _, result := range req.Results {
        if err := s.taskRepo.UpdateResult(ctx, result.ID, result.Status, result.Output, result.ExitCode); err != nil {
            // Log error but continue
        }
    }

    // Get pending tasks for this agent
    tasks, err := s.taskRepo.GetPendingForAgent(ctx, req.Paw)
    if err != nil {
        return nil, err
    }

    instructions := make([]dto.Instruction, len(tasks))
    for i, task := range tasks {
        instructions[i] = dto.Instruction{
            ID:          task.ID,
            TechniqueID: task.TechniqueID,
            Executor:    task.Executor,
            Command:     task.Command,
            Timeout:     task.Timeout,
        }
    }

    return &dto.HeartbeatResponse{
        Paw:          agent.Paw,
        Sleep:        5,
        Instructions: instructions,
    }, nil
}

func (s *AgentService) GetAll(ctx context.Context) ([]*dto.AgentResponse, error) {
    agents, err := s.agentRepo.FindAll(ctx)
    if err != nil {
        return nil, err
    }

    // Update status based on last_seen
    for _, agent := range agents {
        if time.Since(agent.LastSeen) > s.heartbeatTTL {
            agent.Status = entity.AgentOffline
        }
    }

    responses := make([]*dto.AgentResponse, len(agents))
    for i, agent := range agents {
        responses[i] = dto.AgentToResponse(agent)
    }

    return responses, nil
}

func (s *AgentService) GetByPaw(ctx context.Context, paw string) (*dto.AgentResponse, error) {
    agent, err := s.agentRepo.FindByPaw(ctx, paw)
    if err != nil {
        return nil, err
    }

    if time.Since(agent.LastSeen) > s.heartbeatTTL {
        agent.Status = entity.AgentOffline
    }

    return dto.AgentToResponse(agent), nil
}

func (s *AgentService) Delete(ctx context.Context, paw string) error {
    return s.agentRepo.Delete(ctx, paw)
}

func (s *AgentService) UpdateStatus(ctx context.Context) error {
    agents, err := s.agentRepo.FindAll(ctx)
    if err != nil {
        return err
    }

    for _, agent := range agents {
        if time.Since(agent.LastSeen) > s.heartbeatTTL && agent.Status == entity.AgentOnline {
            agent.Status = entity.AgentOffline
            s.agentRepo.Update(ctx, agent)
        }
    }

    return nil
}
```

**Fichiers:**
- server/internal/application/agent_service.go
- server/internal/application/agent_service_test.go
- server/internal/application/dto/agent_dto.go

**Definition of Done:**
- [ ] Methode Register pour enregistrer/mettre a jour un agent
- [ ] Methode Heartbeat pour gerer le beaconing avec instructions
- [ ] Methode GetAll avec mise a jour du statut offline
- [ ] Methode GetByPaw pour details d'un agent
- [ ] Methode Delete pour supprimer un agent
- [ ] DTOs request/response definis
- [ ] Tests unitaires avec mocks des repositories
- [ ] Gestion du TTL pour statut offline","backend;application;service;agents;mvp"
"BE-20: Creer TechniqueService - GetAll, GetByID, GetByTactic, Import",Story,"**Objectif:**
Implementer le service applicatif TechniqueService pour gerer les techniques MITRE ATT&CK: listing, filtrage par tactic, et import depuis fichiers YAML.

**Code Go exemple:**
```go
// internal/application/technique_service.go
package application

import (
    ""context""
    ""io/fs""
    ""os""
    ""path/filepath""
    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
    ""autostrike/internal/application/dto""
    ""gopkg.in/yaml.v3""
)

type TechniqueService struct {
    techRepo repository.TechniqueRepository
}

func NewTechniqueService(techRepo repository.TechniqueRepository) *TechniqueService {
    return &TechniqueService{techRepo: techRepo}
}

func (s *TechniqueService) GetAll(ctx context.Context) ([]*dto.TechniqueResponse, error) {
    techniques, err := s.techRepo.FindAll(ctx)
    if err != nil {
        return nil, err
    }

    responses := make([]*dto.TechniqueResponse, len(techniques))
    for i, tech := range techniques {
        responses[i] = dto.TechniqueToResponse(tech)
    }

    return responses, nil
}

func (s *TechniqueService) GetByID(ctx context.Context, id string) (*dto.TechniqueResponse, error) {
    technique, err := s.techRepo.FindByID(ctx, id)
    if err != nil {
        return nil, err
    }

    return dto.TechniqueToResponse(technique), nil
}

func (s *TechniqueService) GetByTactic(ctx context.Context, tactic entity.TacticType) ([]*dto.TechniqueResponse, error) {
    techniques, err := s.techRepo.FindByTactic(ctx, tactic)
    if err != nil {
        return nil, err
    }

    responses := make([]*dto.TechniqueResponse, len(techniques))
    for i, tech := range techniques {
        responses[i] = dto.TechniqueToResponse(tech)
    }

    return responses, nil
}

func (s *TechniqueService) Import(ctx context.Context, dirPath string) (*dto.ImportResult, error) {
    result := &dto.ImportResult{
        Imported: 0,
        Skipped:  0,
        Errors:   []string{},
    }

    err := filepath.WalkDir(dirPath, func(path string, d fs.DirEntry, err error) error {
        if err != nil {
            return err
        }

        if d.IsDir() || filepath.Ext(path) != "".yaml"" {
            return nil
        }

        data, err := os.ReadFile(path)
        if err != nil {
            result.Errors = append(result.Errors, path+"": ""+err.Error())
            result.Skipped++
            return nil
        }

        var techYAML dto.TechniqueYAML
        if err := yaml.Unmarshal(data, &techYAML); err != nil {
            result.Errors = append(result.Errors, path+"": ""+err.Error())
            result.Skipped++
            return nil
        }

        technique := techYAML.ToEntity()

        // Upsert
        existing, _ := s.techRepo.FindByID(ctx, technique.ID)
        if existing != nil {
            if err := s.techRepo.Update(ctx, technique); err != nil {
                result.Errors = append(result.Errors, technique.ID+"": ""+err.Error())
                result.Skipped++
                return nil
            }
        } else {
            if err := s.techRepo.Create(ctx, technique); err != nil {
                result.Errors = append(result.Errors, technique.ID+"": ""+err.Error())
                result.Skipped++
                return nil
            }
        }

        result.Imported++
        return nil
    })

    if err != nil {
        return nil, err
    }

    return result, nil
}

func (s *TechniqueService) GetSafeOnly(ctx context.Context) ([]*dto.TechniqueResponse, error) {
    techniques, err := s.techRepo.FindSafe(ctx)
    if err != nil {
        return nil, err
    }

    responses := make([]*dto.TechniqueResponse, len(techniques))
    for i, tech := range techniques {
        responses[i] = dto.TechniqueToResponse(tech)
    }

    return responses, nil
}
```

```go
// internal/application/dto/technique_dto.go
package dto

type TechniqueYAML struct {
    ID          string   `yaml:""id""`
    Name        string   `yaml:""name""`
    Tactic      string   `yaml:""tactic""`
    Description string   `yaml:""description""`
    Platforms   []string `yaml:""platforms""`
    Executors   []struct {
        Type    string `yaml:""type""`
        Command string `yaml:""command""`
        Cleanup string `yaml:""cleanup""`
        Timeout int    `yaml:""timeout""`
    } `yaml:""executors""`
    Detection []struct {
        Source    string `yaml:""source""`
        Indicator string `yaml:""indicator""`
    } `yaml:""detection""`
    IsSafe     bool     `yaml:""is_safe""`
    References []string `yaml:""references""`
}

type ImportResult struct {
    Imported int      `json:""imported""`
    Skipped  int      `json:""skipped""`
    Errors   []string `json:""errors""`
}
```

**Fichiers:**
- server/internal/application/technique_service.go
- server/internal/application/technique_service_test.go
- server/internal/application/dto/technique_dto.go

**Definition of Done:**
- [ ] Methode GetAll pour lister toutes les techniques
- [ ] Methode GetByID pour details d'une technique
- [ ] Methode GetByTactic pour filtrer par tactic MITRE
- [ ] Methode Import pour charger les techniques depuis YAML
- [ ] Methode GetSafeOnly pour techniques securisees
- [ ] Parsing YAML complet avec validation
- [ ] Tests unitaires avec fixtures YAML
- [ ] Gestion des erreurs d'import detaillee","backend;application;service;techniques;mitre;mvp"
"BE-21: Creer ScenarioService - CRUD, Validate, Clone",Story,"**Objectif:**
Implementer le service applicatif ScenarioService pour gerer les scenarios d'attaque: operations CRUD completes, validation de coherence et clonage de scenarios.

**Code Go exemple:**
```go
// internal/application/scenario_service.go
package application

import (
    ""context""
    ""errors""
    ""time""
    ""github.com/google/uuid""
    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
    ""autostrike/internal/application/dto""
)

var (
    ErrScenarioNotFound     = errors.New(""scenario not found"")
    ErrInvalidScenario      = errors.New(""invalid scenario"")
    ErrTechniqueNotFound    = errors.New(""technique not found in scenario"")
    ErrEmptyPhases          = errors.New(""scenario must have at least one phase"")
)

type ScenarioService struct {
    scenarioRepo  repository.ScenarioRepository
    techniqueRepo repository.TechniqueRepository
}

func NewScenarioService(scenarioRepo repository.ScenarioRepository, techniqueRepo repository.TechniqueRepository) *ScenarioService {
    return &ScenarioService{
        scenarioRepo:  scenarioRepo,
        techniqueRepo: techniqueRepo,
    }
}

func (s *ScenarioService) Create(ctx context.Context, req dto.CreateScenarioRequest) (*dto.ScenarioResponse, error) {
    scenario := &entity.Scenario{
        ID:          uuid.New().String(),
        Name:        req.Name,
        Description: req.Description,
        Phases:      dto.PhasesToEntity(req.Phases),
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }

    if err := s.Validate(ctx, scenario); err != nil {
        return nil, err
    }

    if err := s.scenarioRepo.Create(ctx, scenario); err != nil {
        return nil, err
    }

    return dto.ScenarioToResponse(scenario), nil
}

func (s *ScenarioService) GetByID(ctx context.Context, id string) (*dto.ScenarioResponse, error) {
    scenario, err := s.scenarioRepo.FindByID(ctx, id)
    if err != nil {
        return nil, ErrScenarioNotFound
    }

    return dto.ScenarioToResponse(scenario), nil
}

func (s *ScenarioService) GetAll(ctx context.Context) ([]*dto.ScenarioResponse, error) {
    scenarios, err := s.scenarioRepo.FindAll(ctx)
    if err != nil {
        return nil, err
    }

    responses := make([]*dto.ScenarioResponse, len(scenarios))
    for i, scenario := range scenarios {
        responses[i] = dto.ScenarioToResponse(scenario)
    }

    return responses, nil
}

func (s *ScenarioService) Update(ctx context.Context, id string, req dto.UpdateScenarioRequest) (*dto.ScenarioResponse, error) {
    scenario, err := s.scenarioRepo.FindByID(ctx, id)
    if err != nil {
        return nil, ErrScenarioNotFound
    }

    if req.Name != """" {
        scenario.Name = req.Name
    }
    if req.Description != """" {
        scenario.Description = req.Description
    }
    if len(req.Phases) > 0 {
        scenario.Phases = dto.PhasesToEntity(req.Phases)
    }
    scenario.UpdatedAt = time.Now()

    if err := s.Validate(ctx, scenario); err != nil {
        return nil, err
    }

    if err := s.scenarioRepo.Update(ctx, scenario); err != nil {
        return nil, err
    }

    return dto.ScenarioToResponse(scenario), nil
}

func (s *ScenarioService) Delete(ctx context.Context, id string) error {
    _, err := s.scenarioRepo.FindByID(ctx, id)
    if err != nil {
        return ErrScenarioNotFound
    }

    return s.scenarioRepo.Delete(ctx, id)
}

func (s *ScenarioService) Validate(ctx context.Context, scenario *entity.Scenario) error {
    if len(scenario.Phases) == 0 {
        return ErrEmptyPhases
    }

    for _, phase := range scenario.Phases {
        for _, techID := range phase.Techniques {
            _, err := s.techniqueRepo.FindByID(ctx, techID)
            if err != nil {
                return ErrTechniqueNotFound
            }
        }
    }

    return nil
}

func (s *ScenarioService) Clone(ctx context.Context, id string, newName string) (*dto.ScenarioResponse, error) {
    original, err := s.scenarioRepo.FindByID(ctx, id)
    if err != nil {
        return nil, ErrScenarioNotFound
    }

    cloned := &entity.Scenario{
        ID:          uuid.New().String(),
        Name:        newName,
        Description: original.Description + "" (cloned)"",
        Phases:      make([]entity.Phase, len(original.Phases)),
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }

    for i, phase := range original.Phases {
        cloned.Phases[i] = entity.Phase{
            Name:        phase.Name,
            Description: phase.Description,
            Order:       phase.Order,
            Techniques:  make([]string, len(phase.Techniques)),
        }
        copy(cloned.Phases[i].Techniques, phase.Techniques)
    }

    if err := s.scenarioRepo.Create(ctx, cloned); err != nil {
        return nil, err
    }

    return dto.ScenarioToResponse(cloned), nil
}
```

**Fichiers:**
- server/internal/application/scenario_service.go
- server/internal/application/scenario_service_test.go
- server/internal/application/dto/scenario_dto.go

**Definition of Done:**
- [ ] Methode Create avec validation
- [ ] Methode GetByID et GetAll
- [ ] Methode Update avec validation
- [ ] Methode Delete avec verification d'existence
- [ ] Methode Validate pour verifier les techniques existent
- [ ] Methode Clone pour dupliquer un scenario
- [ ] DTOs request/response complets
- [ ] Tests unitaires couvrant tous les cas
- [ ] Gestion des erreurs metier","backend;application;service;scenarios;mvp"
"BE-22: Creer ExecutionService - Start, Stop, GetStatus, GetResults",Story,"**Objectif:**
Implementer le service applicatif ExecutionService pour orchestrer l'execution des scenarios: demarrage, arret, suivi du statut et collecte des resultats.

**Code Go exemple:**
```go
// internal/application/execution_service.go
package application

import (
    ""context""
    ""errors""
    ""time""
    ""github.com/google/uuid""
    ""autostrike/internal/domain/entity""
    ""autostrike/internal/domain/repository""
    ""autostrike/internal/domain/service""
    ""autostrike/internal/application/dto""
)

var (
    ErrExecutionNotFound = errors.New(""execution not found"")
    ErrExecutionRunning  = errors.New(""execution already running"")
    ErrNoAgentsOnline    = errors.New(""no agents online"")
)

type ExecutionService struct {
    executionRepo repository.ExecutionRepository
    resultRepo    repository.ResultRepository
    scenarioRepo  repository.ScenarioRepository
    agentRepo     repository.AgentRepository
    taskRepo      repository.TaskRepository
    orchestrator  *service.AttackOrchestrator
    notifier      Notifier
}

type Notifier interface {
    Notify(event dto.WSEvent)
}

func NewExecutionService(
    executionRepo repository.ExecutionRepository,
    resultRepo repository.ResultRepository,
    scenarioRepo repository.ScenarioRepository,
    agentRepo repository.AgentRepository,
    taskRepo repository.TaskRepository,
    orchestrator *service.AttackOrchestrator,
    notifier Notifier,
) *ExecutionService {
    return &ExecutionService{
        executionRepo: executionRepo,
        resultRepo:    resultRepo,
        scenarioRepo:  scenarioRepo,
        agentRepo:     agentRepo,
        taskRepo:      taskRepo,
        orchestrator:  orchestrator,
        notifier:      notifier,
    }
}

func (s *ExecutionService) Start(ctx context.Context, req dto.StartExecutionRequest) (*dto.ExecutionResponse, error) {
    // Get scenario
    scenario, err := s.scenarioRepo.FindByID(ctx, req.ScenarioID)
    if err != nil {
        return nil, err
    }

    // Get online agents
    agents, err := s.agentRepo.FindByPaws(ctx, req.AgentPaws)
    if err != nil {
        return nil, err
    }

    onlineAgents := make([]*entity.Agent, 0)
    for _, agent := range agents {
        if agent.Status == entity.AgentOnline {
            onlineAgents = append(onlineAgents, agent)
        }
    }

    if len(onlineAgents) == 0 {
        return nil, ErrNoAgentsOnline
    }

    // Create execution
    execution := &entity.Execution{
        ID:         uuid.New().String(),
        ScenarioID: scenario.ID,
        Status:     ""running"",
        StartedAt:  time.Now(),
    }

    if err := s.executionRepo.Create(ctx, execution); err != nil {
        return nil, err
    }

    // Plan execution
    plan, err := s.orchestrator.PlanExecution(scenario, onlineAgents)
    if err != nil {
        return nil, err
    }

    // Create pending tasks
    for _, task := range plan.Tasks {
        pendingTask := &entity.PendingTask{
            ID:          uuid.New().String(),
            AgentPaw:    task.AgentPaw,
            ExecutionID: execution.ID,
            TechniqueID: task.TechniqueID,
            Command:     task.Command,
            Timeout:     task.Timeout,
            Status:      ""pending"",
        }
        if err := s.taskRepo.Create(ctx, pendingTask); err != nil {
            return nil, err
        }
    }

    // Notify via WebSocket
    s.notifier.Notify(dto.WSEvent{
        Type:      ""execution_started"",
        Timestamp: time.Now(),
        Payload: map[string]interface{}{
            ""execution_id"": execution.ID,
            ""scenario_id"":  scenario.ID,
            ""total_tasks"":  len(plan.Tasks),
        },
    })

    return dto.ExecutionToResponse(execution, len(plan.Tasks), 0), nil
}

func (s *ExecutionService) Stop(ctx context.Context, executionID string) error {
    execution, err := s.executionRepo.FindByID(ctx, executionID)
    if err != nil {
        return ErrExecutionNotFound
    }

    if execution.Status != ""running"" {
        return nil
    }

    // Cancel pending tasks
    if err := s.taskRepo.CancelByExecutionID(ctx, executionID); err != nil {
        return err
    }

    // Update execution status
    now := time.Now()
    execution.Status = ""cancelled""
    execution.CompletedAt = &now

    if err := s.executionRepo.Update(ctx, execution); err != nil {
        return err
    }

    s.notifier.Notify(dto.WSEvent{
        Type:      ""execution_cancelled"",
        Timestamp: time.Now(),
        Payload: map[string]interface{}{
            ""execution_id"": executionID,
        },
    })

    return nil
}

func (s *ExecutionService) GetStatus(ctx context.Context, executionID string) (*dto.ExecutionStatusResponse, error) {
    execution, err := s.executionRepo.FindByID(ctx, executionID)
    if err != nil {
        return nil, ErrExecutionNotFound
    }

    results, err := s.resultRepo.FindByExecutionID(ctx, executionID)
    if err != nil {
        return nil, err
    }

    pendingCount, err := s.taskRepo.CountPendingByExecutionID(ctx, executionID)
    if err != nil {
        return nil, err
    }

    return &dto.ExecutionStatusResponse{
        ID:           execution.ID,
        ScenarioID:   execution.ScenarioID,
        Status:       execution.Status,
        StartedAt:    execution.StartedAt,
        CompletedAt:  execution.CompletedAt,
        TotalTasks:   len(results) + pendingCount,
        Completed:    len(results),
        Pending:      pendingCount,
    }, nil
}

func (s *ExecutionService) GetResults(ctx context.Context, executionID string) ([]*dto.ResultResponse, error) {
    results, err := s.resultRepo.FindByExecutionID(ctx, executionID)
    if err != nil {
        return nil, err
    }

    responses := make([]*dto.ResultResponse, len(results))
    for i, result := range results {
        responses[i] = dto.ResultToResponse(result)
    }

    return responses, nil
}
```

**Fichiers:**
- server/internal/application/execution_service.go
- server/internal/application/execution_service_test.go
- server/internal/application/dto/execution_dto.go

**Definition of Done:**
- [ ] Methode Start pour demarrer une execution
- [ ] Methode Stop pour arreter une execution en cours
- [ ] Methode GetStatus avec progression
- [ ] Methode GetResults pour recuperer les resultats
- [ ] Integration avec AttackOrchestrator
- [ ] Creation des pending_tasks pour les agents
- [ ] Notifications WebSocket pour les evenements
- [ ] Tests unitaires avec mocks
- [ ] Gestion des cas d'erreur","backend;application;service;execution;orchestration;mvp"
"BE-23: Creer handler REST /api/v1/agents",Story,"**Objectif:**
Implementer le handler REST pour l'endpoint /api/v1/agents permettant de lister, consulter et supprimer les agents AutoStrike.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/handlers/agent_handler.go
package handlers

import (
    ""net/http""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/application""
    ""autostrike/internal/application/dto""
)

type AgentHandler struct {
    agentService *application.AgentService
}

func NewAgentHandler(agentService *application.AgentService) *AgentHandler {
    return &AgentHandler{agentService: agentService}
}

// GET /api/v1/agents
func (h *AgentHandler) GetAll(c *gin.Context) {
    agents, err := h.agentService.GetAll(c.Request.Context())
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to fetch agents"",
            ""details"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""agents"": agents,
        ""count"":  len(agents),
    })
}

// GET /api/v1/agents/:paw
func (h *AgentHandler) GetByPaw(c *gin.Context) {
    paw := c.Param(""paw"")

    agent, err := h.agentService.GetByPaw(c.Request.Context(), paw)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            ""error"": ""Agent not found"",
            ""paw"":   paw,
        })
        return
    }

    c.JSON(http.StatusOK, agent)
}

// DELETE /api/v1/agents/:paw
func (h *AgentHandler) Delete(c *gin.Context) {
    paw := c.Param(""paw"")

    if err := h.agentService.Delete(c.Request.Context(), paw); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to delete agent"",
            ""details"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""message"": ""Agent deleted successfully"",
        ""paw"":     paw,
    })
}

// GET /api/v1/agents/online
func (h *AgentHandler) GetOnline(c *gin.Context) {
    agents, err := h.agentService.GetAll(c.Request.Context())
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    online := make([]*dto.AgentResponse, 0)
    for _, agent := range agents {
        if agent.Status == ""online"" {
            online = append(online, agent)
        }
    }

    c.JSON(http.StatusOK, gin.H{
        ""agents"": online,
        ""count"":  len(online),
    })
}

// Register routes
func (h *AgentHandler) RegisterRoutes(router *gin.RouterGroup) {
    agents := router.Group(""/agents"")
    {
        agents.GET("""", h.GetAll)
        agents.GET(""/online"", h.GetOnline)
        agents.GET(""/:paw"", h.GetByPaw)
        agents.DELETE(""/:paw"", h.Delete)
    }
}
```

```go
// internal/infrastructure/api/rest/router.go
package rest

import (
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/infrastructure/api/rest/handlers""
    ""autostrike/internal/infrastructure/api/rest/middleware""
)

func SetupRouter(
    agentHandler *handlers.AgentHandler,
    // ... other handlers
) *gin.Engine {
    router := gin.Default()

    // Middleware
    router.Use(middleware.CORS())
    router.Use(middleware.Logger())

    // API v1
    v1 := router.Group(""/api/v1"")
    {
        agentHandler.RegisterRoutes(v1)
    }

    return router
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/agent_handler.go
- server/internal/infrastructure/api/rest/handlers/agent_handler_test.go
- server/internal/infrastructure/api/rest/router.go

**Definition of Done:**
- [ ] GET /api/v1/agents - Liste tous les agents
- [ ] GET /api/v1/agents/online - Liste agents online
- [ ] GET /api/v1/agents/:paw - Details d'un agent
- [ ] DELETE /api/v1/agents/:paw - Supprimer un agent
- [ ] Responses JSON structurees
- [ ] Gestion des erreurs HTTP appropriee
- [ ] Tests d'integration avec httptest
- [ ] Documentation OpenAPI","backend;api;rest;handlers;agents;mvp"
"BE-24: Creer handler REST /api/v1/agents/:paw/beacon",Story,"**Objectif:**
Implementer le handler REST pour l'endpoint /api/v1/agents/:paw/beacon utilise par les agents pour le beaconing: enregistrement, heartbeat et recuperation des instructions.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/handlers/beacon_handler.go
package handlers

import (
    ""net/http""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/application""
    ""autostrike/internal/application/dto""
)

type BeaconHandler struct {
    agentService *application.AgentService
}

func NewBeaconHandler(agentService *application.AgentService) *BeaconHandler {
    return &BeaconHandler{agentService: agentService}
}

// POST /api/v1/agents/:paw/beacon
func (h *BeaconHandler) Beacon(c *gin.Context) {
    paw := c.Param(""paw"")

    var req dto.HeartbeatRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""Invalid request body"",
            ""details"": err.Error(),
        })
        return
    }

    // Ensure PAW matches
    if req.Paw == """" {
        req.Paw = paw
    } else if req.Paw != paw {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""PAW mismatch"",
        })
        return
    }

    // First beacon = register
    _, err := h.agentService.GetByPaw(c.Request.Context(), paw)
    if err != nil {
        // New agent - register
        registerReq := dto.RegisterAgentRequest{
            Paw:       req.Paw,
            Hostname:  req.Hostname,
            Platform:  req.Platform,
            Username:  req.Username,
            Executors: req.Executors,
            IPAddress: c.ClientIP(),
        }

        if _, err := h.agentService.Register(c.Request.Context(), registerReq); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{
                ""error"": ""Failed to register agent"",
                ""details"": err.Error(),
            })
            return
        }
    }

    // Process heartbeat
    response, err := h.agentService.Heartbeat(c.Request.Context(), req)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to process beacon"",
            ""details"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, response)
}

// Register routes
func (h *BeaconHandler) RegisterRoutes(router *gin.RouterGroup) {
    agents := router.Group(""/agents"")
    {
        agents.POST(""/:paw/beacon"", h.Beacon)
    }
}
```

```go
// internal/application/dto/beacon_dto.go
package dto

type HeartbeatRequest struct {
    Paw       string        `json:""paw""`
    Hostname  string        `json:""hostname"" binding:""required""`
    Platform  string        `json:""platform"" binding:""required""`
    Username  string        `json:""username""`
    Executors []string      `json:""executors"" binding:""required""`
    Results   []TaskResult  `json:""results""`
}

type TaskResult struct {
    ID          string `json:""id""`
    TechniqueID string `json:""technique_id""`
    Status      string `json:""status""`
    Output      string `json:""output""`
    Stderr      string `json:""stderr""`
    ExitCode    int    `json:""exit_code""`
    PID         uint32 `json:""pid""`
}

type HeartbeatResponse struct {
    Paw          string        `json:""paw""`
    Sleep        int           `json:""sleep""`
    Instructions []Instruction `json:""instructions""`
}

type Instruction struct {
    ID          string `json:""id""`
    TechniqueID string `json:""technique_id""`
    Executor    string `json:""executor""`
    Command     string `json:""command""`
    Timeout     int    `json:""timeout""`
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/beacon_handler.go
- server/internal/infrastructure/api/rest/handlers/beacon_handler_test.go
- server/internal/application/dto/beacon_dto.go

**Definition of Done:**
- [ ] POST /api/v1/agents/:paw/beacon implementee
- [ ] Enregistrement automatique des nouveaux agents
- [ ] Heartbeat avec mise a jour last_seen
- [ ] Reception et traitement des resultats d'execution
- [ ] Retour des instructions pending
- [ ] Validation du body JSON
- [ ] Tests d'integration
- [ ] Documentation du protocole beacon","backend;api;rest;handlers;beacon;agents;mvp"
"BE-25: Creer handler REST /api/v1/techniques",Story,"**Objectif:**
Implementer le handler REST pour l'endpoint /api/v1/techniques permettant de lister et consulter les techniques MITRE ATT&CK disponibles.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/handlers/technique_handler.go
package handlers

import (
    ""net/http""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/application""
    ""autostrike/internal/domain/entity""
)

type TechniqueHandler struct {
    techniqueService *application.TechniqueService
}

func NewTechniqueHandler(techniqueService *application.TechniqueService) *TechniqueHandler {
    return &TechniqueHandler{techniqueService: techniqueService}
}

// GET /api/v1/techniques
func (h *TechniqueHandler) GetAll(c *gin.Context) {
    techniques, err := h.techniqueService.GetAll(c.Request.Context())
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to fetch techniques"",
            ""details"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""techniques"": techniques,
        ""count"":      len(techniques),
    })
}

// GET /api/v1/techniques/:id
func (h *TechniqueHandler) GetByID(c *gin.Context) {
    id := c.Param(""id"")

    technique, err := h.techniqueService.GetByID(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            ""error"": ""Technique not found"",
            ""id"":    id,
        })
        return
    }

    c.JSON(http.StatusOK, technique)
}

// GET /api/v1/techniques/tactic/:tactic
func (h *TechniqueHandler) GetByTactic(c *gin.Context) {
    tacticStr := c.Param(""tactic"")
    tactic := entity.TacticType(tacticStr)

    // Validate tactic
    validTactics := []entity.TacticType{
        entity.Reconnaissance,
        entity.ResourceDevelopment,
        entity.InitialAccess,
        entity.Execution,
        entity.Persistence,
        entity.PrivilegeEscalation,
        entity.DefenseEvasion,
        entity.CredentialAccess,
        entity.Discovery,
        entity.LateralMovement,
        entity.Collection,
        entity.CommandAndControl,
        entity.Exfiltration,
        entity.Impact,
    }

    valid := false
    for _, t := range validTactics {
        if t == tactic {
            valid = true
            break
        }
    }

    if !valid {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""Invalid tactic"",
            ""tactic"": tacticStr,
            ""valid_tactics"": validTactics,
        })
        return
    }

    techniques, err := h.techniqueService.GetByTactic(c.Request.Context(), tactic)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""tactic"":     tacticStr,
        ""techniques"": techniques,
        ""count"":      len(techniques),
    })
}

// GET /api/v1/techniques/safe
func (h *TechniqueHandler) GetSafe(c *gin.Context) {
    techniques, err := h.techniqueService.GetSafeOnly(c.Request.Context())
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""techniques"": techniques,
        ""count"":      len(techniques),
    })
}

// POST /api/v1/techniques/import
func (h *TechniqueHandler) Import(c *gin.Context) {
    var req struct {
        Path string `json:""path"" binding:""required""`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    result, err := h.techniqueService.Import(c.Request.Context(), req.Path)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, result)
}

// Register routes
func (h *TechniqueHandler) RegisterRoutes(router *gin.RouterGroup) {
    techniques := router.Group(""/techniques"")
    {
        techniques.GET("""", h.GetAll)
        techniques.GET(""/safe"", h.GetSafe)
        techniques.GET(""/:id"", h.GetByID)
        techniques.GET(""/tactic/:tactic"", h.GetByTactic)
        techniques.POST(""/import"", h.Import)
    }
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/technique_handler.go
- server/internal/infrastructure/api/rest/handlers/technique_handler_test.go

**Definition of Done:**
- [ ] GET /api/v1/techniques - Liste toutes les techniques
- [ ] GET /api/v1/techniques/:id - Details d'une technique
- [ ] GET /api/v1/techniques/tactic/:tactic - Filtre par tactic
- [ ] GET /api/v1/techniques/safe - Techniques securisees
- [ ] POST /api/v1/techniques/import - Import depuis YAML
- [ ] Validation des paramètres tactic
- [ ] Tests d'integration
- [ ] Documentation OpenAPI","backend;api;rest;handlers;techniques;mitre;mvp"
"BE-26: Creer handler REST /api/v1/scenarios",Story,"**Objectif:**
Implementer le handler REST pour l'endpoint /api/v1/scenarios avec les operations CRUD completes sur les scenarios d'attaque.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/handlers/scenario_handler.go
package handlers

import (
    ""net/http""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/application""
    ""autostrike/internal/application/dto""
)

type ScenarioHandler struct {
    scenarioService *application.ScenarioService
}

func NewScenarioHandler(scenarioService *application.ScenarioService) *ScenarioHandler {
    return &ScenarioHandler{scenarioService: scenarioService}
}

// GET /api/v1/scenarios
func (h *ScenarioHandler) GetAll(c *gin.Context) {
    scenarios, err := h.scenarioService.GetAll(c.Request.Context())
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""scenarios"": scenarios,
        ""count"":     len(scenarios),
    })
}

// GET /api/v1/scenarios/:id
func (h *ScenarioHandler) GetByID(c *gin.Context) {
    id := c.Param(""id"")

    scenario, err := h.scenarioService.GetByID(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            ""error"": ""Scenario not found"",
            ""id"":    id,
        })
        return
    }

    c.JSON(http.StatusOK, scenario)
}

// POST /api/v1/scenarios
func (h *ScenarioHandler) Create(c *gin.Context) {
    var req dto.CreateScenarioRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""Invalid request body"",
            ""details"": err.Error(),
        })
        return
    }

    scenario, err := h.scenarioService.Create(c.Request.Context(), req)
    if err != nil {
        status := http.StatusInternalServerError
        if err == application.ErrInvalidScenario || err == application.ErrTechniqueNotFound || err == application.ErrEmptyPhases {
            status = http.StatusBadRequest
        }
        c.JSON(status, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, scenario)
}

// PUT /api/v1/scenarios/:id
func (h *ScenarioHandler) Update(c *gin.Context) {
    id := c.Param(""id"")

    var req dto.UpdateScenarioRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    scenario, err := h.scenarioService.Update(c.Request.Context(), id, req)
    if err != nil {
        status := http.StatusInternalServerError
        if err == application.ErrScenarioNotFound {
            status = http.StatusNotFound
        } else if err == application.ErrTechniqueNotFound {
            status = http.StatusBadRequest
        }
        c.JSON(status, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, scenario)
}

// DELETE /api/v1/scenarios/:id
func (h *ScenarioHandler) Delete(c *gin.Context) {
    id := c.Param(""id"")

    if err := h.scenarioService.Delete(c.Request.Context(), id); err != nil {
        status := http.StatusInternalServerError
        if err == application.ErrScenarioNotFound {
            status = http.StatusNotFound
        }
        c.JSON(status, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""message"": ""Scenario deleted successfully"",
        ""id"":      id,
    })
}

// POST /api/v1/scenarios/:id/clone
func (h *ScenarioHandler) Clone(c *gin.Context) {
    id := c.Param(""id"")

    var req struct {
        Name string `json:""name"" binding:""required""`
    }
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    scenario, err := h.scenarioService.Clone(c.Request.Context(), id, req.Name)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusCreated, scenario)
}

// Register routes
func (h *ScenarioHandler) RegisterRoutes(router *gin.RouterGroup) {
    scenarios := router.Group(""/scenarios"")
    {
        scenarios.GET("""", h.GetAll)
        scenarios.POST("""", h.Create)
        scenarios.GET(""/:id"", h.GetByID)
        scenarios.PUT(""/:id"", h.Update)
        scenarios.DELETE(""/:id"", h.Delete)
        scenarios.POST(""/:id/clone"", h.Clone)
    }
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/scenario_handler.go
- server/internal/infrastructure/api/rest/handlers/scenario_handler_test.go

**Definition of Done:**
- [ ] GET /api/v1/scenarios - Liste tous les scenarios
- [ ] POST /api/v1/scenarios - Creer un scenario
- [ ] GET /api/v1/scenarios/:id - Details d'un scenario
- [ ] PUT /api/v1/scenarios/:id - Modifier un scenario
- [ ] DELETE /api/v1/scenarios/:id - Supprimer un scenario
- [ ] POST /api/v1/scenarios/:id/clone - Cloner un scenario
- [ ] Validation des phases et techniques
- [ ] Tests d'integration
- [ ] Documentation OpenAPI","backend;api;rest;handlers;scenarios;mvp"
"BE-27: Creer handler REST /api/v1/executions",Task,"**Objectif:**
Implementer le handler REST pour l'endpoint /api/v1/executions permettant de gerer les executions de scenarios: demarrage, arret, statut et resultats.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/handlers/execution_handler.go
package handlers

import (
    ""net/http""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/application""
    ""autostrike/internal/application/dto""
)

type ExecutionHandler struct {
    executionService *application.ExecutionService
}

func NewExecutionHandler(executionService *application.ExecutionService) *ExecutionHandler {
    return &ExecutionHandler{executionService: executionService}
}

// POST /api/v1/executions
func (h *ExecutionHandler) Start(c *gin.Context) {
    var req dto.StartExecutionRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""Invalid request body"",
            ""details"": err.Error(),
        })
        return
    }

    execution, err := h.executionService.Start(c.Request.Context(), req)
    if err != nil {
        status := http.StatusInternalServerError
        if err == application.ErrNoAgentsOnline {
            status = http.StatusBadRequest
        }
        c.JSON(status, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusAccepted, execution)
}

// GET /api/v1/executions/:id
func (h *ExecutionHandler) GetStatus(c *gin.Context) {
    id := c.Param(""id"")

    status, err := h.executionService.GetStatus(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            ""error"": ""Execution not found"",
            ""id"":    id,
        })
        return
    }

    c.JSON(http.StatusOK, status)
}

// GET /api/v1/executions/:id/results
func (h *ExecutionHandler) GetResults(c *gin.Context) {
    id := c.Param(""id"")

    results, err := h.executionService.GetResults(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""execution_id"": id,
        ""results"":      results,
        ""count"":        len(results),
    })
}

// POST /api/v1/executions/:id/stop
func (h *ExecutionHandler) Stop(c *gin.Context) {
    id := c.Param(""id"")

    if err := h.executionService.Stop(c.Request.Context(), id); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""message"": ""Execution stopped"",
        ""id"":      id,
    })
}

// GET /api/v1/executions
func (h *ExecutionHandler) GetAll(c *gin.Context) {
    // Optional query params
    scenarioID := c.Query(""scenario_id"")
    status := c.Query(""status"")

    executions, err := h.executionService.GetAll(c.Request.Context(), scenarioID, status)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""executions"": executions,
        ""count"":      len(executions),
    })
}

// Register routes
func (h *ExecutionHandler) RegisterRoutes(router *gin.RouterGroup) {
    executions := router.Group(""/executions"")
    {
        executions.GET("""", h.GetAll)
        executions.POST("""", h.Start)
        executions.GET(""/:id"", h.GetStatus)
        executions.GET(""/:id/results"", h.GetResults)
        executions.POST(""/:id/stop"", h.Stop)
    }
}
```

```go
// internal/application/dto/execution_dto.go
package dto

import ""time""

type StartExecutionRequest struct {
    ScenarioID string   `json:""scenario_id"" binding:""required""`
    AgentPaws  []string `json:""agent_paws"" binding:""required,min=1""`
    SafeMode   bool     `json:""safe_mode""`
}

type ExecutionResponse struct {
    ID          string     `json:""id""`
    ScenarioID  string     `json:""scenario_id""`
    Status      string     `json:""status""`
    StartedAt   time.Time  `json:""started_at""`
    CompletedAt *time.Time `json:""completed_at,omitempty""`
    TotalTasks  int        `json:""total_tasks""`
    Completed   int        `json:""completed""`
}

type ExecutionStatusResponse struct {
    ID          string     `json:""id""`
    ScenarioID  string     `json:""scenario_id""`
    Status      string     `json:""status""`
    StartedAt   time.Time  `json:""started_at""`
    CompletedAt *time.Time `json:""completed_at,omitempty""`
    TotalTasks  int        `json:""total_tasks""`
    Completed   int        `json:""completed""`
    Pending     int        `json:""pending""`
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/execution_handler.go
- server/internal/infrastructure/api/rest/handlers/execution_handler_test.go

**Definition of Done:**
- [ ] POST /api/v1/executions - Demarrer une execution
- [ ] GET /api/v1/executions - Lister les executions
- [ ] GET /api/v1/executions/:id - Statut d'une execution
- [ ] GET /api/v1/executions/:id/results - Resultats d'une execution
- [ ] POST /api/v1/executions/:id/stop - Arreter une execution
- [ ] Support safe_mode dans la requete
- [ ] Response 202 Accepted pour Start
- [ ] Tests d'integration
- [ ] Documentation OpenAPI","backend;api;rest;handlers;executions;mvp"
"BE-28: Creer handler REST /api/v1/reports",Story,"**Objectif:**
Implementer le handler REST pour l'endpoint /api/v1/reports permettant de generer des rapports de securite: couverture MITRE, score de securite et export.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/handlers/report_handler.go
package handlers

import (
    ""net/http""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/application""
)

type ReportHandler struct {
    reportService *application.ReportService
}

func NewReportHandler(reportService *application.ReportService) *ReportHandler {
    return &ReportHandler{reportService: reportService}
}

// GET /api/v1/reports/coverage
func (h *ReportHandler) GetCoverage(c *gin.Context) {
    coverage, err := h.reportService.GetMitreCoverage(c.Request.Context())
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, coverage)
}

// GET /api/v1/reports/score
func (h *ReportHandler) GetScore(c *gin.Context) {
    score, err := h.reportService.CalculateSecurityScore(c.Request.Context())
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, score)
}

// GET /api/v1/reports/export/:format
func (h *ReportHandler) Export(c *gin.Context) {
    format := c.Param(""format"")

    switch format {
    case ""json"":
        report, err := h.reportService.ExportJSON(c.Request.Context())
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{""error"": err.Error()})
            return
        }
        c.Header(""Content-Disposition"", ""attachment; filename=autostrike-report.json"")
        c.Data(http.StatusOK, ""application/json"", report)

    case ""pdf"":
        report, err := h.reportService.ExportPDF(c.Request.Context())
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{""error"": err.Error()})
            return
        }
        c.Header(""Content-Disposition"", ""attachment; filename=autostrike-report.pdf"")
        c.Data(http.StatusOK, ""application/pdf"", report)

    case ""csv"":
        report, err := h.reportService.ExportCSV(c.Request.Context())
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{""error"": err.Error()})
            return
        }
        c.Header(""Content-Disposition"", ""attachment; filename=autostrike-report.csv"")
        c.Data(http.StatusOK, ""text/csv"", report)

    default:
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""Unsupported format"",
            ""supported"": []string{""json"", ""pdf"", ""csv""},
        })
    }
}

// GET /api/v1/reports/techniques/:id
func (h *ReportHandler) GetTechniqueReport(c *gin.Context) {
    id := c.Param(""id"")

    report, err := h.reportService.GetTechniqueReport(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            ""error"": err.Error(),
        })
        return
    }

    c.JSON(http.StatusOK, report)
}

// Register routes
func (h *ReportHandler) RegisterRoutes(router *gin.RouterGroup) {
    reports := router.Group(""/reports"")
    {
        reports.GET(""/coverage"", h.GetCoverage)
        reports.GET(""/score"", h.GetScore)
        reports.GET(""/export/:format"", h.Export)
        reports.GET(""/techniques/:id"", h.GetTechniqueReport)
    }
}
```

```go
// internal/application/report_service.go
package application

type CoverageReport struct {
    TotalTechniques  int                     `json:""total_techniques""`
    TestedTechniques int                     `json:""tested_techniques""`
    CoveragePercent  float64                 `json:""coverage_percent""`
    ByTactic         map[string]TacticStats  `json:""by_tactic""`
    ByStatus         map[string]int          `json:""by_status""`
}

type TacticStats struct {
    Total   int `json:""total""`
    Tested  int `json:""tested""`
    Blocked int `json:""blocked""`
    Detected int `json:""detected""`
    Success int `json:""success""`
}

type SecurityScoreReport struct {
    Score       int     `json:""score""`
    Label       string  `json:""label""`
    Blocked     int     `json:""blocked""`
    Detected    int     `json:""detected""`
    Success     int     `json:""success""`
    Total       int     `json:""total""`
    Trend       string  `json:""trend""`
    LastUpdated string  `json:""last_updated""`
}

type TechniqueReport struct {
    TechniqueID   string           `json:""technique_id""`
    TechniqueName string           `json:""technique_name""`
    Tactic        string           `json:""tactic""`
    TotalTests    int              `json:""total_tests""`
    LastStatus    string           `json:""last_status""`
    History       []ExecutionEntry `json:""history""`
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/report_handler.go
- server/internal/infrastructure/api/rest/handlers/report_handler_test.go
- server/internal/application/report_service.go

**Definition of Done:**
- [ ] GET /api/v1/reports/coverage - Couverture MITRE
- [ ] GET /api/v1/reports/score - Score de securite
- [ ] GET /api/v1/reports/export/:format - Export JSON/PDF/CSV
- [ ] GET /api/v1/reports/techniques/:id - Rapport par technique
- [ ] Calcul du score: blocked=100%, detected=50%, success=0%
- [ ] Stats par tactic MITRE
- [ ] Tests d'integration
- [ ] Documentation OpenAPI","backend;api;rest;handlers;reports;mvp"
"BE-29: Creer middleware authentification JWT",Story,"**Objectif:**
Implementer le middleware d'authentification JWT pour securiser les endpoints API AutoStrike avec gestion des tokens, refresh et roles utilisateurs.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/middleware/auth.go
package middleware

import (
    ""errors""
    ""net/http""
    ""strings""
    ""time""
    ""github.com/gin-gonic/gin""
    ""github.com/golang-jwt/jwt/v5""
)

var (
    ErrMissingToken = errors.New(""missing authorization token"")
    ErrInvalidToken = errors.New(""invalid token"")
    ErrExpiredToken = errors.New(""token expired"")
)

type JWTConfig struct {
    SecretKey     []byte
    AccessExpiry  time.Duration
    RefreshExpiry time.Duration
    Issuer        string
}

type Claims struct {
    UserID   string   `json:""user_id""`
    Username string   `json:""username""`
    Roles    []string `json:""roles""`
    jwt.RegisteredClaims
}

type JWTMiddleware struct {
    config JWTConfig
}

func NewJWTMiddleware(config JWTConfig) *JWTMiddleware {
    return &JWTMiddleware{config: config}
}

func (m *JWTMiddleware) Authenticate() gin.HandlerFunc {
    return func(c *gin.Context) {
        tokenString, err := m.extractToken(c)
        if err != nil {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{
                ""error"": err.Error(),
            })
            return
        }

        claims, err := m.validateToken(tokenString)
        if err != nil {
            status := http.StatusUnauthorized
            if err == ErrExpiredToken {
                status = http.StatusUnauthorized
            }
            c.AbortWithStatusJSON(status, gin.H{
                ""error"": err.Error(),
            })
            return
        }

        // Set user info in context
        c.Set(""user_id"", claims.UserID)
        c.Set(""username"", claims.Username)
        c.Set(""roles"", claims.Roles)

        c.Next()
    }
}

func (m *JWTMiddleware) RequireRole(roles ...string) gin.HandlerFunc {
    return func(c *gin.Context) {
        userRoles, exists := c.Get(""roles"")
        if !exists {
            c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                ""error"": ""No roles found"",
            })
            return
        }

        hasRole := false
        for _, required := range roles {
            for _, userRole := range userRoles.([]string) {
                if userRole == required {
                    hasRole = true
                    break
                }
            }
        }

        if !hasRole {
            c.AbortWithStatusJSON(http.StatusForbidden, gin.H{
                ""error"": ""Insufficient permissions"",
                ""required_roles"": roles,
            })
            return
        }

        c.Next()
    }
}

func (m *JWTMiddleware) extractToken(c *gin.Context) (string, error) {
    authHeader := c.GetHeader(""Authorization"")
    if authHeader == """" {
        return """", ErrMissingToken
    }

    parts := strings.SplitN(authHeader, "" "", 2)
    if len(parts) != 2 || strings.ToLower(parts[0]) != ""bearer"" {
        return """", ErrInvalidToken
    }

    return parts[1], nil
}

func (m *JWTMiddleware) validateToken(tokenString string) (*Claims, error) {
    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, ErrInvalidToken
        }
        return m.config.SecretKey, nil
    })

    if err != nil {
        if errors.Is(err, jwt.ErrTokenExpired) {
            return nil, ErrExpiredToken
        }
        return nil, ErrInvalidToken
    }

    claims, ok := token.Claims.(*Claims)
    if !ok || !token.Valid {
        return nil, ErrInvalidToken
    }

    return claims, nil
}

func (m *JWTMiddleware) GenerateAccessToken(userID, username string, roles []string) (string, error) {
    claims := Claims{
        UserID:   userID,
        Username: username,
        Roles:    roles,
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(time.Now().Add(m.config.AccessExpiry)),
            IssuedAt:  jwt.NewNumericDate(time.Now()),
            Issuer:    m.config.Issuer,
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(m.config.SecretKey)
}

func (m *JWTMiddleware) GenerateRefreshToken(userID string) (string, error) {
    claims := jwt.RegisteredClaims{
        Subject:   userID,
        ExpiresAt: jwt.NewNumericDate(time.Now().Add(m.config.RefreshExpiry)),
        IssuedAt:  jwt.NewNumericDate(time.Now()),
        Issuer:    m.config.Issuer,
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString(m.config.SecretKey)
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/middleware/auth.go
- server/internal/infrastructure/api/rest/middleware/auth_test.go

**Definition of Done:**
- [ ] Middleware Authenticate() pour valider le JWT
- [ ] Middleware RequireRole() pour verifier les permissions
- [ ] Generation access token avec claims personnalises
- [ ] Generation refresh token
- [ ] Extraction token du header Authorization Bearer
- [ ] Gestion expiration et erreurs
- [ ] Tests unitaires complets
- [ ] Configuration externalisee (secret, expiry)","backend;api;rest;middleware;security;jwt;mvp"
"BE-30: Creer handler REST /api/v1/auth (login, refresh, logout)",Story,"**Objectif:**
Implementer le handler REST pour l'endpoint /api/v1/auth avec les operations d'authentification: login, refresh token et logout.

**Code Go exemple:**
```go
// internal/infrastructure/api/rest/handlers/auth_handler.go
package handlers

import (
    ""net/http""
    ""time""
    ""github.com/gin-gonic/gin""
    ""autostrike/internal/application""
    ""autostrike/internal/infrastructure/api/rest/middleware""
)

type AuthHandler struct {
    authService   *application.AuthService
    jwtMiddleware *middleware.JWTMiddleware
}

func NewAuthHandler(authService *application.AuthService, jwtMiddleware *middleware.JWTMiddleware) *AuthHandler {
    return &AuthHandler{
        authService:   authService,
        jwtMiddleware: jwtMiddleware,
    }
}

// POST /api/v1/auth/login
func (h *AuthHandler) Login(c *gin.Context) {
    var req struct {
        Username string `json:""username"" binding:""required""`
        Password string `json:""password"" binding:""required""`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""Invalid request body"",
        })
        return
    }

    user, err := h.authService.ValidateCredentials(c.Request.Context(), req.Username, req.Password)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{
            ""error"": ""Invalid credentials"",
        })
        return
    }

    // Generate tokens
    accessToken, err := h.jwtMiddleware.GenerateAccessToken(user.ID, user.Username, user.Roles)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to generate access token"",
        })
        return
    }

    refreshToken, err := h.jwtMiddleware.GenerateRefreshToken(user.ID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to generate refresh token"",
        })
        return
    }

    // Store refresh token
    if err := h.authService.StoreRefreshToken(c.Request.Context(), user.ID, refreshToken); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to store refresh token"",
        })
        return
    }

    c.JSON(http.StatusOK, gin.H{
        ""access_token"":  accessToken,
        ""refresh_token"": refreshToken,
        ""token_type"":    ""Bearer"",
        ""expires_in"":    3600, // 1 hour
        ""user"": gin.H{
            ""id"":       user.ID,
            ""username"": user.Username,
            ""roles"":    user.Roles,
        },
    })
}

// POST /api/v1/auth/refresh
func (h *AuthHandler) Refresh(c *gin.Context) {
    var req struct {
        RefreshToken string `json:""refresh_token"" binding:""required""`
    }

    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            ""error"": ""Invalid request body"",
        })
        return
    }

    // Validate refresh token
    userID, err := h.authService.ValidateRefreshToken(c.Request.Context(), req.RefreshToken)
    if err != nil {
        c.JSON(http.StatusUnauthorized, gin.H{
            ""error"": ""Invalid refresh token"",
        })
        return
    }

    // Get user details
    user, err := h.authService.GetUserByID(c.Request.Context(), userID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""User not found"",
        })
        return
    }

    // Generate new access token
    accessToken, err := h.jwtMiddleware.GenerateAccessToken(user.ID, user.Username, user.Roles)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to generate access token"",
        })
        return
    }

    // Optionally rotate refresh token
    newRefreshToken, err := h.jwtMiddleware.GenerateRefreshToken(user.ID)
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            ""error"": ""Failed to generate refresh token"",
        })
        return
    }

    // Revoke old, store new
    h.authService.RevokeRefreshToken(c.Request.Context(), req.RefreshToken)
    h.authService.StoreRefreshToken(c.Request.Context(), user.ID, newRefreshToken)

    c.JSON(http.StatusOK, gin.H{
        ""access_token"":  accessToken,
        ""refresh_token"": newRefreshToken,
        ""token_type"":    ""Bearer"",
        ""expires_in"":    3600,
    })
}

// POST /api/v1/auth/logout
func (h *AuthHandler) Logout(c *gin.Context) {
    var req struct {
        RefreshToken string `json:""refresh_token""`
    }

    c.ShouldBindJSON(&req)

    // Get user ID from context (set by auth middleware)
    userID, exists := c.Get(""user_id"")
    if exists {
        // Revoke all refresh tokens for this user
        h.authService.RevokeAllRefreshTokens(c.Request.Context(), userID.(string))
    } else if req.RefreshToken != """" {
        // Revoke specific refresh token
        h.authService.RevokeRefreshToken(c.Request.Context(), req.RefreshToken)
    }

    c.JSON(http.StatusOK, gin.H{
        ""message"": ""Logged out successfully"",
    })
}

// GET /api/v1/auth/me
func (h *AuthHandler) Me(c *gin.Context) {
    userID, _ := c.Get(""user_id"")
    username, _ := c.Get(""username"")
    roles, _ := c.Get(""roles"")

    c.JSON(http.StatusOK, gin.H{
        ""id"":       userID,
        ""username"": username,
        ""roles"":    roles,
    })
}

// Register routes
func (h *AuthHandler) RegisterRoutes(router *gin.RouterGroup, jwtMiddleware *middleware.JWTMiddleware) {
    auth := router.Group(""/auth"")
    {
        // Public routes
        auth.POST(""/login"", h.Login)
        auth.POST(""/refresh"", h.Refresh)

        // Protected routes
        protected := auth.Group("""")
        protected.Use(jwtMiddleware.Authenticate())
        {
            protected.POST(""/logout"", h.Logout)
            protected.GET(""/me"", h.Me)
        }
    }
}
```

```go
// internal/application/auth_service.go
package application

type User struct {
    ID       string   `json:""id""`
    Username string   `json:""username""`
    Password string   `json:""-""`
    Roles    []string `json:""roles""`
}

type AuthService struct {
    userRepo  repository.UserRepository
    tokenRepo repository.TokenRepository
}

func (s *AuthService) ValidateCredentials(ctx context.Context, username, password string) (*User, error) {
    user, err := s.userRepo.FindByUsername(ctx, username)
    if err != nil {
        return nil, err
    }

    if !bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)) {
        return nil, errors.New(""invalid credentials"")
    }

    return user, nil
}
```

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/auth_handler.go
- server/internal/infrastructure/api/rest/handlers/auth_handler_test.go
- server/internal/application/auth_service.go

**Definition of Done:**
- [ ] POST /api/v1/auth/login - Authentification
- [ ] POST /api/v1/auth/refresh - Renouvellement token
- [ ] POST /api/v1/auth/logout - Deconnexion
- [ ] GET /api/v1/auth/me - Profil utilisateur connecte
- [ ] Validation des credentials avec bcrypt
- [ ] Stockage et revocation des refresh tokens
- [ ] Rotation des refresh tokens
- [ ] Tests d'integration
- [ ] Documentation OpenAPI","backend;api;rest;handlers;auth;security;mvp"
"[BE-31] Creer middleware logging",Task,"**Objectif:** Implementer un middleware de logging structure pour toutes les requetes API avec correlation ID et metriques de performance.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/rest/middleware/logging.go
package middleware

import (
    \"time\"
    \"github.com/gin-gonic/gin\"
    \"github.com/google/uuid\"
    \"go.uber.org/zap\"
)

func LoggingMiddleware(logger *zap.Logger) gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        correlationID := uuid.New().String()
        c.Set(\"correlation_id\", correlationID)
        c.Header(\"X-Correlation-ID\", correlationID)

        c.Next()

        duration := time.Since(start)
        logger.Info(\"request\",
            zap.String(\"correlation_id\", correlationID),
            zap.String(\"method\", c.Request.Method),
            zap.String(\"path\", c.Request.URL.Path),
            zap.Int(\"status\", c.Writer.Status()),
            zap.Duration(\"duration\", duration),
            zap.String(\"client_ip\", c.ClientIP()),
        )
    }
}
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/rest/middleware/logging.go
- server/internal/infrastructure/api/rest/middleware/logging_test.go

**Definition of Done:**
- [ ] Middleware logging implemente avec zap logger
- [ ] Correlation ID genere pour chaque requete
- [ ] Duree, status, methode, path logues
- [ ] Header X-Correlation-ID ajoute aux reponses
- [ ] Tests unitaires couvrant les cas nominaux
- [ ] Integration dans le router principal",backend;middleware
"[BE-32] Creer middleware rate limiting",Task,"**Objectif:** Implementer un middleware de rate limiting pour proteger l'API contre les abus avec configuration par endpoint.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/rest/middleware/ratelimit.go
package middleware

import (
    \"net/http\"
    \"sync\"
    \"time\"
    \"github.com/gin-gonic/gin\"
    \"golang.org/x/time/rate\"
)

type RateLimiter struct {
    visitors map[string]*rate.Limiter
    mu       sync.RWMutex
    rate     rate.Limit
    burst    int
}

func NewRateLimiter(r rate.Limit, b int) *RateLimiter {
    return &RateLimiter{
        visitors: make(map[string]*rate.Limiter),
        rate:     r,
        burst:    b,
    }
}

func (rl *RateLimiter) GetLimiter(ip string) *rate.Limiter {
    rl.mu.Lock()
    defer rl.mu.Unlock()

    limiter, exists := rl.visitors[ip]
    if !exists {
        limiter = rate.NewLimiter(rl.rate, rl.burst)
        rl.visitors[ip] = limiter
    }
    return limiter
}

func RateLimitMiddleware(rl *RateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        limiter := rl.GetLimiter(c.ClientIP())
        if !limiter.Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{
                \"error\": \"rate limit exceeded\",
                \"retry_after\": \"60s\",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/rest/middleware/ratelimit.go
- server/internal/infrastructure/api/rest/middleware/ratelimit_test.go

**Definition of Done:**
- [ ] Rate limiter par IP implemente
- [ ] Configuration rate et burst parametrable
- [ ] Reponse 429 avec header Retry-After
- [ ] Nettoyage periodique des limiters inactifs
- [ ] Tests unitaires avec simulation de depassement
- [ ] Documentation des limites par defaut",backend;middleware
"[BE-33] Creer middleware CORS",Task,"**Objectif:** Configurer CORS pour permettre les requetes cross-origin du dashboard React vers l'API backend.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/rest/middleware/cors.go
package middleware

import (
    \"github.com/gin-gonic/gin\"
)

type CORSConfig struct {
    AllowedOrigins   []string
    AllowedMethods   []string
    AllowedHeaders   []string
    AllowCredentials bool
    MaxAge           int
}

func DefaultCORSConfig() CORSConfig {
    return CORSConfig{
        AllowedOrigins:   []string{\"https://localhost:3000\", \"https://localhost:5173\"},
        AllowedMethods:   []string{\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"},
        AllowedHeaders:   []string{\"Origin\", \"Content-Type\", \"Authorization\", \"X-Correlation-ID\"},
        AllowCredentials: true,
        MaxAge:           86400,
    }
}

func CORSMiddleware(config CORSConfig) gin.HandlerFunc {
    return func(c *gin.Context) {
        origin := c.Request.Header.Get(\"Origin\")
        for _, allowed := range config.AllowedOrigins {
            if origin == allowed {
                c.Header(\"Access-Control-Allow-Origin\", origin)
                break
            }
        }
        c.Header(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS\")
        c.Header(\"Access-Control-Allow-Headers\", \"Origin, Content-Type, Authorization\")
        c.Header(\"Access-Control-Allow-Credentials\", \"true\")
        c.Header(\"Access-Control-Max-Age\", \"86400\")

        if c.Request.Method == \"OPTIONS\" {
            c.AbortWithStatus(204)
            return
        }
        c.Next()
    }
}
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/rest/middleware/cors.go
- server/internal/infrastructure/api/rest/middleware/cors_test.go

**Definition of Done:**
- [ ] CORS middleware configure pour origines dashboard
- [ ] Support des methodes GET, POST, PUT, DELETE, OPTIONS
- [ ] Headers Authorization et Content-Type autorises
- [ ] Preflight OPTIONS requests geres correctement
- [ ] Configuration externalisable via config.yaml
- [ ] Tests unitaires validant les headers CORS",backend;middleware
"[BE-34] Creer service AttackOrchestrator",Task,"**Objectif:** Implementer le service domain AttackOrchestrator pour planifier l'execution des scenarios, selectionner les agents compatibles et dispatcher les taches.

**Code Go exemple:**
\`\`\`go
// internal/domain/service/orchestrator.go
package service

import (
    \"autostrike/internal/domain/entity\"
    \"autostrike/internal/domain/repository\"
    \"github.com/google/uuid\"
)

type AttackOrchestrator struct {
    agentRepo    repository.AgentRepository
    techRepo     repository.TechniqueRepository
    taskRepo     repository.TaskRepository
    validator    *TechniqueValidator
}

type ExecutionPlan struct {
    ID     string
    Tasks  []PlannedTask
}

type PlannedTask struct {
    TechniqueID string
    AgentPaw    string
    Phase       string
    Order       int
    Command     string
    Timeout     int
}

func NewAttackOrchestrator(
    agentRepo repository.AgentRepository,
    techRepo repository.TechniqueRepository,
    taskRepo repository.TaskRepository,
    validator *TechniqueValidator,
) *AttackOrchestrator {
    return &AttackOrchestrator{
        agentRepo: agentRepo,
        techRepo:  techRepo,
        taskRepo:  taskRepo,
        validator: validator,
    }
}

func (o *AttackOrchestrator) PlanExecution(
    scenario *entity.Scenario,
    targetAgents []*entity.Agent,
    safeMode bool,
) (*ExecutionPlan, error) {
    plan := &ExecutionPlan{
        ID:    uuid.New().String(),
        Tasks: make([]PlannedTask, 0),
    }

    for _, phase := range scenario.Phases {
        for _, techID := range phase.Techniques {
            technique, err := o.techRepo.FindByID(techID)
            if err != nil {
                continue
            }
            if safeMode && !technique.IsSafe {
                continue
            }
            agent := o.selectCompatibleAgent(technique, targetAgents)
            if agent == nil {
                continue
            }
            executor := o.selectBestExecutor(technique, agent)
            plan.Tasks = append(plan.Tasks, PlannedTask{
                TechniqueID: techID,
                AgentPaw:    agent.Paw,
                Phase:       phase.Name,
                Order:       len(plan.Tasks),
                Command:     executor.Command,
                Timeout:     executor.Timeout,
            })
        }
    }
    return plan, nil
}

func (o *AttackOrchestrator) selectCompatibleAgent(
    tech *entity.Technique,
    agents []*entity.Agent,
) *entity.Agent {
    for _, agent := range agents {
        if o.validator.IsCompatible(agent, tech) && agent.Status == entity.AgentOnline {
            return agent
        }
    }
    return nil
}

func (o *AttackOrchestrator) selectBestExecutor(
    tech *entity.Technique,
    agent *entity.Agent,
) *entity.Executor {
    priority := map[string]int{\"psh\": 1, \"cmd\": 2, \"bash\": 3, \"sh\": 4}
    var best *entity.Executor
    bestPriority := 999
    for i, exec := range tech.Executors {
        for _, agentExec := range agent.Executors {
            if exec.Type == agentExec {
                if p := priority[exec.Type]; p < bestPriority {
                    bestPriority = p
                    best = &tech.Executors[i]
                }
            }
        }
    }
    return best
}
\`\`\`

**Fichiers:**
- server/internal/domain/service/orchestrator.go
- server/internal/domain/service/orchestrator_test.go

**Definition of Done:**
- [ ] PlanExecution genere un plan ordonne de taches
- [ ] Selection automatique des agents compatibles
- [ ] Support du mode safe (techniques is_safe uniquement)
- [ ] Selection du meilleur executor par priorite
- [ ] Gestion des cas sans agent compatible
- [ ] Tests unitaires avec mocks des repositories",backend;domain
"[BE-35] Creer service TechniqueValidator",Task,"**Objectif:** Implementer le service domain TechniqueValidator pour verifier la compatibilite agent/technique et appliquer le mode safe.

**Code Go exemple:**
\`\`\`go
// internal/domain/service/validator.go
package service

import (
    \"autostrike/internal/domain/entity\"
)

type TechniqueValidator struct{}

func NewTechniqueValidator() *TechniqueValidator {
    return &TechniqueValidator{}
}

func (v *TechniqueValidator) IsCompatible(agent *entity.Agent, technique *entity.Technique) bool {
    if !v.isPlatformCompatible(agent.Platform, technique.Platforms) {
        return false
    }
    if !v.hasCompatibleExecutor(agent.Executors, technique.Executors) {
        return false
    }
    return true
}

func (v *TechniqueValidator) isPlatformCompatible(agentPlatform string, techPlatforms []string) bool {
    for _, p := range techPlatforms {
        if p == agentPlatform {
            return true
        }
    }
    return false
}

func (v *TechniqueValidator) hasCompatibleExecutor(agentExecutors []string, techExecutors []entity.Executor) bool {
    for _, te := range techExecutors {
        for _, ae := range agentExecutors {
            if te.Type == ae {
                return true
            }
        }
    }
    return false
}

func (v *TechniqueValidator) ValidateForExecution(
    technique *entity.Technique,
    safeMode bool,
) error {
    if safeMode && !technique.IsSafe {
        return ErrTechniqueNotSafe
    }
    if len(technique.Executors) == 0 {
        return ErrNoExecutorDefined
    }
    return nil
}

func (v *TechniqueValidator) FilterSafeTechniques(techniques []*entity.Technique) []*entity.Technique {
    safe := make([]*entity.Technique, 0)
    for _, t := range techniques {
        if t.IsSafe {
            safe = append(safe, t)
        }
    }
    return safe
}

var (
    ErrTechniqueNotSafe  = errors.New(\"technique not safe for production\")
    ErrNoExecutorDefined = errors.New(\"no executor defined for technique\")
)
\`\`\`

**Fichiers:**
- server/internal/domain/service/validator.go
- server/internal/domain/service/validator_test.go

**Definition of Done:**
- [ ] Validation compatibilite plateforme (windows/linux/darwin)
- [ ] Validation compatibilite executor (psh/cmd/bash)
- [ ] Filtrage des techniques safe mode
- [ ] Erreurs explicites pour techniques non compatibles
- [ ] Tests unitaires couvrant toutes les combinaisons
- [ ] Documentation des regles de validation",backend;domain
"[BE-36] Creer service ScoreCalculator",Task,"**Objectif:** Implementer le service domain ScoreCalculator pour calculer le score de securite selon la formule: (blocked*100 + detected*50) / (total*100).

**Code Go exemple:**
\`\`\`go
// internal/domain/service/score_calculator.go
package service

import (
    \"autostrike/internal/domain/entity\"
    \"math\"
)

type ScoreCalculator struct{}

type SecurityScore struct {
    Score           float64
    Label           string
    TotalTested     int
    Blocked         int
    Detected        int
    Success         int
    Failed          int
    Coverage        float64
    TrendDirection  string
    TrendValue      float64
}

func NewScoreCalculator() *ScoreCalculator {
    return &ScoreCalculator{}
}

func (c *ScoreCalculator) Calculate(results []entity.ExecutionResult) SecurityScore {
    if len(results) == 0 {
        return SecurityScore{Score: 0, Label: \"Non teste\"}
    }

    var blocked, detected, success, failed int
    for _, r := range results {
        switch r.Status {
        case entity.StatusBlocked:
            blocked++
        case entity.StatusDetected:
            detected++
        case entity.StatusSuccess:
            success++
        case entity.StatusFailed:
            failed++
        }
    }

    total := blocked + detected + success
    if total == 0 {
        return SecurityScore{Score: 0, Label: \"Non teste\"}
    }

    points := float64(blocked*100 + detected*50)
    maxPoints := float64(total * 100)
    score := math.Round((points / maxPoints) * 100)

    return SecurityScore{
        Score:       score,
        Label:       c.getScoreLabel(score),
        TotalTested: total,
        Blocked:     blocked,
        Detected:    detected,
        Success:     success,
        Failed:      failed,
        Coverage:    float64(total) / float64(len(results)) * 100,
    }
}

func (c *ScoreCalculator) getScoreLabel(score float64) string {
    switch {
    case score >= 80:
        return \"Excellent\"
    case score >= 60:
        return \"Bon\"
    case score >= 40:
        return \"A ameliorer\"
    default:
        return \"Critique\"
    }
}

func (c *ScoreCalculator) CalculateTrend(current, previous SecurityScore) (string, float64) {
    diff := current.Score - previous.Score
    if diff > 0 {
        return \"up\", diff
    } else if diff < 0 {
        return \"down\", -diff
    }
    return \"stable\", 0
}
\`\`\`

**Fichiers:**
- server/internal/domain/service/score_calculator.go
- server/internal/domain/service/score_calculator_test.go

**Definition of Done:**
- [ ] Formule score implementee: (blocked*100 + detected*50) / (total*100)
- [ ] Labels calcules (Excellent/Bon/A ameliorer/Critique)
- [ ] Compteurs par status (blocked/detected/success/failed)
- [ ] Calcul du coverage (% techniques testees)
- [ ] Calcul de tendance vs execution precedente
- [ ] Tests unitaires avec cas limites (0 resultats, 100% blocked)",backend;domain
"[BE-37] Implementer WebSocket server",Task,"**Objectif:** Implementer le serveur WebSocket avec gorilla/websocket pour les notifications temps reel, incluant hub de broadcast et gestion des clients.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/websocket/hub.go
package websocket

import (
    \"sync\"
)

type Hub struct {
    clients    map[*Client]bool
    broadcast  chan []byte
    register   chan *Client
    unregister chan *Client
    mu         sync.RWMutex
}

func NewHub() *Hub {
    return &Hub{
        clients:    make(map[*Client]bool),
        broadcast:  make(chan []byte, 256),
        register:   make(chan *Client),
        unregister: make(chan *Client),
    }
}

func (h *Hub) Run() {
    for {
        select {
        case client := <-h.register:
            h.mu.Lock()
            h.clients[client] = true
            h.mu.Unlock()
        case client := <-h.unregister:
            h.mu.Lock()
            if _, ok := h.clients[client]; ok {
                delete(h.clients, client)
                close(client.send)
            }
            h.mu.Unlock()
        case message := <-h.broadcast:
            h.mu.RLock()
            for client := range h.clients {
                select {
                case client.send <- message:
                default:
                    close(client.send)
                    delete(h.clients, client)
                }
            }
            h.mu.RUnlock()
        }
    }
}

func (h *Hub) Broadcast(message []byte) {
    h.broadcast <- message
}

func (h *Hub) ClientCount() int {
    h.mu.RLock()
    defer h.mu.RUnlock()
    return len(h.clients)
}
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/websocket/hub.go
- server/internal/infrastructure/api/websocket/client.go
- server/internal/infrastructure/api/websocket/hub_test.go

**Definition of Done:**
- [ ] Hub WebSocket avec pattern broadcast
- [ ] Gestion register/unregister des clients
- [ ] Channel bufferise pour eviter blocage
- [ ] Mutex pour acces concurrent safe
- [ ] Nettoyage automatique clients deconnectes
- [ ] Tests unitaires de concurrence",backend;websocket
"[BE-38] Creer WebSocket handler /ws/live",Task,"**Objectif:** Creer le handler WebSocket pour l'endpoint /ws/live avec authentification JWT et gestion des evenements temps reel.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/websocket/handler.go
package websocket

import (
    \"net/http\"
    \"time\"
    \"github.com/gin-gonic/gin\"
    \"github.com/gorilla/websocket\"
)

var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    CheckOrigin: func(r *http.Request) bool {
        origin := r.Header.Get(\"Origin\")
        return origin == \"https://localhost:3000\" || origin == \"https://localhost:5173\"
    },
}

type Client struct {
    hub      *Hub
    conn     *websocket.Conn
    send     chan []byte
    userID   string
    filters  map[string]string
}

func HandleWebSocket(hub *Hub) gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.Query(\"token\")
        if token == \"\" {
            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"missing token\"})
            return
        }

        userID, err := validateToken(token)
        if err != nil {
            c.JSON(http.StatusUnauthorized, gin.H{\"error\": \"invalid token\"})
            return
        }

        conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
        if err != nil {
            return
        }

        client := &Client{
            hub:     hub,
            conn:    conn,
            send:    make(chan []byte, 256),
            userID:  userID,
            filters: make(map[string]string),
        }

        if execID := c.Query(\"execution\"); execID != \"\" {
            client.filters[\"execution_id\"] = execID
        }

        hub.register <- client

        go client.writePump()
        go client.readPump()
    }
}

func (c *Client) writePump() {
    ticker := time.NewTicker(30 * time.Second)
    defer func() {
        ticker.Stop()
        c.conn.Close()
    }()

    for {
        select {
        case message, ok := <-c.send:
            if !ok {
                c.conn.WriteMessage(websocket.CloseMessage, []byte{})
                return
            }
            c.conn.WriteMessage(websocket.TextMessage, message)
        case <-ticker.C:
            if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
                return
            }
        }
    }
}

func (c *Client) readPump() {
    defer func() {
        c.hub.unregister <- c
        c.conn.Close()
    }()

    c.conn.SetReadLimit(512)
    c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
    c.conn.SetPongHandler(func(string) error {
        c.conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        return nil
    })

    for {
        _, _, err := c.conn.ReadMessage()
        if err != nil {
            break
        }
    }
}
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/websocket/handler.go
- server/internal/infrastructure/api/websocket/handler_test.go

**Definition of Done:**
- [ ] Upgrade HTTP vers WebSocket fonctionnel
- [ ] Authentification par token query parameter
- [ ] Filtrage par execution_id optionnel
- [ ] Ping/Pong heartbeat toutes les 30s
- [ ] Gestion propre de la deconnexion
- [ ] Tests d'integration avec client mock",backend;websocket
"[BE-39] Creer systeme de notifications",Task,"**Objectif:** Implementer le systeme de notifications temps reel avec types d'evenements: agent_connected, execution_started, technique_completed, etc.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/websocket/notifications.go
package websocket

import (
    \"encoding/json\"
    \"time\"
)

type EventType string

const (
    EventAgentConnected     EventType = \"agent_connected\"
    EventAgentDisconnected  EventType = \"agent_disconnected\"
    EventExecutionStarted   EventType = \"execution_started\"
    EventTechniqueStarted   EventType = \"technique_started\"
    EventTechniqueCompleted EventType = \"technique_completed\"
    EventExecutionCompleted EventType = \"execution_completed\"
    EventError              EventType = \"error\"
)

type WSEvent struct {
    Type      EventType   `json:\"type\"`
    Timestamp string      `json:\"timestamp\"`
    Payload   interface{} `json:\"payload\"`
}

type NotificationService struct {
    hub *Hub
}

func NewNotificationService(hub *Hub) *NotificationService {
    return &NotificationService{hub: hub}
}

func (n *NotificationService) emit(eventType EventType, payload interface{}) {
    event := WSEvent{
        Type:      eventType,
        Timestamp: time.Now().UTC().Format(time.RFC3339),
        Payload:   payload,
    }
    data, _ := json.Marshal(event)
    n.hub.Broadcast(data)
}

func (n *NotificationService) AgentConnected(paw, hostname, platform string) {
    n.emit(EventAgentConnected, map[string]string{
        \"paw\":      paw,
        \"hostname\": hostname,
        \"platform\": platform,
    })
}

func (n *NotificationService) AgentDisconnected(paw string) {
    n.emit(EventAgentDisconnected, map[string]string{\"paw\": paw})
}

func (n *NotificationService) ExecutionStarted(execID, scenarioID string, totalTechniques int) {
    n.emit(EventExecutionStarted, map[string]interface{}{
        \"execution_id\": execID,
        \"scenario_id\":  scenarioID,
        \"total\":        totalTechniques,
    })
}

func (n *NotificationService) TechniqueCompleted(execID, techID, agentPaw, status string, durationMs int64) {
    n.emit(EventTechniqueCompleted, map[string]interface{}{
        \"execution_id\":  execID,
        \"technique_id\":  techID,
        \"agent_paw\":     agentPaw,
        \"status\":        status,
        \"duration_ms\":   durationMs,
    })
}

func (n *NotificationService) ExecutionCompleted(execID string, score float64) {
    n.emit(EventExecutionCompleted, map[string]interface{}{
        \"execution_id\": execID,
        \"score\":        score,
    })
}
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/websocket/notifications.go
- server/internal/infrastructure/api/websocket/notifications_test.go

**Definition of Done:**
- [ ] Types d'evenements definis (agent, execution, technique)
- [ ] Format JSON standardise avec timestamp ISO8601
- [ ] Service notification injectable dans les handlers
- [ ] Broadcast vers tous les clients connectes
- [ ] Tests unitaires de serialisation JSON
- [ ] Documentation du format des evenements",backend;websocket
"[BE-40] Parser YAML techniques MITRE",Task,"**Objectif:** Implementer le parser YAML pour charger les definitions de techniques MITRE ATT&CK et les importer en base de donnees.

**Code Go exemple:**
\`\`\`go
// pkg/mitre/parser.go
package mitre

import (
    \"os\"
    \"path/filepath\"
    \"autostrike/internal/domain/entity\"
    \"gopkg.in/yaml.v3\"
)

type TechniqueYAML struct {
    ID          string          `yaml:\"id\"`
    Name        string          `yaml:\"name\"`
    Tactic      string          `yaml:\"tactic\"`
    Description string          `yaml:\"description\"`
    Platforms   []string        `yaml:\"platforms\"`
    Executors   []ExecutorYAML  `yaml:\"executors\"`
    Detection   []DetectionYAML `yaml:\"detection\"`
    IsSafe      bool            `yaml:\"is_safe\"`
    References  []string        `yaml:\"references\"`
}

type ExecutorYAML struct {
    Type    string `yaml:\"type\"`
    Command string `yaml:\"command\"`
    Cleanup string `yaml:\"cleanup\"`
    Timeout int    `yaml:\"timeout\"`
}

type DetectionYAML struct {
    Source    string `yaml:\"source\"`
    Indicator string `yaml:\"indicator\"`
}

type Parser struct {
    techniquesDir string
}

func NewParser(dir string) *Parser {
    return &Parser{techniquesDir: dir}
}

func (p *Parser) ParseFile(path string) (*entity.Technique, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, err
    }

    var yaml TechniqueYAML
    if err := yaml.Unmarshal(data, &yaml); err != nil {
        return nil, err
    }

    return p.toEntity(&yaml), nil
}

func (p *Parser) ParseAll() ([]*entity.Technique, error) {
    techniques := make([]*entity.Technique, 0)

    files, err := filepath.Glob(filepath.Join(p.techniquesDir, \"*.yaml\"))
    if err != nil {
        return nil, err
    }

    for _, file := range files {
        tech, err := p.ParseFile(file)
        if err != nil {
            continue
        }
        techniques = append(techniques, tech)
    }
    return techniques, nil
}

func (p *Parser) toEntity(yaml *TechniqueYAML) *entity.Technique {
    executors := make([]entity.Executor, len(yaml.Executors))
    for i, e := range yaml.Executors {
        executors[i] = entity.Executor{
            Type:    e.Type,
            Command: e.Command,
            Cleanup: e.Cleanup,
            Timeout: e.Timeout,
        }
    }
    return &entity.Technique{
        ID:          yaml.ID,
        Name:        yaml.Name,
        Tactic:      entity.TacticType(yaml.Tactic),
        Description: yaml.Description,
        Platforms:   yaml.Platforms,
        Executors:   executors,
        IsSafe:      yaml.IsSafe,
        References:  yaml.References,
    }
}
\`\`\`

**Fichiers:**
- server/pkg/mitre/parser.go
- server/pkg/mitre/parser_test.go

**Definition of Done:**
- [ ] Parsing YAML avec gopkg.in/yaml.v3
- [ ] Conversion vers entites domain
- [ ] ParseAll pour charger tout le repertoire
- [ ] Validation des champs obligatoires
- [ ] Gestion des erreurs de parsing
- [ ] Tests avec fichiers YAML de test",backend;mitre
"[BE-41] Creer definition YAML T1082",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1082 - System Information Discovery (systeminfo, Get-ComputerInfo).

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1082.yaml
id: \"T1082\"
name: \"System Information Discovery\"
tactic: \"discovery\"
description: |
  An adversary may attempt to get detailed information about the
  operating system and hardware, including version, patches, hotfixes,
  service packs, and architecture.

platforms:
  - windows
  - linux
  - macos

executors:
  - type: psh
    command: |
      systeminfo
      Get-ComputerInfo | Select-Object WindowsVersion, OsHardwareAbstractionLayer, OsBuildNumber
      Get-WmiObject Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber
    cleanup: null
    timeout: 60

  - type: cmd
    command: |
      systeminfo
      hostname
      ver
    cleanup: null
    timeout: 60

  - type: bash
    command: |
      uname -a
      cat /etc/os-release 2>/dev/null || cat /etc/*-release 2>/dev/null
      hostnamectl 2>/dev/null || hostname
      lscpu 2>/dev/null || cat /proc/cpuinfo
    cleanup: null
    timeout: 30

detection:
  - source: \"Process Creation\"
    indicator: \"systeminfo.exe execution\"
  - source: \"Command Line\"
    indicator: \"Get-ComputerInfo or Get-WmiObject Win32_OperatingSystem\"
  - source: \"Process Creation\"
    indicator: \"uname or hostnamectl execution\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1082/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1082.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Commandes Windows (PowerShell + CMD) definies
- [ ] Commandes Linux (bash) definies
- [ ] Indicateurs de detection documentes
- [ ] Marque is_safe: true
- [ ] Reference MITRE incluse",backend;technique
"[BE-42] Creer definition YAML T1083",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1083 - File and Directory Discovery (dir, Get-ChildItem, ls).

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1083.yaml
id: \"T1083\"
name: \"File and Directory Discovery\"
tactic: \"discovery\"
description: |
  Adversaries may enumerate files and directories or search in specific
  locations of a host or network share for certain information within
  a file system.

platforms:
  - windows
  - linux
  - macos

executors:
  - type: psh
    command: |
      Get-ChildItem -Path C:\\ -Recurse -Depth 2 -ErrorAction SilentlyContinue | Select-Object -First 50 FullName
      Get-ChildItem -Path $env:USERPROFILE\\Documents -ErrorAction SilentlyContinue | Select-Object Name, Length
      Get-ChildItem -Path $env:TEMP -ErrorAction SilentlyContinue | Select-Object -First 20 Name
    cleanup: null
    timeout: 60

  - type: cmd
    command: |
      dir C:\\ /s /b | findstr /n . | findstr \"^[1-50]:\"
      dir %USERPROFILE%\\Documents
      dir %TEMP%
    cleanup: null
    timeout: 60

  - type: bash
    command: |
      find / -maxdepth 3 -type f 2>/dev/null | head -50
      ls -la $HOME/Documents 2>/dev/null || ls -la $HOME
      ls -la /tmp 2>/dev/null | head -20
    cleanup: null
    timeout: 30

detection:
  - source: \"Process Creation\"
    indicator: \"dir.exe or Get-ChildItem with recursive flags\"
  - source: \"File System\"
    indicator: \"Enumeration of sensitive directories\"
  - source: \"Command Line\"
    indicator: \"find command with broad scope\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1083/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1083.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Limitation de profondeur pour eviter surcharge
- [ ] Commandes Windows et Linux definies
- [ ] Gestion erreurs silencieuse (SilentlyContinue, 2>/dev/null)
- [ ] Indicateurs de detection documentes
- [ ] Marque is_safe: true",backend;technique
"[BE-43] Creer definition YAML T1057",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1057 - Process Discovery (tasklist, Get-Process, ps).

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1057.yaml
id: \"T1057\"
name: \"Process Discovery\"
tactic: \"discovery\"
description: |
  Adversaries may attempt to get information about running processes
  on a system. Information obtained could be used to gain an understanding
  of common software/applications running on systems within the network.

platforms:
  - windows
  - linux
  - macos

executors:
  - type: psh
    command: |
      Get-Process | Select-Object -First 30 ProcessName, Id, CPU, WorkingSet
      Get-WmiObject Win32_Process | Select-Object -First 30 Name, ProcessId, CommandLine
      Get-Process | Where-Object {$_.MainWindowTitle} | Select-Object ProcessName, MainWindowTitle
    cleanup: null
    timeout: 30

  - type: cmd
    command: |
      tasklist /v
      wmic process list brief
    cleanup: null
    timeout: 30

  - type: bash
    command: |
      ps aux | head -50
      ps -ef | head -50
      pgrep -l . | head -30
    cleanup: null
    timeout: 20

detection:
  - source: \"Process Creation\"
    indicator: \"tasklist.exe or Get-Process execution\"
  - source: \"WMI\"
    indicator: \"Win32_Process query\"
  - source: \"Command Line\"
    indicator: \"ps or pgrep execution\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1057/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1057.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Commandes Windows (PowerShell, CMD, WMIC) definies
- [ ] Commandes Linux (ps, pgrep) definies
- [ ] Limitation du nombre de resultats
- [ ] Indicateurs de detection documentes
- [ ] Marque is_safe: true",backend;technique
"[BE-44] Creer definition YAML T1059.001",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1059.001 - PowerShell execution.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1059.001.yaml
id: \"T1059.001\"
name: \"PowerShell\"
tactic: \"execution\"
description: |
  Adversaries may abuse PowerShell commands and scripts for execution.
  PowerShell is a powerful interactive command-line interface and
  scripting environment included in the Windows operating system.

platforms:
  - windows

executors:
  - type: psh
    command: |
      $ExecutionContext.SessionState.LanguageMode
      Get-ExecutionPolicy -List
      Get-Process | Select-Object -First 5 ProcessName, Id
      $PSVersionTable
      [System.Environment]::OSVersion
    cleanup: null
    timeout: 30

  - type: cmd
    command: |
      powershell.exe -NoProfile -NonInteractive -Command \"Get-Process | Select -First 5\"
      powershell.exe -NoProfile -Command \"$PSVersionTable\"
    cleanup: null
    timeout: 30

detection:
  - source: \"Process Creation\"
    indicator: \"powershell.exe with command line arguments\"
  - source: \"Script Block Logging\"
    indicator: \"Event ID 4104\"
  - source: \"Module Logging\"
    indicator: \"Event ID 4103\"
  - source: \"PowerShell\"
    indicator: \"Execution policy bypass attempts\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1059/001/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1059.001.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Execution PowerShell directe et via CMD
- [ ] Verification du Language Mode
- [ ] Indicateurs de detection (Script Block Logging, etc.)
- [ ] Marque is_safe: true
- [ ] Reference MITRE incluse",backend;technique
"[BE-45] Creer definition YAML T1059.003",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1059.003 - Windows Command Shell execution.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1059.003.yaml
id: \"T1059.003\"
name: \"Windows Command Shell\"
tactic: \"execution\"
description: |
  Adversaries may abuse the Windows command shell for execution.
  The Windows command shell (cmd.exe) is the primary command prompt
  on Windows systems.

platforms:
  - windows

executors:
  - type: cmd
    command: |
      echo AutoStrike Command Shell Test
      whoami
      hostname
      set
      dir %SYSTEMROOT%\\System32 | findstr /i \"cmd exe\"
    cleanup: null
    timeout: 30

  - type: psh
    command: |
      cmd.exe /c \"echo AutoStrike Test && whoami && hostname\"
      Start-Process cmd.exe -ArgumentList \"/c dir\" -NoNewWindow -Wait
    cleanup: null
    timeout: 30

detection:
  - source: \"Process Creation\"
    indicator: \"cmd.exe spawned by unexpected parent process\"
  - source: \"Command Line\"
    indicator: \"cmd.exe /c with suspicious commands\"
  - source: \"Process\"
    indicator: \"Multiple cmd.exe instances in short time\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1059/003/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1059.003.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Execution CMD directe et via PowerShell
- [ ] Commandes de test benignes
- [ ] Indicateurs de detection documentes
- [ ] Marque is_safe: true
- [ ] Reference MITRE incluse",backend;technique
"[BE-46] Creer definition YAML T1059.004",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1059.004 - Unix Shell execution (bash, sh).

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1059.004.yaml
id: \"T1059.004\"
name: \"Unix Shell\"
tactic: \"execution\"
description: |
  Adversaries may abuse Unix shell commands and scripts for execution.
  Unix shells are the primary command-line interfaces on Linux and macOS.

platforms:
  - linux
  - macos

executors:
  - type: bash
    command: |
      echo \"AutoStrike Unix Shell Test\"
      whoami
      hostname
      id
      env | head -20
      echo $SHELL
      cat /etc/shells
    cleanup: null
    timeout: 30

  - type: sh
    command: |
      echo \"AutoStrike sh Shell Test\"
      whoami
      hostname
      id
      printenv | head -20
    cleanup: null
    timeout: 30

detection:
  - source: \"Process Creation\"
    indicator: \"bash or sh spawned by unexpected parent\"
  - source: \"Command Line\"
    indicator: \"bash -c with suspicious arguments\"
  - source: \"Auditd\"
    indicator: \"execve syscalls for shell execution\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1059/004/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1059.004.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Support bash et sh
- [ ] Support Linux et macOS
- [ ] Commandes de test benignes
- [ ] Indicateurs de detection (auditd) documentes
- [ ] Marque is_safe: true",backend;technique
"[BE-47] Creer definition YAML T1016",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1016 - System Network Configuration Discovery.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1016.yaml
id: \"T1016\"
name: \"System Network Configuration Discovery\"
tactic: \"discovery\"
description: |
  Adversaries may look for details about the network configuration
  and settings, such as IP and/or MAC addresses, of systems they
  access or through information discovery of remote systems.

platforms:
  - windows
  - linux
  - macos

executors:
  - type: psh
    command: |
      Get-NetIPConfiguration
      Get-NetAdapter | Select-Object Name, Status, MacAddress
      Get-DnsClientServerAddress
      Get-NetRoute | Select-Object -First 20
      [System.Net.Dns]::GetHostAddresses($env:COMPUTERNAME)
    cleanup: null
    timeout: 30

  - type: cmd
    command: |
      ipconfig /all
      netstat -an | findstr LISTEN
      route print
      arp -a
      nslookup %COMPUTERNAME%
    cleanup: null
    timeout: 30

  - type: bash
    command: |
      ip addr 2>/dev/null || ifconfig
      ip route 2>/dev/null || netstat -rn
      cat /etc/resolv.conf
      ss -tuln 2>/dev/null || netstat -tuln
      arp -a 2>/dev/null || ip neigh
    cleanup: null
    timeout: 30

detection:
  - source: \"Process Creation\"
    indicator: \"ipconfig.exe or netstat.exe execution\"
  - source: \"Command Line\"
    indicator: \"Get-NetIPConfiguration or network enumeration cmdlets\"
  - source: \"Process\"
    indicator: \"ip or ifconfig execution\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1016/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1016.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Discovery IP, MAC, DNS, routes
- [ ] Support Windows, Linux, macOS
- [ ] Commandes alternatives (ip vs ifconfig)
- [ ] Indicateurs de detection documentes
- [ ] Marque is_safe: true",backend;technique
"[BE-48] Creer definition YAML T1069",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1069 - Permission Groups Discovery.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1069.yaml
id: \"T1069\"
name: \"Permission Groups Discovery\"
tactic: \"discovery\"
description: |
  Adversaries may attempt to discover group and permission settings.
  This information can help adversaries determine which user accounts
  and groups are available.

platforms:
  - windows
  - linux
  - macos

executors:
  - type: psh
    command: |
      Get-LocalGroup
      Get-LocalGroupMember -Group \"Administrators\" -ErrorAction SilentlyContinue
      Get-LocalGroupMember -Group \"Remote Desktop Users\" -ErrorAction SilentlyContinue
      whoami /groups
      net localgroup
    cleanup: null
    timeout: 30

  - type: cmd
    command: |
      net localgroup
      net localgroup Administrators
      net localgroup \"Remote Desktop Users\"
      whoami /groups
    cleanup: null
    timeout: 30

  - type: bash
    command: |
      cat /etc/group
      groups
      id
      getent group sudo 2>/dev/null
      getent group wheel 2>/dev/null
      getent group admin 2>/dev/null
    cleanup: null
    timeout: 20

detection:
  - source: \"Process Creation\"
    indicator: \"net.exe localgroup commands\"
  - source: \"Command Line\"
    indicator: \"Get-LocalGroup or Get-LocalGroupMember\"
  - source: \"Process\"
    indicator: \"getent or groups command execution\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1069/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1069.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Enumeration groupes locaux et membres
- [ ] Groupes privilegies (Administrators, sudo, wheel)
- [ ] Support Windows et Linux
- [ ] Indicateurs de detection documentes
- [ ] Marque is_safe: true",backend;technique
"[BE-49] Creer definition YAML T1087",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1087 - Account Discovery.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1087.yaml
id: \"T1087\"
name: \"Account Discovery\"
tactic: \"discovery\"
description: |
  Adversaries may attempt to get a listing of local system or domain
  accounts. This information can help adversaries determine which
  accounts exist to aid in follow-on behavior.

platforms:
  - windows
  - linux
  - macos

executors:
  - type: psh
    command: |
      Get-LocalUser
      Get-LocalUser | Where-Object {$_.Enabled -eq $true} | Select-Object Name, LastLogon
      Get-WmiObject Win32_UserAccount | Select-Object Name, Disabled, LocalAccount
      whoami /all
      query user 2>$null
    cleanup: null
    timeout: 30

  - type: cmd
    command: |
      net user
      net user %USERNAME%
      wmic useraccount list brief
      query user
    cleanup: null
    timeout: 30

  - type: bash
    command: |
      cat /etc/passwd
      cat /etc/passwd | cut -d: -f1
      getent passwd
      who
      w
      last | head -20
    cleanup: null
    timeout: 20

detection:
  - source: \"Process Creation\"
    indicator: \"net.exe user commands\"
  - source: \"WMI\"
    indicator: \"Win32_UserAccount queries\"
  - source: \"Command Line\"
    indicator: \"Get-LocalUser execution\"
  - source: \"File Access\"
    indicator: \"/etc/passwd read access\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1087/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1087.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Enumeration comptes locaux
- [ ] Info sur comptes actifs/desactives
- [ ] Support Windows et Linux
- [ ] Indicateurs de detection documentes
- [ ] Marque is_safe: true",backend;technique
"[BE-50] Creer definition YAML T1053.005",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1053.005 - Scheduled Task (schtasks, New-ScheduledTask) avec cleanup obligatoire.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1053.005.yaml
id: \"T1053.005\"
name: \"Scheduled Task\"
tactic: \"persistence\"
description: |
  Adversaries may abuse the Windows Task Scheduler to perform task
  scheduling for initial or recurring execution of malicious code.
  NOTE: Cette technique cree une tache planifiee de test qui est
  immediatement supprimee (cleanup).

platforms:
  - windows

executors:
  - type: psh
    command: |
      $taskName = \"AutoStrikeTest_$(Get-Random)\"
      $action = New-ScheduledTaskAction -Execute \"cmd.exe\" -Argument \"/c echo AutoStrike Test\"
      $trigger = New-ScheduledTaskTrigger -Once -At (Get-Date).AddHours(24)
      Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Description \"AutoStrike Test Task\"
      Get-ScheduledTask -TaskName $taskName | Select-Object TaskName, State
      echo \"Task created: $taskName\"
    cleanup: |
      $taskName = Get-ScheduledTask | Where-Object {$_.TaskName -like \"AutoStrikeTest_*\"} | Select-Object -First 1 -ExpandProperty TaskName
      if ($taskName) { Unregister-ScheduledTask -TaskName $taskName -Confirm:$false }
      echo \"Cleanup completed\"
    timeout: 60

  - type: cmd
    command: |
      set TASKNAME=AutoStrikeTest_%RANDOM%
      schtasks /create /tn %TASKNAME% /tr \"cmd.exe /c echo test\" /sc once /st 23:59 /f
      schtasks /query /tn %TASKNAME%
      echo Task created: %TASKNAME%
    cleanup: |
      for /f \"tokens=1\" %%t in ('schtasks /query /fo list ^| findstr /i \"AutoStrikeTest\"') do schtasks /delete /tn %%t /f
      echo Cleanup completed
    timeout: 60

detection:
  - source: \"Process Creation\"
    indicator: \"schtasks.exe /create\"
  - source: \"Windows Event\"
    indicator: \"Event ID 4698 - Scheduled task created\"
  - source: \"Command Line\"
    indicator: \"Register-ScheduledTask or New-ScheduledTask\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1053/005/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1053.005.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Creation tache planifiee de test
- [ ] Cleanup OBLIGATOIRE supprimant la tache
- [ ] Nom de tache unique (random)
- [ ] Indicateurs de detection (Event ID 4698)
- [ ] Marque is_safe: true avec cleanup",backend;technique
"[BE-51] Creer definition YAML T1547.001",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1547.001 - Registry Run Keys persistence avec cleanup obligatoire.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1547.001.yaml
id: \"T1547.001\"
name: \"Registry Run Keys\"
tactic: \"persistence\"
description: |
  Adversaries may achieve persistence by adding a program to a Registry
  run key. NOTE: Cette technique cree une cle de registre de test qui
  est immediatement supprimee (cleanup).

platforms:
  - windows

executors:
  - type: psh
    command: |
      $keyName = \"AutoStrikeTest_$(Get-Random)\"
      $regPath = \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\"
      Set-ItemProperty -Path $regPath -Name $keyName -Value \"cmd.exe /c echo AutoStrike Test\" -Type String
      Get-ItemProperty -Path $regPath -Name $keyName
      echo \"Registry key created: $keyName\"
    cleanup: |
      $regPath = \"HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\"
      Get-ItemProperty -Path $regPath | ForEach-Object {
          $_.PSObject.Properties | Where-Object {$_.Name -like \"AutoStrikeTest_*\"} | ForEach-Object {
              Remove-ItemProperty -Path $regPath -Name $_.Name -ErrorAction SilentlyContinue
          }
      }
      echo \"Cleanup completed\"
    timeout: 30

  - type: cmd
    command: |
      set KEYNAME=AutoStrikeTest_%RANDOM%
      reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v %KEYNAME% /t REG_SZ /d \"cmd.exe /c echo test\" /f
      reg query \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v %KEYNAME%
      echo Registry key created: %KEYNAME%
    cleanup: |
      for /f \"tokens=1\" %%k in ('reg query \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" ^| findstr /i \"AutoStrikeTest\"') do reg delete \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v %%k /f
      echo Cleanup completed
    timeout: 30

detection:
  - source: \"Registry\"
    indicator: \"Modification of Run/RunOnce keys\"
  - source: \"Windows Event\"
    indicator: \"Event ID 13 (Sysmon) - Registry value set\"
  - source: \"Registry\"
    indicator: \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run modifications\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1547/001/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1547.001.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Creation cle registre dans HKCU Run
- [ ] Cleanup OBLIGATOIRE supprimant la cle
- [ ] Nom de cle unique (random)
- [ ] Indicateurs de detection (Sysmon Event ID 13)
- [ ] Marque is_safe: true avec cleanup",backend;technique
"[BE-52] Creer definition YAML T1070.004",Task,"**Objectif:** Creer le fichier YAML de definition pour la technique T1070.004 - File Deletion (del, Remove-Item) avec fichier de test.

**Fichier YAML:**
\`\`\`yaml
# configs/techniques/T1070.004.yaml
id: \"T1070.004\"
name: \"File Deletion\"
tactic: \"defense-evasion\"
description: |
  Adversaries may delete files left behind by the actions of their
  intrusion activity. NOTE: Cette technique cree un fichier de test
  puis le supprime pour simuler l'activite.

platforms:
  - windows
  - linux
  - macos

executors:
  - type: psh
    command: |
      $testFile = \"$env:TEMP\\AutoStrikeTest_$(Get-Random).txt\"
      \"AutoStrike File Deletion Test\" | Out-File -FilePath $testFile
      echo \"Created test file: $testFile\"
      Test-Path $testFile
      Remove-Item -Path $testFile -Force
      echo \"File deleted\"
      Test-Path $testFile
    cleanup: null
    timeout: 20

  - type: cmd
    command: |
      set TESTFILE=%TEMP%\\AutoStrikeTest_%RANDOM%.txt
      echo AutoStrike File Deletion Test > %TESTFILE%
      echo Created test file: %TESTFILE%
      if exist %TESTFILE% echo File exists
      del /f /q %TESTFILE%
      echo File deleted
      if not exist %TESTFILE% echo File confirmed deleted
    cleanup: null
    timeout: 20

  - type: bash
    command: |
      TESTFILE=\"/tmp/AutoStrikeTest_$RANDOM.txt\"
      echo \"AutoStrike File Deletion Test\" > $TESTFILE
      echo \"Created test file: $TESTFILE\"
      ls -la $TESTFILE
      rm -f $TESTFILE
      echo \"File deleted\"
      ls -la $TESTFILE 2>&1 || echo \"File confirmed deleted\"
    cleanup: null
    timeout: 20

detection:
  - source: \"File System\"
    indicator: \"File deletion in temp directories\"
  - source: \"Process Creation\"
    indicator: \"del.exe or Remove-Item with force flag\"
  - source: \"Sysmon\"
    indicator: \"Event ID 23 - File delete\"

is_safe: true

references:
  - https://attack.mitre.org/techniques/T1070/004/
\`\`\`

**Fichiers:**
- server/configs/techniques/T1070.004.yaml

**Definition of Done:**
- [ ] Fichier YAML valide et parsable
- [ ] Creation puis suppression fichier de test
- [ ] Fichier dans repertoire temp uniquement
- [ ] Verification de la suppression
- [ ] Support Windows, Linux, macOS
- [ ] Marque is_safe: true (fichier de test)",backend;technique
"[BE-53] Generer certificats CA mTLS",Task,"**Objectif:** Creer un script de generation des certificats pour mTLS: CA root autosignee, certificat serveur, template certificat agent.

**Script shell:**
\`\`\`bash
#!/bin/bash
# scripts/generate-certs.sh

set -e

CERT_DIR=\"./certs\"
CA_DAYS=3650
SERVER_DAYS=365
AGENT_DAYS=365

mkdir -p $CERT_DIR

echo \"=== Generating CA Root Certificate ===\"
openssl genrsa -out $CERT_DIR/ca.key 4096
openssl req -new -x509 -days $CA_DAYS -key $CERT_DIR/ca.key \
    -out $CERT_DIR/ca.crt \
    -subj \"/C=FR/ST=IDF/L=Paris/O=AutoStrike/OU=Security/CN=AutoStrike CA\"

echo \"=== Generating Server Certificate ===\"
openssl genrsa -out $CERT_DIR/server.key 2048

cat > $CERT_DIR/server.cnf << EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = FR
ST = IDF
L = Paris
O = AutoStrike
OU = Server
CN = localhost

[v3_req]
basicConstraints = CA:FALSE
keyUsage = digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = autostrike.local
IP.1 = 127.0.0.1
EOF

openssl req -new -key $CERT_DIR/server.key -out $CERT_DIR/server.csr -config $CERT_DIR/server.cnf
openssl x509 -req -days $SERVER_DAYS -in $CERT_DIR/server.csr \
    -CA $CERT_DIR/ca.crt -CAkey $CERT_DIR/ca.key -CAcreateserial \
    -out $CERT_DIR/server.crt -extensions v3_req -extfile $CERT_DIR/server.cnf

echo \"=== Creating Agent Certificate Template ===\"
cat > $CERT_DIR/agent-template.cnf << EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = FR
ST = IDF
L = Paris
O = AutoStrike
OU = Agent
CN = AGENT_PAW_PLACEHOLDER

[v3_req]
basicConstraints = CA:FALSE
keyUsage = digitalSignature
extendedKeyUsage = clientAuth
EOF

echo \"=== Certificates Generated ===\"
echo \"CA Certificate: $CERT_DIR/ca.crt\"
echo \"Server Certificate: $CERT_DIR/server.crt\"
echo \"Server Key: $CERT_DIR/server.key\"
echo \"\"
echo \"To generate agent certificate, run:\"
echo \"  ./scripts/generate-agent-cert.sh <agent-paw>\"

chmod 600 $CERT_DIR/*.key
chmod 644 $CERT_DIR/*.crt
\`\`\`

**Fichiers:**
- scripts/generate-certs.sh
- scripts/generate-agent-cert.sh
- server/certs/.gitkeep

**Definition of Done:**
- [ ] Script generation CA root (4096 bits, 10 ans)
- [ ] Script generation certificat serveur (2048 bits, 1 an)
- [ ] SAN incluant localhost et IPs
- [ ] Template pour certificats agents
- [ ] Permissions restrictives sur cles privees
- [ ] Documentation usage des scripts",backend;security
"[BE-54] Configurer TLS serveur",Task,"**Objectif:** Configurer le serveur Go pour HTTPS avec les certificats generes, TLS 1.3 minimum, cipher suites securisees.

**Code Go exemple:**
\`\`\`go
// pkg/crypto/tls.go
package crypto

import (
    \"crypto/tls\"
    \"crypto/x509\"
    \"fmt\"
    \"os\"
)

type TLSConfig struct {
    CertFile   string
    KeyFile    string
    CAFile     string
    MinVersion uint16
    ClientAuth tls.ClientAuthType
}

func DefaultTLSConfig() TLSConfig {
    return TLSConfig{
        CertFile:   \"./certs/server.crt\",
        KeyFile:    \"./certs/server.key\",
        CAFile:     \"./certs/ca.crt\",
        MinVersion: tls.VersionTLS13,
        ClientAuth: tls.RequireAndVerifyClientCert,
    }
}

func NewTLSConfig(cfg TLSConfig) (*tls.Config, error) {
    cert, err := tls.LoadX509KeyPair(cfg.CertFile, cfg.KeyFile)
    if err != nil {
        return nil, fmt.Errorf(\"failed to load server certificate: %w\", err)
    }

    caCert, err := os.ReadFile(cfg.CAFile)
    if err != nil {
        return nil, fmt.Errorf(\"failed to read CA certificate: %w\", err)
    }

    caCertPool := x509.NewCertPool()
    if !caCertPool.AppendCertsFromPEM(caCert) {
        return nil, fmt.Errorf(\"failed to parse CA certificate\")
    }

    return &tls.Config{
        Certificates: []tls.Certificate{cert},
        ClientCAs:    caCertPool,
        ClientAuth:   cfg.ClientAuth,
        MinVersion:   cfg.MinVersion,
        CipherSuites: []uint16{
            tls.TLS_AES_256_GCM_SHA384,
            tls.TLS_CHACHA20_POLY1305_SHA256,
            tls.TLS_AES_128_GCM_SHA256,
        },
    }, nil
}

func NewServerWithTLS(addr string, handler http.Handler, tlsCfg *tls.Config) *http.Server {
    return &http.Server{
        Addr:      addr,
        Handler:   handler,
        TLSConfig: tlsCfg,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }
}
\`\`\`

**Fichiers:**
- server/pkg/crypto/tls.go
- server/pkg/crypto/tls_test.go
- server/configs/config.yaml (section tls)

**Definition of Done:**
- [ ] TLS 1.3 minimum configure
- [ ] Cipher suites modernes uniquement
- [ ] Chargement certificats depuis fichiers
- [ ] Configuration timeouts securisee
- [ ] Option pour desactiver mTLS (dev mode)
- [ ] Tests avec certificats de test",backend;security
"[BE-55] Implementer verification certificat agent",Task,"**Objectif:** Implementer la verification mTLS des certificats clients (agents) avec validation de la CA et extraction du PAW.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/rest/middleware/mtls.go
package middleware

import (
    \"crypto/x509\"
    \"net/http\"
    \"strings\"
    \"github.com/gin-gonic/gin\"
)

func MTLSMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        if c.Request.TLS == nil || len(c.Request.TLS.PeerCertificates) == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{
                \"error\": \"client certificate required\",
            })
            c.Abort()
            return
        }

        clientCert := c.Request.TLS.PeerCertificates[0]

        if err := validateAgentCertificate(clientCert); err != nil {
            c.JSON(http.StatusForbidden, gin.H{
                \"error\": \"invalid client certificate\",
                \"details\": err.Error(),
            })
            c.Abort()
            return
        }

        agentPaw := extractPawFromCert(clientCert)
        c.Set(\"agent_paw\", agentPaw)
        c.Set(\"client_cert\", clientCert)

        c.Next()
    }
}

func validateAgentCertificate(cert *x509.Certificate) error {
    if cert.Subject.Organization == nil ||
       len(cert.Subject.Organization) == 0 ||
       cert.Subject.Organization[0] != \"AutoStrike\" {
        return ErrInvalidOrganization
    }

    if cert.Subject.OrganizationalUnit == nil ||
       len(cert.Subject.OrganizationalUnit) == 0 ||
       cert.Subject.OrganizationalUnit[0] != \"Agent\" {
        return ErrInvalidOU
    }

    for _, usage := range cert.ExtKeyUsage {
        if usage == x509.ExtKeyUsageClientAuth {
            return nil
        }
    }
    return ErrMissingClientAuth
}

func extractPawFromCert(cert *x509.Certificate) string {
    return cert.Subject.CommonName
}

var (
    ErrInvalidOrganization = errors.New(\"certificate organization must be AutoStrike\")
    ErrInvalidOU           = errors.New(\"certificate OU must be Agent\")
    ErrMissingClientAuth   = errors.New(\"certificate must have clientAuth extended key usage\")
)
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/rest/middleware/mtls.go
- server/internal/infrastructure/api/rest/middleware/mtls_test.go

**Definition of Done:**
- [ ] Verification presence certificat client
- [ ] Validation Organization = AutoStrike
- [ ] Validation OU = Agent
- [ ] Validation ExtKeyUsage = clientAuth
- [ ] Extraction PAW depuis CN
- [ ] Tests avec certificats valides et invalides",backend;security
"[BE-56] Creer endpoint generation script deploiement",Task,"**Objectif:** Creer les endpoints GET /deploy/agent.ps1 et /deploy/agent.sh pour generer dynamiquement les scripts de deploiement agent.

**Code Go exemple:**
\`\`\`go
// internal/infrastructure/api/rest/handlers/deploy_handler.go
package handlers

import (
    \"fmt\"
    \"net/http\"
    \"text/template\"
    \"github.com/gin-gonic/gin\"
)

type DeployHandler struct {
    serverURL string
    caPath    string
}

func NewDeployHandler(serverURL, caPath string) *DeployHandler {
    return &DeployHandler{
        serverURL: serverURL,
        caPath:    caPath,
    }
}

const powershellScript = `# AutoStrike Agent Deployment Script
# Generated for: {{.ServerURL}}

$ErrorActionPreference = \"Stop\"
$AgentDir = \"$env:ProgramFiles\\AutoStrike\"
$AgentExe = \"$AgentDir\\autostrike-agent.exe\"

Write-Host \"[*] Creating directory...\"
New-Item -ItemType Directory -Force -Path $AgentDir | Out-Null

Write-Host \"[*] Downloading agent...\"
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls13
Invoke-WebRequest -Uri \"{{.ServerURL}}/downloads/agent-windows-amd64.exe\" -OutFile $AgentExe

Write-Host \"[*] Downloading CA certificate...\"
Invoke-WebRequest -Uri \"{{.ServerURL}}/downloads/ca.crt\" -OutFile \"$AgentDir\\ca.crt\"

Write-Host \"[*] Registering agent...\"
& $AgentExe --server \"{{.ServerURL}}\" --register

Write-Host \"[+] Agent deployed successfully!\"
`

const bashScript = `#!/bin/bash
# AutoStrike Agent Deployment Script
# Generated for: {{.ServerURL}}

set -e

AGENT_DIR=\"/opt/autostrike\"
AGENT_BIN=\"$AGENT_DIR/autostrike-agent\"

echo \"[*] Creating directory...\"
sudo mkdir -p $AGENT_DIR

echo \"[*] Downloading agent...\"
curl -sSL \"{{.ServerURL}}/downloads/agent-linux-amd64\" -o $AGENT_BIN
chmod +x $AGENT_BIN

echo \"[*] Downloading CA certificate...\"
curl -sSL \"{{.ServerURL}}/downloads/ca.crt\" -o \"$AGENT_DIR/ca.crt\"

echo \"[*] Registering agent...\"
$AGENT_BIN --server \"{{.ServerURL}}\" --register

echo \"[+] Agent deployed successfully!\"
`

func (h *DeployHandler) GetPowerShellScript(c *gin.Context) {
    tmpl := template.Must(template.New(\"ps1\").Parse(powershellScript))
    c.Header(\"Content-Type\", \"text/plain; charset=utf-8\")
    c.Header(\"Content-Disposition\", \"attachment; filename=deploy-agent.ps1\")
    tmpl.Execute(c.Writer, map[string]string{\"ServerURL\": h.serverURL})
}

func (h *DeployHandler) GetBashScript(c *gin.Context) {
    tmpl := template.Must(template.New(\"sh\").Parse(bashScript))
    c.Header(\"Content-Type\", \"text/plain; charset=utf-8\")
    c.Header(\"Content-Disposition\", \"attachment; filename=deploy-agent.sh\")
    tmpl.Execute(c.Writer, map[string]string{\"ServerURL\": h.serverURL})
}
\`\`\`

**Fichiers:**
- server/internal/infrastructure/api/rest/handlers/deploy_handler.go
- server/internal/infrastructure/api/rest/handlers/deploy_handler_test.go

**Definition of Done:**
- [ ] Endpoint GET /deploy/agent.ps1 pour Windows
- [ ] Endpoint GET /deploy/agent.sh pour Linux
- [ ] URL serveur injectee dynamiquement
- [ ] Telechargement agent et CA certificate
- [ ] Scripts executables one-liner
- [ ] Tests de generation des scripts",backend;api
"[BE-57] Implementer export PDF",Task,"**Objectif:** Implementer la generation de rapport PDF avec statistiques, graphique de score, couverture MITRE et recommandations.

**Code Go exemple:**
\`\`\`go
// internal/application/report_service.go
package application

import (
    \"bytes\"
    \"time\"
    \"github.com/jung-kurt/gofpdf\"
)

type ReportService struct {
    scoreCalc   *service.ScoreCalculator
    resultRepo  repository.ResultRepository
    techRepo    repository.TechniqueRepository
}

type ReportData struct {
    GeneratedAt    time.Time
    Score          service.SecurityScore
    TechniqueStats []TechniqueStat
    Recommendations []string
    ExecutionID    string
}

type TechniqueStat struct {
    ID       string
    Name     string
    Tactic   string
    Status   string
    LastTest time.Time
}

func (s *ReportService) GeneratePDF(executionID string) ([]byte, error) {
    data, err := s.gatherReportData(executionID)
    if err != nil {
        return nil, err
    }

    pdf := gofpdf.New(\"P\", \"mm\", \"A4\", \"\")
    pdf.SetTitle(\"AutoStrike Security Report\", false)
    pdf.SetAuthor(\"AutoStrike\", false)

    s.addTitlePage(pdf, data)
    s.addScorePage(pdf, data)
    s.addCoveragePage(pdf, data)
    s.addRecommendationsPage(pdf, data)

    var buf bytes.Buffer
    if err := pdf.Output(&buf); err != nil {
        return nil, err
    }
    return buf.Bytes(), nil
}

func (s *ReportService) addTitlePage(pdf *gofpdf.Fpdf, data *ReportData) {
    pdf.AddPage()
    pdf.SetFont(\"Arial\", \"B\", 24)
    pdf.Cell(0, 20, \"AutoStrike Security Report\")
    pdf.Ln(30)

    pdf.SetFont(\"Arial\", \"\", 12)
    pdf.Cell(0, 10, fmt.Sprintf(\"Generated: %s\", data.GeneratedAt.Format(\"2006-01-02 15:04\")))
    pdf.Ln(10)
    pdf.Cell(0, 10, fmt.Sprintf(\"Execution ID: %s\", data.ExecutionID))
}

func (s *ReportService) addScorePage(pdf *gofpdf.Fpdf, data *ReportData) {
    pdf.AddPage()
    pdf.SetFont(\"Arial\", \"B\", 18)
    pdf.Cell(0, 15, \"Security Score\")
    pdf.Ln(20)

    pdf.SetFont(\"Arial\", \"B\", 48)
    scoreColor := s.getScoreColor(data.Score.Score)
    pdf.SetTextColor(scoreColor[0], scoreColor[1], scoreColor[2])
    pdf.Cell(0, 20, fmt.Sprintf(\"%.0f%%\", data.Score.Score))
    pdf.Ln(25)

    pdf.SetTextColor(0, 0, 0)
    pdf.SetFont(\"Arial\", \"\", 12)
    pdf.Cell(0, 10, fmt.Sprintf(\"Status: %s\", data.Score.Label))
    pdf.Ln(15)

    pdf.Cell(60, 10, fmt.Sprintf(\"Blocked: %d\", data.Score.Blocked))
    pdf.Cell(60, 10, fmt.Sprintf(\"Detected: %d\", data.Score.Detected))
    pdf.Cell(60, 10, fmt.Sprintf(\"Success: %d\", data.Score.Success))
}

func (s *ReportService) getScoreColor(score float64) [3]int {
    if score >= 80 {
        return [3]int{34, 197, 94}
    } else if score >= 60 {
        return [3]int{234, 179, 8}
    } else if score >= 40 {
        return [3]int{249, 115, 22}
    }
    return [3]int{239, 68, 68}
}
\`\`\`

**Fichiers:**
- server/internal/application/report_service.go
- server/internal/application/report_service_test.go
- server/internal/infrastructure/api/rest/handlers/report_handler.go

**Definition of Done:**
- [ ] Generation PDF avec gofpdf
- [ ] Page de titre avec date et execution ID
- [ ] Page score avec couleur selon niveau
- [ ] Page couverture avec stats par tactic
- [ ] Page recommandations basees sur resultats
- [ ] Endpoint GET /api/v1/reports/export/pdf",backend;reports
"[BE-58] Creer profil adversaire APT29",Task,"**Objectif:** Creer le profil adversaire APT29 (Cozy Bear) avec description, techniques associees et references.

**Fichier YAML:**
\`\`\`yaml
# configs/adversaries/APT29.yaml
id: \"apt29\"
name: \"APT29 - Cozy Bear\"
aliases:
  - Cozy Bear
  - The Dukes
  - YTTRIUM
  - Iron Hemlock
  - Midnight Blizzard

description: |
  APT29 is a Russian state-sponsored threat group that has been active
  since at least 2008. The group is attributed to Russia's Foreign
  Intelligence Service (SVR) and has targeted government networks in
  Europe and NATO member countries, research institutes, and think tanks.

  Notable campaigns include the 2016 DNC hack, SolarWinds supply chain
  attack (2020), and ongoing phishing campaigns targeting diplomatic entities.

attribution: \"Russia - SVR\"

targets:
  - Government
  - Diplomatic entities
  - Think tanks
  - Healthcare (COVID-19 research)
  - Technology

techniques:
  # Discovery
  - T1082  # System Information Discovery
  - T1083  # File and Directory Discovery
  - T1057  # Process Discovery
  - T1016  # System Network Configuration Discovery
  - T1087  # Account Discovery

  # Execution
  - T1059.001  # PowerShell
  - T1059.003  # Windows Command Shell

  # Persistence
  - T1053.005  # Scheduled Task
  - T1547.001  # Registry Run Keys

  # Defense Evasion
  - T1070.004  # File Deletion

references:
  - https://attack.mitre.org/groups/G0016/
  - https://www.mandiant.com/resources/apt29-domain-fronting
  - https://www.microsoft.com/security/blog/tag/midnight-blizzard/

created_at: \"2026-01-01\"
updated_at: \"2026-01-29\"
\`\`\`

**Code Go (entity):**
\`\`\`go
// internal/domain/entity/adversary.go
type AdversaryProfile struct {
    ID          string   `json:\"id\"`
    Name        string   `json:\"name\"`
    Aliases     []string `json:\"aliases\"`
    Description string   `json:\"description\"`
    Attribution string   `json:\"attribution\"`
    Targets     []string `json:\"targets\"`
    Techniques  []string `json:\"techniques\"`
    References  []string `json:\"references\"`
    CreatedAt   time.Time `json:\"created_at\"`
    UpdatedAt   time.Time `json:\"updated_at\"`
}
\`\`\`

**Fichiers:**
- server/configs/adversaries/APT29.yaml
- server/internal/domain/entity/adversary.go
- server/pkg/mitre/adversary_parser.go

**Definition of Done:**
- [ ] Fichier YAML avec profil complet APT29
- [ ] Techniques mappees aux IDs MITRE implementes
- [ ] Description historique et attribution
- [ ] Cibles et secteurs documentes
- [ ] References MITRE et vendors incluses
- [ ] Parser YAML pour charger le profil",backend;adversary
"[BE-59] Creer profil adversaire APT28",Task,"**Objectif:** Creer le profil adversaire APT28 (Fancy Bear) avec description, techniques associees et references.

**Fichier YAML:**
\`\`\`yaml
# configs/adversaries/APT28.yaml
id: \"apt28\"
name: \"APT28 - Fancy Bear\"
aliases:
  - Fancy Bear
  - Sofacy
  - Pawn Storm
  - STRONTIUM
  - Forest Blizzard
  - Sednit

description: |
  APT28 is a Russian state-sponsored threat group that has been active
  since at least 2004. The group is attributed to Russia's Main Intelligence
  Directorate (GRU), specifically Unit 26165.

  APT28 has targeted government, military, and security organizations,
  particularly those of NATO members. Notable operations include attacks
  on the German Bundestag (2015), WADA (2016), and the 2016 US election
  infrastructure.

attribution: \"Russia - GRU Unit 26165\"

targets:
  - Government
  - Military
  - Defense contractors
  - Media organizations
  - Political organizations

techniques:
  # Discovery
  - T1082  # System Information Discovery
  - T1083  # File and Directory Discovery
  - T1057  # Process Discovery
  - T1069  # Permission Groups Discovery
  - T1087  # Account Discovery

  # Execution
  - T1059.001  # PowerShell
  - T1059.003  # Windows Command Shell

  # Persistence
  - T1053.005  # Scheduled Task
  - T1547.001  # Registry Run Keys

  # Defense Evasion
  - T1070.004  # File Deletion

references:
  - https://attack.mitre.org/groups/G0007/
  - https://www.mandiant.com/resources/apt28-a-window-into-russias-cyber-espionage-operations
  - https://www.microsoft.com/security/blog/tag/forest-blizzard/

created_at: \"2026-01-01\"
updated_at: \"2026-01-29\"
\`\`\`

**Fichiers:**
- server/configs/adversaries/APT28.yaml

**Definition of Done:**
- [ ] Fichier YAML avec profil complet APT28
- [ ] Techniques mappees aux IDs MITRE implementes
- [ ] Description historique et attribution GRU
- [ ] Cibles et secteurs documentes
- [ ] References MITRE et vendors incluses
- [ ] Distinction claire avec APT29 (SVR vs GRU)",backend;adversary
"[AG-01] Initialiser projet Rust avec Cargo",Task,"**Objectif:**
Initialiser le projet Rust pour l'agent AutoStrike avec la structure de modules appropriee.

**Code Rust exemple:**
```rust
// Commande d'initialisation
// cargo new autostrike-agent --name agent

// Structure initiale main.rs
mod config;
mod beacon;
mod executor;
mod techniques;
mod utils;

fn main() {
    println!(""AutoStrike Agent v0.1.0"");
}
```

**Fichiers:**
- agent/Cargo.toml
- agent/src/main.rs
- agent/src/config.rs (vide)
- agent/src/beacon/mod.rs
- agent/src/executor/mod.rs
- agent/src/techniques/mod.rs
- agent/src/utils/mod.rs

**Definition of Done:**
- [ ] Projet Cargo initialise avec cargo new
- [ ] Structure des modules creee (beacon/, executor/, techniques/, utils/)
- [ ] Fichier main.rs compile sans erreur
- [ ] cargo build fonctionne
- [ ] cargo test passe (meme si vide)",agent;setup
"[AG-02] Configurer Cargo.toml dependances",Task,"**Objectif:**
Configurer toutes les dependances necessaires pour l'agent dans Cargo.toml.

**Code Rust exemple:**
```rust
// Cargo.toml
[package]
name = ""autostrike-agent""
version = ""0.1.0""
edition = ""2021""

[dependencies]
tokio = { version = ""1.35"", features = [""full""] }
reqwest = { version = ""0.11"", features = [""json"", ""rustls-tls""] }
serde = { version = ""1.0"", features = [""derive""] }
serde_json = ""1.0""
uuid = { version = ""1.6"", features = [""v4""] }
base64 = ""0.21""
hostname = ""0.3""
whoami = ""1.4""
rand = ""0.8""
log = ""0.4""
env_logger = ""0.10""

[profile.release]
opt-level = ""z""
lto = true
codegen-units = 1
panic = ""abort""
strip = true
```

**Fichiers:**
- agent/Cargo.toml

**Definition of Done:**
- [ ] Toutes les dependances ajoutees (tokio, reqwest, serde, uuid, base64, hostname, whoami, rand)
- [ ] Features configurees correctement (tokio full, reqwest json+rustls-tls, serde derive)
- [ ] Profile release configure pour optimisation taille
- [ ] cargo build compile sans erreur
- [ ] cargo update fonctionne",agent;setup
"[AG-03] Creer module config",Task,"**Objectif:**
Creer le module de configuration de l'agent avec chargement des variables d'environnement et valeurs par defaut.

**Code Rust exemple:**
```rust
// src/config.rs
use serde::Deserialize;

#[derive(Clone, Deserialize)]
pub struct Config {
    pub server_url: String,
    pub sleep: u64,
    pub jitter: u64,
    pub paw: Option<String>,
}

impl Config {
    pub fn load() -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Config {
            server_url: std::env::var(""AUTOSTRIKE_SERVER"")
                .unwrap_or_else(|_| ""https://localhost:8443"".to_string()),
            sleep: std::env::var(""AUTOSTRIKE_SLEEP"")
                .unwrap_or_else(|_| ""5"".to_string())
                .parse()
                .unwrap_or(5),
            jitter: std::env::var(""AUTOSTRIKE_JITTER"")
                .unwrap_or_else(|_| ""3"".to_string())
                .parse()
                .unwrap_or(3),
            paw: std::env::var(""AUTOSTRIKE_PAW"").ok(),
        })
    }
}

impl Default for Config {
    fn default() -> Self {
        Config {
            server_url: ""https://localhost:8443"".to_string(),
            sleep: 5,
            jitter: 3,
            paw: None,
        }
    }
}
```

**Fichiers:**
- agent/src/config.rs

**Definition of Done:**
- [ ] Struct Config avec tous les champs (server_url, sleep, jitter, paw)
- [ ] Methode load() implementee avec lecture env vars
- [ ] Valeurs par defaut definies
- [ ] Tests unitaires pour Config::load()
- [ ] Impl Default pour Config",agent;config
"[AG-04] Creer module beacon/client",Task,"**Objectif:**
Creer le client beacon responsable de la communication avec le serveur C2.

**Code Rust exemple:**
```rust
// src/beacon/client.rs
use reqwest::Client;
use crate::config::Config;
use super::protocol::{BeaconRequest, BeaconResponse, TaskResult, Instruction};

pub struct BeaconClient {
    client: Client,
    config: Config,
    paw: String,
    pending_results: Vec<TaskResult>,
}

impl BeaconClient {
    pub fn new(config: &Config) -> Result<Self, Box<dyn std::error::Error>> {
        let client = Client::builder()
            .danger_accept_invalid_certs(true)
            .build()?;

        let paw = config.paw.clone()
            .unwrap_or_else(|| uuid::Uuid::new_v4().to_string());

        Ok(Self {
            client,
            config: config.clone(),
            paw,
            pending_results: vec![],
        })
    }

    pub async fn beacon(&mut self) -> Result<Vec<Instruction>, Box<dyn std::error::Error>> {
        let request = BeaconRequest::new(&self.paw, self.pending_results.drain(..).collect());

        let response: BeaconResponse = self.client
            .post(&format!(""{}/api/v1/agents/{}/beacon"", self.config.server_url, self.paw))
            .json(&request)
            .send()
            .await?
            .json()
            .await?;

        self.paw = response.paw;
        Ok(response.instructions)
    }

    pub fn queue_result(&mut self, result: TaskResult) {
        self.pending_results.push(result);
    }
}
```

**Fichiers:**
- agent/src/beacon/mod.rs
- agent/src/beacon/client.rs

**Definition of Done:**
- [ ] Struct BeaconClient avec client HTTP, config et paw
- [ ] Methode new() pour initialisation
- [ ] Methode beacon() pour communication serveur
- [ ] Methode queue_result() pour stocker resultats
- [ ] Tests unitaires avec mock serveur",agent;beacon
"[AG-05] Creer struct BeaconRequest",Task,"**Objectif:**
Creer la structure BeaconRequest pour les requetes vers le serveur C2.

**Code Rust exemple:**
```rust
// src/beacon/protocol.rs
use serde::{Serialize, Deserialize};

#[derive(Serialize, Debug)]
pub struct BeaconRequest {
    pub paw: String,
    pub hostname: String,
    pub platform: String,
    pub username: String,
    pub executors: Vec<String>,
    pub results: Vec<TaskResult>,
    pub os_version: Option<String>,
    pub architecture: Option<String>,
}

impl BeaconRequest {
    pub fn new(paw: &str, results: Vec<TaskResult>) -> Self {
        Self {
            paw: paw.to_string(),
            hostname: hostname::get()
                .map(|h| h.to_string_lossy().to_string())
                .unwrap_or_else(|_| ""unknown"".to_string()),
            platform: std::env::consts::OS.to_string(),
            username: whoami::username(),
            executors: Self::detect_executors(),
            results,
            os_version: None,
            architecture: Some(std::env::consts::ARCH.to_string()),
        }
    }

    fn detect_executors() -> Vec<String> {
        let mut executors = vec![];
        #[cfg(target_os = ""windows"")]
        {
            executors.push(""psh"".to_string());
            executors.push(""cmd"".to_string());
        }
        #[cfg(any(target_os = ""linux"", target_os = ""macos""))]
        {
            executors.push(""bash"".to_string());
            executors.push(""sh"".to_string());
        }
        executors
    }
}
```

**Fichiers:**
- agent/src/beacon/protocol.rs

**Definition of Done:**
- [ ] Struct BeaconRequest avec derive Serialize
- [ ] Champs: paw, hostname, platform, username, executors, results
- [ ] Methode new() avec detection automatique des infos systeme
- [ ] Tests unitaires pour serialisation JSON
- [ ] Documentation des champs",agent;beacon
"[AG-06] Creer struct BeaconResponse",Task,"**Objectif:**
Creer la structure BeaconResponse pour deserialiser les reponses du serveur.

**Code Rust exemple:**
```rust
// src/beacon/protocol.rs (suite)
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
pub struct BeaconResponse {
    pub paw: String,
    pub sleep: u64,
    pub instructions: Vec<Instruction>,
    #[serde(default)]
    pub config_update: Option<ConfigUpdate>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct ConfigUpdate {
    pub sleep: Option<u64>,
    pub jitter: Option<u64>,
}

impl BeaconResponse {
    pub fn has_instructions(&self) -> bool {
        !self.instructions.is_empty()
    }

    pub fn instruction_count(&self) -> usize {
        self.instructions.len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_response() {
        let json = r#""{
            ""paw"": ""agent-123"",
            ""sleep"": 5,
            ""instructions"": []
        }""#;

        let response: BeaconResponse = serde_json::from_str(json).unwrap();
        assert_eq!(response.paw, ""agent-123"");
        assert_eq!(response.sleep, 5);
        assert!(!response.has_instructions());
    }
}
```

**Fichiers:**
- agent/src/beacon/protocol.rs

**Definition of Done:**
- [ ] Struct BeaconResponse avec derive Deserialize
- [ ] Champs: paw, sleep, instructions
- [ ] Support optionnel de config_update
- [ ] Methodes utilitaires (has_instructions, instruction_count)
- [ ] Tests unitaires pour deserialisation JSON",agent;beacon
"[AG-07] Creer struct Instruction",Task,"**Objectif:**
Creer la structure Instruction representant une tache a executer.

**Code Rust exemple:**
```rust
// src/beacon/protocol.rs (suite)
use serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
pub struct Instruction {
    pub id: String,
    pub technique_id: String,
    pub executor: String,
    pub command: String,
    pub timeout: u64,
    #[serde(default)]
    pub cleanup: Option<String>,
    #[serde(default)]
    pub payloads: Vec<Payload>,
}

#[derive(Deserialize, Debug, Clone)]
pub struct Payload {
    pub name: String,
    pub content: String,  // Base64 encoded
}

impl Instruction {
    pub fn timeout_duration(&self) -> std::time::Duration {
        std::time::Duration::from_secs(self.timeout)
    }

    pub fn has_cleanup(&self) -> bool {
        self.cleanup.is_some()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deserialize_instruction() {
        let json = r#""{
            ""id"": ""task-001"",
            ""technique_id"": ""T1082"",
            ""executor"": ""psh"",
            ""command"": ""systeminfo"",
            ""timeout"": 30
        }""#;

        let instruction: Instruction = serde_json::from_str(json).unwrap();
        assert_eq!(instruction.technique_id, ""T1082"");
        assert_eq!(instruction.timeout, 30);
    }
}
```

**Fichiers:**
- agent/src/beacon/protocol.rs

**Definition of Done:**
- [ ] Struct Instruction avec derive Deserialize
- [ ] Champs: id, technique_id, executor, command, timeout
- [ ] Support optionnel de cleanup et payloads
- [ ] Methode timeout_duration() retournant Duration
- [ ] Tests unitaires",agent;beacon
"[AG-08] Creer struct TaskResult",Task,"**Objectif:**
Creer la structure TaskResult pour reporter les resultats d'execution.

**Code Rust exemple:**
```rust
// src/beacon/protocol.rs (suite)
use serde::Serialize;

#[derive(Serialize, Debug, Clone)]
pub struct TaskResult {
    pub id: String,
    pub technique_id: String,
    pub status: TaskStatus,
    pub output: String,      // Base64 encoded stdout
    pub stderr: String,      // Base64 encoded stderr
    pub exit_code: i32,
    pub pid: u32,
    pub started_at: String,  // ISO 8601
    pub completed_at: String,
    pub duration_ms: u64,
}

#[derive(Serialize, Debug, Clone)]
#[serde(rename_all = ""lowercase"")]
pub enum TaskStatus {
    Success,
    Failed,
    Timeout,
    Error,
}

impl TaskResult {
    pub fn success(id: &str, technique_id: &str, output: &[u8], pid: u32, duration_ms: u64) -> Self {
        Self {
            id: id.to_string(),
            technique_id: technique_id.to_string(),
            status: TaskStatus::Success,
            output: base64::encode(output),
            stderr: String::new(),
            exit_code: 0,
            pid,
            started_at: chrono::Utc::now().to_rfc3339(),
            completed_at: chrono::Utc::now().to_rfc3339(),
            duration_ms,
        }
    }

    pub fn failed(id: &str, technique_id: &str, stderr: &[u8], exit_code: i32, pid: u32) -> Self {
        Self {
            id: id.to_string(),
            technique_id: technique_id.to_string(),
            status: TaskStatus::Failed,
            output: String::new(),
            stderr: base64::encode(stderr),
            exit_code,
            pid,
            started_at: chrono::Utc::now().to_rfc3339(),
            completed_at: chrono::Utc::now().to_rfc3339(),
            duration_ms: 0,
        }
    }
}
```

**Fichiers:**
- agent/src/beacon/protocol.rs

**Definition of Done:**
- [ ] Struct TaskResult avec derive Serialize
- [ ] Champs: id, technique_id, status, output, stderr, exit_code, pid
- [ ] Enum TaskStatus (Success, Failed, Timeout, Error)
- [ ] Methodes factory (success, failed, timeout)
- [ ] Output/stderr encodes en base64
- [ ] Tests unitaires",agent;beacon
"[AG-09] Implementer beacon loop",Task,"**Objectif:**
Implementer la boucle principale de l'agent: beacon, execute, report, sleep avec jitter.

**Code Rust exemple:**
```rust
// src/main.rs
use std::time::Duration;
use tokio::time::sleep;
use log::{info, error, debug};

mod config;
mod beacon;
mod executor;

use config::Config;
use beacon::BeaconClient;
use executor::dispatch_executor;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();

    let config = Config::load()?;
    info!(""AutoStrike Agent starting - Server: {}"", config.server_url);

    let mut client = BeaconClient::new(&config)?;

    loop {
        debug!(""Beaconing to server..."");

        match client.beacon().await {
            Ok(instructions) => {
                info!(""Received {} instructions"", instructions.len());

                for instruction in instructions {
                    info!(""Executing technique: {}"", instruction.technique_id);

                    let result = dispatch_executor(&instruction).await;
                    client.queue_result(result);
                }
            }
            Err(e) => {
                error!(""Beacon error: {}"", e);
            }
        }

        // Sleep avec jitter
        let jitter = rand::random::<u64>() % config.jitter;
        let sleep_time = config.sleep + jitter;
        debug!(""Sleeping for {} seconds"", sleep_time);
        sleep(Duration::from_secs(sleep_time)).await;
    }
}
```

**Fichiers:**
- agent/src/main.rs

**Definition of Done:**
- [ ] Boucle infinie implementee avec tokio
- [ ] Appel beacon() periodique
- [ ] Execution des instructions recues
- [ ] Report des resultats au serveur
- [ ] Sleep avec jitter aleatoire
- [ ] Logging des operations
- [ ] Gestion des erreurs sans crash",agent;core
"[AG-10] Implementer detection executors disponibles",Task,"**Objectif:**
Detecter automatiquement les executors disponibles sur le systeme (psh/cmd Windows, bash/sh Linux).

**Code Rust exemple:**
```rust
// src/executor/detection.rs
use std::process::Command;
use std::path::Path;

pub fn detect_available_executors() -> Vec<String> {
    let mut executors = vec![];

    #[cfg(target_os = ""windows"")]
    {
        if is_powershell_available() {
            executors.push(""psh"".to_string());
        }
        if is_cmd_available() {
            executors.push(""cmd"".to_string());
        }
    }

    #[cfg(any(target_os = ""linux"", target_os = ""macos""))]
    {
        if is_bash_available() {
            executors.push(""bash"".to_string());
        }
        if is_sh_available() {
            executors.push(""sh"".to_string());
        }
    }

    executors
}

#[cfg(target_os = ""windows"")]
fn is_powershell_available() -> bool {
    Command::new(""powershell"")
        .args(&[""-NoProfile"", ""-Command"", ""$true""])
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

#[cfg(target_os = ""windows"")]
fn is_cmd_available() -> bool {
    Command::new(""cmd"")
        .args(&[""/c"", ""echo test""])
        .output()
        .map(|o| o.status.success())
        .unwrap_or(false)
}

#[cfg(any(target_os = ""linux"", target_os = ""macos""))]
fn is_bash_available() -> bool {
    Path::new(""/bin/bash"").exists() || Path::new(""/usr/bin/bash"").exists()
}

#[cfg(any(target_os = ""linux"", target_os = ""macos""))]
fn is_sh_available() -> bool {
    Path::new(""/bin/sh"").exists()
}
```

**Fichiers:**
- agent/src/executor/detection.rs
- agent/src/executor/mod.rs

**Definition of Done:**
- [ ] Detection PowerShell sur Windows
- [ ] Detection cmd.exe sur Windows
- [ ] Detection bash sur Linux/macOS
- [ ] Detection sh sur Linux/macOS
- [ ] Fonction detect_available_executors() retourne Vec<String>
- [ ] Compilation conditionnelle par OS",agent;core
"[AG-11] Creer trait Executor",Task,"**Objectif:**
Creer le trait Executor definissant l'interface commune pour tous les executors.

**Code Rust exemple:**
```rust
// src/executor/traits.rs
use std::process::Output;
use std::time::Duration;
use async_trait::async_trait;

#[derive(Debug)]
pub enum ExecutorError {
    NotFound(String),
    Timeout,
    ExecutionFailed(String),
    IoError(std::io::Error),
}

impl std::fmt::Display for ExecutorError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NotFound(name) => write!(f, ""Executor not found: {}"", name),
            Self::Timeout => write!(f, ""Execution timed out""),
            Self::ExecutionFailed(msg) => write!(f, ""Execution failed: {}"", msg),
            Self::IoError(e) => write!(f, ""IO error: {}"", e),
        }
    }
}

impl std::error::Error for ExecutorError {}

#[async_trait]
pub trait Executor: Send + Sync {
    fn name(&self) -> &str;

    async fn execute(&self, command: &str, timeout: Duration) -> Result<ExecutionOutput, ExecutorError>;

    fn is_available(&self) -> bool;
}

#[derive(Debug, Clone)]
pub struct ExecutionOutput {
    pub stdout: Vec<u8>,
    pub stderr: Vec<u8>,
    pub exit_code: i32,
    pub pid: u32,
    pub duration: Duration,
}
```

**Fichiers:**
- agent/src/executor/traits.rs
- agent/src/executor/mod.rs

**Definition of Done:**
- [ ] Trait Executor avec methode execute()
- [ ] Methode name() retournant le nom de l'executor
- [ ] Methode is_available() pour verification
- [ ] Enum ExecutorError avec variantes (NotFound, Timeout, ExecutionFailed, IoError)
- [ ] Struct ExecutionOutput (stdout, stderr, exit_code, pid, duration)
- [ ] Documentation Rustdoc",agent;executor
"[AG-12] Implementer PowerShellExecutor",Task,"**Objectif:**
Implementer l'executor PowerShell pour Windows avec support timeout.

**Code Rust exemple:**
```rust
// src/executor/powershell.rs
use super::traits::{Executor, ExecutorError, ExecutionOutput};
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use async_trait::async_trait;
use tokio::time::timeout;

pub struct PowerShellExecutor;

impl PowerShellExecutor {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl Executor for PowerShellExecutor {
    fn name(&self) -> &str {
        ""psh""
    }

    async fn execute(&self, command: &str, exec_timeout: Duration) -> Result<ExecutionOutput, ExecutorError> {
        let start = Instant::now();

        let child = Command::new(""powershell.exe"")
            .args(&[
                ""-NoProfile"",
                ""-NonInteractive"",
                ""-ExecutionPolicy"", ""Bypass"",
                ""-Command"", command
            ])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(ExecutorError::IoError)?;

        let pid = child.id();

        let result = timeout(exec_timeout, async {
            child.wait_with_output()
        }).await;

        match result {
            Ok(Ok(output)) => Ok(ExecutionOutput {
                stdout: output.stdout,
                stderr: output.stderr,
                exit_code: output.status.code().unwrap_or(-1),
                pid,
                duration: start.elapsed(),
            }),
            Ok(Err(e)) => Err(ExecutorError::IoError(e)),
            Err(_) => Err(ExecutorError::Timeout),
        }
    }

    fn is_available(&self) -> bool {
        #[cfg(target_os = ""windows"")]
        {
            Command::new(""powershell.exe"")
                .args(&[""-NoProfile"", ""-Command"", ""$true""])
                .output()
                .map(|o| o.status.success())
                .unwrap_or(false)
        }
        #[cfg(not(target_os = ""windows""))]
        {
            false
        }
    }
}
```

**Fichiers:**
- agent/src/executor/powershell.rs

**Definition of Done:**
- [ ] Struct PowerShellExecutor implementant trait Executor
- [ ] Execution via powershell.exe -NoProfile -NonInteractive
- [ ] Support ExecutionPolicy Bypass
- [ ] Gestion timeout avec kill process
- [ ] Capture stdout et stderr
- [ ] Retour du PID et exit code
- [ ] Compilation conditionnelle Windows",agent;executor
"[AG-13] Implementer CmdExecutor",Task,"**Objectif:**
Implementer l'executor cmd.exe pour Windows avec support timeout.

**Code Rust exemple:**
```rust
// src/executor/cmd.rs
use super::traits::{Executor, ExecutorError, ExecutionOutput};
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use async_trait::async_trait;
use tokio::time::timeout;

pub struct CmdExecutor;

impl CmdExecutor {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl Executor for CmdExecutor {
    fn name(&self) -> &str {
        ""cmd""
    }

    async fn execute(&self, command: &str, exec_timeout: Duration) -> Result<ExecutionOutput, ExecutorError> {
        let start = Instant::now();

        let child = Command::new(""cmd.exe"")
            .args(&[""/c"", command])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(ExecutorError::IoError)?;

        let pid = child.id();

        let result = timeout(exec_timeout, async {
            child.wait_with_output()
        }).await;

        match result {
            Ok(Ok(output)) => Ok(ExecutionOutput {
                stdout: output.stdout,
                stderr: output.stderr,
                exit_code: output.status.code().unwrap_or(-1),
                pid,
                duration: start.elapsed(),
            }),
            Ok(Err(e)) => Err(ExecutorError::IoError(e)),
            Err(_) => Err(ExecutorError::Timeout),
        }
    }

    fn is_available(&self) -> bool {
        #[cfg(target_os = ""windows"")]
        {
            Command::new(""cmd.exe"")
                .args(&[""/c"", ""echo test""])
                .output()
                .map(|o| o.status.success())
                .unwrap_or(false)
        }
        #[cfg(not(target_os = ""windows""))]
        {
            false
        }
    }
}
```

**Fichiers:**
- agent/src/executor/cmd.rs

**Definition of Done:**
- [ ] Struct CmdExecutor implementant trait Executor
- [ ] Execution via cmd.exe /c
- [ ] Gestion timeout avec kill process
- [ ] Capture stdout et stderr
- [ ] Retour du PID et exit code
- [ ] Compilation conditionnelle Windows
- [ ] Tests unitaires",agent;executor
"[AG-14] Implementer BashExecutor",Task,"**Objectif:**
Implementer l'executor Bash pour Linux/macOS avec support timeout.

**Code Rust exemple:**
```rust
// src/executor/bash.rs
use super::traits::{Executor, ExecutorError, ExecutionOutput};
use std::process::{Command, Stdio};
use std::time::{Duration, Instant};
use async_trait::async_trait;
use tokio::time::timeout;

pub struct BashExecutor;

impl BashExecutor {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl Executor for BashExecutor {
    fn name(&self) -> &str {
        ""bash""
    }

    async fn execute(&self, command: &str, exec_timeout: Duration) -> Result<ExecutionOutput, ExecutorError> {
        let start = Instant::now();

        let child = Command::new(""/bin/bash"")
            .args(&[""-c"", command])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .map_err(ExecutorError::IoError)?;

        let pid = child.id();

        let result = timeout(exec_timeout, async {
            child.wait_with_output()
        }).await;

        match result {
            Ok(Ok(output)) => Ok(ExecutionOutput {
                stdout: output.stdout,
                stderr: output.stderr,
                exit_code: output.status.code().unwrap_or(-1),
                pid,
                duration: start.elapsed(),
            }),
            Ok(Err(e)) => Err(ExecutorError::IoError(e)),
            Err(_) => Err(ExecutorError::Timeout),
        }
    }

    fn is_available(&self) -> bool {
        #[cfg(any(target_os = ""linux"", target_os = ""macos""))]
        {
            std::path::Path::new(""/bin/bash"").exists()
        }
        #[cfg(target_os = ""windows"")]
        {
            false
        }
    }
}
```

**Fichiers:**
- agent/src/executor/bash.rs

**Definition of Done:**
- [ ] Struct BashExecutor implementant trait Executor
- [ ] Execution via /bin/bash -c
- [ ] Gestion timeout avec kill process
- [ ] Capture stdout et stderr
- [ ] Retour du PID et exit code
- [ ] Compilation conditionnelle Linux/macOS
- [ ] Tests unitaires",agent;executor
"[AG-15] Creer dispatcher executor",Task,"**Objectif:**
Creer le dispatcher qui selectionne et execute l'executor approprie selon le type demande.

**Code Rust exemple:**
```rust
// src/executor/dispatcher.rs
use super::traits::{Executor, ExecutorError, ExecutionOutput};
use super::powershell::PowerShellExecutor;
use super::cmd::CmdExecutor;
use super::bash::BashExecutor;
use crate::beacon::protocol::{Instruction, TaskResult, TaskStatus};
use std::time::Duration;

pub struct ExecutorDispatcher {
    executors: Vec<Box<dyn Executor>>,
}

impl ExecutorDispatcher {
    pub fn new() -> Self {
        let mut executors: Vec<Box<dyn Executor>> = vec![];

        #[cfg(target_os = ""windows"")]
        {
            executors.push(Box::new(PowerShellExecutor::new()));
            executors.push(Box::new(CmdExecutor::new()));
        }

        #[cfg(any(target_os = ""linux"", target_os = ""macos""))]
        {
            executors.push(Box::new(BashExecutor::new()));
        }

        Self { executors }
    }

    pub fn get_executor(&self, name: &str) -> Option<&dyn Executor> {
        self.executors.iter()
            .find(|e| e.name() == name && e.is_available())
            .map(|e| e.as_ref())
    }

    pub async fn execute(&self, instruction: &Instruction) -> TaskResult {
        let executor = match self.get_executor(&instruction.executor) {
            Some(e) => e,
            None => return TaskResult::error(&instruction.id, &instruction.technique_id,
                &format!(""Executor '{}' not available"", instruction.executor)),
        };

        let timeout = Duration::from_secs(instruction.timeout);

        match executor.execute(&instruction.command, timeout).await {
            Ok(output) => TaskResult::from_output(&instruction.id, &instruction.technique_id, output),
            Err(e) => TaskResult::error(&instruction.id, &instruction.technique_id, &e.to_string()),
        }
    }
}
```

**Fichiers:**
- agent/src/executor/dispatcher.rs
- agent/src/executor/mod.rs

**Definition of Done:**
- [ ] Struct ExecutorDispatcher gerant tous les executors
- [ ] Methode get_executor() par nom
- [ ] Methode execute() prenant une Instruction
- [ ] Retour TaskResult avec status approprie
- [ ] Gestion des erreurs (executor non disponible)
- [ ] Tests unitaires",agent;core
"[AG-16] Implementer timeout execution",Task,"**Objectif:**
Implementer un timeout configurable par technique avec kill du process si depasse.

**Code Rust exemple:**
```rust
// src/executor/timeout.rs
use std::process::Child;
use std::time::Duration;
use tokio::time::timeout as tokio_timeout;
use tokio::process::Command as TokioCommand;

pub struct TimeoutExecutor;

impl TimeoutExecutor {
    pub async fn execute_with_timeout(
        mut child: Child,
        timeout: Duration,
    ) -> Result<std::process::Output, TimeoutError> {
        let pid = child.id();

        let result = tokio_timeout(timeout, async move {
            child.wait_with_output()
        }).await;

        match result {
            Ok(Ok(output)) => Ok(output),
            Ok(Err(e)) => Err(TimeoutError::IoError(e)),
            Err(_) => {
                // Timeout - kill the process
                Self::kill_process(pid);
                Err(TimeoutError::Timeout)
            }
        }
    }

    #[cfg(target_os = ""windows"")]
    fn kill_process(pid: u32) {
        use std::process::Command;
        let _ = Command::new(""taskkill"")
            .args(&[""/F"", ""/PID"", &pid.to_string(), ""/T""])
            .output();
    }

    #[cfg(any(target_os = ""linux"", target_os = ""macos""))]
    fn kill_process(pid: u32) {
        use std::process::Command;
        let _ = Command::new(""kill"")
            .args(&[""-9"", &pid.to_string()])
            .output();
    }
}

#[derive(Debug)]
pub enum TimeoutError {
    Timeout,
    IoError(std::io::Error),
}
```

**Fichiers:**
- agent/src/executor/timeout.rs

**Definition of Done:**
- [ ] Fonction execute_with_timeout() async
- [ ] Kill process via taskkill (Windows) ou kill -9 (Linux)
- [ ] Retour d'erreur TimeoutError::Timeout
- [ ] Support des child processes (kill tree sur Windows)
- [ ] Tests unitaires avec process longue duree
- [ ] Documentation",agent;core
"[AG-17] Implementer encodage base64 output",Task,"**Objectif:**
Encoder stdout et stderr en base64 pour transmission securisee au serveur.

**Code Rust exemple:**
```rust
// src/utils/encoding.rs
use base64::{Engine as _, engine::general_purpose};

pub struct OutputEncoder;

impl OutputEncoder {
    pub fn encode(data: &[u8]) -> String {
        general_purpose::STANDARD.encode(data)
    }

    pub fn decode(encoded: &str) -> Result<Vec<u8>, base64::DecodeError> {
        general_purpose::STANDARD.decode(encoded)
    }

    pub fn encode_output(stdout: &[u8], stderr: &[u8]) -> (String, String) {
        (Self::encode(stdout), Self::encode(stderr))
    }

    pub fn truncate_and_encode(data: &[u8], max_size: usize) -> String {
        if data.len() <= max_size {
            Self::encode(data)
        } else {
            let truncated = &data[..max_size];
            let suffix = b""... [truncated]"";
            let mut result = truncated.to_vec();
            result.extend_from_slice(suffix);
            Self::encode(&result)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_decode() {
        let data = b""Hello, World!"";
        let encoded = OutputEncoder::encode(data);
        let decoded = OutputEncoder::decode(&encoded).unwrap();
        assert_eq!(data.to_vec(), decoded);
    }

    #[test]
    fn test_truncate() {
        let data = b""This is a very long output that should be truncated"";
        let encoded = OutputEncoder::truncate_and_encode(data, 20);
        let decoded = OutputEncoder::decode(&encoded).unwrap();
        assert!(decoded.len() <= 20 + 15); // max_size + suffix
    }
}
```

**Fichiers:**
- agent/src/utils/encoding.rs
- agent/src/utils/mod.rs

**Definition of Done:**
- [ ] Fonction encode() pour Vec<u8> -> String base64
- [ ] Fonction decode() pour String base64 -> Vec<u8>
- [ ] Fonction truncate_and_encode() pour limiter taille
- [ ] Integration avec TaskResult
- [ ] Tests unitaires encode/decode
- [ ] Gestion des caracteres non-UTF8",agent;core
"[AG-18] Implementer client HTTPS",Task,"**Objectif:**
Configurer le client HTTP reqwest avec TLS pour communication securisee.

**Code Rust exemple:**
```rust
// src/beacon/http.rs
use reqwest::{Client, ClientBuilder, Certificate};
use std::time::Duration;

pub struct HttpClientConfig {
    pub timeout: Duration,
    pub accept_invalid_certs: bool,
    pub ca_cert: Option<Vec<u8>>,
    pub user_agent: String,
}

impl Default for HttpClientConfig {
    fn default() -> Self {
        Self {
            timeout: Duration::from_secs(30),
            accept_invalid_certs: false,
            ca_cert: None,
            user_agent: ""Mozilla/5.0 (Windows NT 10.0; Win64; x64)"".to_string(),
        }
    }
}

pub fn create_https_client(config: &HttpClientConfig) -> Result<Client, reqwest::Error> {
    let mut builder = ClientBuilder::new()
        .timeout(config.timeout)
        .user_agent(&config.user_agent)
        .use_rustls_tls();

    if config.accept_invalid_certs {
        builder = builder.danger_accept_invalid_certs(true);
    }

    if let Some(ca_cert) = &config.ca_cert {
        let cert = Certificate::from_pem(ca_cert)?;
        builder = builder.add_root_certificate(cert);
    }

    builder.build()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_create_client_default() {
        let config = HttpClientConfig::default();
        let client = create_https_client(&config);
        assert!(client.is_ok());
    }
}
```

**Fichiers:**
- agent/src/beacon/http.rs

**Definition of Done:**
- [ ] Client reqwest avec rustls-tls
- [ ] Configuration timeout
- [ ] Support certificat CA custom
- [ ] User-Agent configurable
- [ ] Option danger_accept_invalid_certs pour dev
- [ ] Tests unitaires",agent;http
"[AG-19] Implementer mTLS client",Task,"**Objectif:**
Implementer l'authentification mutuelle TLS (mTLS) avec certificat client.

**Code Rust exemple:**
```rust
// src/beacon/mtls.rs
use reqwest::{Client, ClientBuilder, Certificate, Identity};
use std::fs;
use std::path::Path;

pub struct MtlsConfig {
    pub ca_cert_path: String,
    pub client_cert_path: String,
    pub client_key_path: String,
}

pub fn create_mtls_client(config: &MtlsConfig) -> Result<Client, Box<dyn std::error::Error>> {
    // Load CA certificate
    let ca_cert = fs::read(&config.ca_cert_path)?;
    let ca = Certificate::from_pem(&ca_cert)?;

    // Load client certificate and key
    let client_cert = fs::read(&config.client_cert_path)?;
    let client_key = fs::read(&config.client_key_path)?;

    // Create PKCS12 identity from cert + key
    let mut pem = client_cert.clone();
    pem.extend_from_slice(&client_key);
    let identity = Identity::from_pem(&pem)?;

    let client = ClientBuilder::new()
        .add_root_certificate(ca)
        .identity(identity)
        .use_rustls_tls()
        .build()?;

    Ok(client)
}

pub fn load_embedded_certs() -> Option<MtlsConfig> {
    // For embedded certs at compile time
    let ca_cert = include_bytes!(""../../certs/ca.pem"");
    let client_cert = include_bytes!(""../../certs/agent.pem"");
    let client_key = include_bytes!(""../../certs/agent-key.pem"");

    // Write to temp files and return config
    // (Alternative: modify create_mtls_client to accept bytes directly)
    None
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mtls_config() {
        let config = MtlsConfig {
            ca_cert_path: ""/path/to/ca.pem"".to_string(),
            client_cert_path: ""/path/to/client.pem"".to_string(),
            client_key_path: ""/path/to/client-key.pem"".to_string(),
        };
        assert!(!config.ca_cert_path.is_empty());
    }
}
```

**Fichiers:**
- agent/src/beacon/mtls.rs

**Definition of Done:**
- [ ] Chargement certificat CA
- [ ] Chargement certificat client + cle privee
- [ ] Creation Identity pour reqwest
- [ ] Support certificats embarques (compile-time)
- [ ] Support certificats fichiers externes
- [ ] Tests unitaires avec certificats de test
- [ ] Documentation configuration mTLS",agent;security
"[AG-20] Implementer gestion erreurs reseau",Task,"**Objectif:**
Implementer retry logic avec backoff exponentiel pour les erreurs reseau.

**Code Rust exemple:**
```rust
// src/beacon/retry.rs
use std::time::Duration;
use tokio::time::sleep;
use log::{warn, info};

pub struct RetryConfig {
    pub max_retries: u32,
    pub initial_delay: Duration,
    pub max_delay: Duration,
    pub multiplier: f64,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_retries: 5,
            initial_delay: Duration::from_secs(1),
            max_delay: Duration::from_secs(300),
            multiplier: 2.0,
        }
    }
}

pub async fn retry_with_backoff<F, T, E, Fut>(
    config: &RetryConfig,
    operation_name: &str,
    mut operation: F,
) -> Result<T, E>
where
    F: FnMut() -> Fut,
    Fut: std::future::Future<Output = Result<T, E>>,
    E: std::fmt::Display,
{
    let mut current_delay = config.initial_delay;
    let mut attempts = 0;

    loop {
        match operation().await {
            Ok(result) => {
                if attempts > 0 {
                    info!(""{} succeeded after {} retries"", operation_name, attempts);
                }
                return Ok(result);
            }
            Err(e) => {
                attempts += 1;

                if attempts >= config.max_retries {
                    warn!(""{} failed after {} attempts: {}"", operation_name, attempts, e);
                    return Err(e);
                }

                warn!(""{} failed (attempt {}): {}. Retrying in {:?}"",
                      operation_name, attempts, e, current_delay);

                sleep(current_delay).await;

                current_delay = Duration::from_secs_f64(
                    (current_delay.as_secs_f64() * config.multiplier)
                        .min(config.max_delay.as_secs_f64())
                );
            }
        }
    }
}
```

**Fichiers:**
- agent/src/beacon/retry.rs

**Definition of Done:**
- [ ] Struct RetryConfig (max_retries, initial_delay, max_delay, multiplier)
- [ ] Fonction retry_with_backoff() generique async
- [ ] Backoff exponentiel jusqu'a max_delay
- [ ] Logging des tentatives et erreurs
- [ ] Integration avec BeaconClient
- [ ] Tests unitaires avec mock d'erreurs",agent;core
"[AG-21] Implementer jitter sleep",Task,"**Objectif:**
Implementer variation aleatoire du sleep pour eviter les patterns detectables.

**Code Rust exemple:**
```rust
// src/utils/timing.rs
use std::time::Duration;
use rand::Rng;

pub struct JitterConfig {
    pub base_sleep: Duration,
    pub jitter_percent: u32,  // 0-100
    pub min_sleep: Duration,
    pub max_sleep: Duration,
}

impl Default for JitterConfig {
    fn default() -> Self {
        Self {
            base_sleep: Duration::from_secs(5),
            jitter_percent: 20,
            min_sleep: Duration::from_secs(1),
            max_sleep: Duration::from_secs(60),
        }
    }
}

pub fn calculate_sleep_with_jitter(config: &JitterConfig) -> Duration {
    let mut rng = rand::thread_rng();

    let base_ms = config.base_sleep.as_millis() as i64;
    let jitter_range = (base_ms * config.jitter_percent as i64) / 100;

    let jitter = rng.gen_range(-jitter_range..=jitter_range);
    let sleep_ms = (base_ms + jitter) as u64;

    let sleep = Duration::from_millis(sleep_ms);

    // Clamp to min/max
    sleep.max(config.min_sleep).min(config.max_sleep)
}

pub fn random_sleep_range(min: Duration, max: Duration) -> Duration {
    let mut rng = rand::thread_rng();
    let min_ms = min.as_millis() as u64;
    let max_ms = max.as_millis() as u64;
    Duration::from_millis(rng.gen_range(min_ms..=max_ms))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_jitter_within_bounds() {
        let config = JitterConfig::default();

        for _ in 0..100 {
            let sleep = calculate_sleep_with_jitter(&config);
            assert!(sleep >= config.min_sleep);
            assert!(sleep <= config.max_sleep);
        }
    }
}
```

**Fichiers:**
- agent/src/utils/timing.rs

**Definition of Done:**
- [ ] Struct JitterConfig (base_sleep, jitter_percent, min/max)
- [ ] Fonction calculate_sleep_with_jitter()
- [ ] Jitter +/- configurable en pourcentage
- [ ] Respect des bornes min/max
- [ ] Tests unitaires (distribution, bornes)
- [ ] Integration dans boucle principale",agent;core
"[AG-22] Creer module techniques/discovery",Task,"**Objectif:**
Creer le module pour les techniques Discovery MITRE ATT&CK.

**Code Rust exemple:**
```rust
// src/techniques/discovery/mod.rs
pub mod t1082_system_info;
pub mod t1083_file_discovery;
pub mod t1057_process_discovery;

use crate::executor::traits::ExecutionOutput;

pub trait DiscoveryTechnique {
    fn technique_id(&self) -> &str;
    fn name(&self) -> &str;
    fn description(&self) -> &str;

    fn get_windows_command(&self) -> Option<String>;
    fn get_linux_command(&self) -> Option<String>;

    fn parse_output(&self, output: &ExecutionOutput) -> DiscoveryResult;
}

#[derive(Debug, Clone)]
pub struct DiscoveryResult {
    pub technique_id: String,
    pub success: bool,
    pub data: DiscoveryData,
    pub raw_output: String,
}

#[derive(Debug, Clone)]
pub enum DiscoveryData {
    SystemInfo(SystemInfoData),
    FileList(Vec<FileEntry>),
    ProcessList(Vec<ProcessEntry>),
    Generic(String),
}

#[derive(Debug, Clone)]
pub struct SystemInfoData {
    pub hostname: Option<String>,
    pub os_version: Option<String>,
    pub architecture: Option<String>,
    pub domain: Option<String>,
}

#[derive(Debug, Clone)]
pub struct FileEntry {
    pub path: String,
    pub size: Option<u64>,
    pub modified: Option<String>,
}

#[derive(Debug, Clone)]
pub struct ProcessEntry {
    pub pid: u32,
    pub name: String,
    pub user: Option<String>,
    pub memory: Option<u64>,
}
```

**Fichiers:**
- agent/src/techniques/discovery/mod.rs

**Definition of Done:**
- [ ] Module discovery cree avec mod.rs
- [ ] Trait DiscoveryTechnique defini
- [ ] Structs DiscoveryResult, DiscoveryData
- [ ] Structs specifiques (SystemInfoData, FileEntry, ProcessEntry)
- [ ] Export des sous-modules techniques
- [ ] Documentation Rustdoc",agent;technique
"[AG-23] Implementer T1082 System Info Discovery",Task,"**Objectif:**
Implementer la technique T1082 System Information Discovery.

**Code Rust exemple:**
```rust
// src/techniques/discovery/t1082_system_info.rs
use super::{DiscoveryTechnique, DiscoveryResult, DiscoveryData, SystemInfoData};
use crate::executor::traits::ExecutionOutput;

pub struct T1082SystemInfoDiscovery;

impl DiscoveryTechnique for T1082SystemInfoDiscovery {
    fn technique_id(&self) -> &str {
        ""T1082""
    }

    fn name(&self) -> &str {
        ""System Information Discovery""
    }

    fn description(&self) -> &str {
        ""Gather detailed system information including OS version, hostname, and hardware specs.""
    }

    fn get_windows_command(&self) -> Option<String> {
        // PowerShell version
        Some(r#""Get-ComputerInfo | Select-Object CsName, WindowsVersion, OsArchitecture, CsDomain | ConvertTo-Json""#.to_string())

        // Alternative cmd: systeminfo
    }

    fn get_linux_command(&self) -> Option<String> {
        Some(r#""echo '{""hostname"":""'$(hostname)'"",""kernel"":""'$(uname -r)'"",""arch"":""'$(uname -m)'"",""distro"":""'$(cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '""')'""}'""#.to_string())
    }

    fn parse_output(&self, output: &ExecutionOutput) -> DiscoveryResult {
        let raw = String::from_utf8_lossy(&output.stdout).to_string();

        // Parse JSON output for structured data
        let data = if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(&raw) {
            SystemInfoData {
                hostname: parsed[""CsName""].as_str().or(parsed[""hostname""].as_str()).map(String::from),
                os_version: parsed[""WindowsVersion""].as_str().or(parsed[""kernel""].as_str()).map(String::from),
                architecture: parsed[""OsArchitecture""].as_str().or(parsed[""arch""].as_str()).map(String::from),
                domain: parsed[""CsDomain""].as_str().map(String::from),
            }
        } else {
            SystemInfoData::default()
        };

        DiscoveryResult {
            technique_id: self.technique_id().to_string(),
            success: output.exit_code == 0,
            data: DiscoveryData::SystemInfo(data),
            raw_output: raw,
        }
    }
}
```

**Fichiers:**
- agent/src/techniques/discovery/t1082_system_info.rs

**Definition of Done:**
- [ ] Struct T1082SystemInfoDiscovery implementant DiscoveryTechnique
- [ ] Commande Windows (PowerShell Get-ComputerInfo ou systeminfo)
- [ ] Commande Linux (uname -a, hostnamectl)
- [ ] Parsing de l'output en SystemInfoData
- [ ] Tests unitaires avec outputs de test
- [ ] Documentation MITRE ATT&CK reference",agent;technique
"[AG-24] Implementer T1083 File Discovery",Task,"**Objectif:**
Implementer la technique T1083 File and Directory Discovery.

**Code Rust exemple:**
```rust
// src/techniques/discovery/t1083_file_discovery.rs
use super::{DiscoveryTechnique, DiscoveryResult, DiscoveryData, FileEntry};
use crate::executor::traits::ExecutionOutput;

pub struct T1083FileDiscovery {
    pub target_path: String,
    pub recursive: bool,
    pub pattern: Option<String>,
}

impl T1083FileDiscovery {
    pub fn new(target_path: &str) -> Self {
        Self {
            target_path: target_path.to_string(),
            recursive: false,
            pattern: None,
        }
    }

    pub fn recursive(mut self) -> Self {
        self.recursive = true;
        self
    }

    pub fn with_pattern(mut self, pattern: &str) -> Self {
        self.pattern = Some(pattern.to_string());
        self
    }
}

impl DiscoveryTechnique for T1083FileDiscovery {
    fn technique_id(&self) -> &str {
        ""T1083""
    }

    fn name(&self) -> &str {
        ""File and Directory Discovery""
    }

    fn description(&self) -> &str {
        ""Enumerate files and directories on the system.""
    }

    fn get_windows_command(&self) -> Option<String> {
        let recurse = if self.recursive { ""-Recurse"" } else { """" };
        let filter = self.pattern.as_ref()
            .map(|p| format!(""-Filter '{}'"", p))
            .unwrap_or_default();

        Some(format!(
            ""Get-ChildItem -Path '{}' {} {} | Select-Object FullName, Length, LastWriteTime | ConvertTo-Json"",
            self.target_path, recurse, filter
        ))
    }

    fn get_linux_command(&self) -> Option<String> {
        let cmd = if self.recursive {
            format!(""find '{}' -type f"", self.target_path)
        } else {
            format!(""ls -la '{}'"", self.target_path)
        };
        Some(cmd)
    }

    fn parse_output(&self, output: &ExecutionOutput) -> DiscoveryResult {
        let raw = String::from_utf8_lossy(&output.stdout).to_string();

        let files: Vec<FileEntry> = raw.lines()
            .filter(|l| !l.is_empty())
            .map(|l| FileEntry { path: l.to_string(), size: None, modified: None })
            .collect();

        DiscoveryResult {
            technique_id: self.technique_id().to_string(),
            success: output.exit_code == 0,
            data: DiscoveryData::FileList(files),
            raw_output: raw,
        }
    }
}
```

**Fichiers:**
- agent/src/techniques/discovery/t1083_file_discovery.rs

**Definition of Done:**
- [ ] Struct T1083FileDiscovery avec options (path, recursive, pattern)
- [ ] Commande Windows (Get-ChildItem ou dir)
- [ ] Commande Linux (ls, find)
- [ ] Support recursif
- [ ] Parsing de l'output en FileEntry
- [ ] Tests unitaires",agent;technique
"[AG-25] Implementer T1057 Process Discovery",Task,"**Objectif:**
Implementer la technique T1057 Process Discovery.

**Code Rust exemple:**
```rust
// src/techniques/discovery/t1057_process_discovery.rs
use super::{DiscoveryTechnique, DiscoveryResult, DiscoveryData, ProcessEntry};
use crate::executor::traits::ExecutionOutput;

pub struct T1057ProcessDiscovery {
    pub filter_user: Option<String>,
    pub filter_name: Option<String>,
}

impl T1057ProcessDiscovery {
    pub fn new() -> Self {
        Self {
            filter_user: None,
            filter_name: None,
        }
    }

    pub fn filter_by_user(mut self, user: &str) -> Self {
        self.filter_user = Some(user.to_string());
        self
    }
}

impl DiscoveryTechnique for T1057ProcessDiscovery {
    fn technique_id(&self) -> &str {
        ""T1057""
    }

    fn name(&self) -> &str {
        ""Process Discovery""
    }

    fn description(&self) -> &str {
        ""List running processes on the system.""
    }

    fn get_windows_command(&self) -> Option<String> {
        Some(r#""Get-Process | Select-Object Id, ProcessName, UserName, WorkingSet64 | ConvertTo-Json""#.to_string())
        // Alternative: tasklist /V
    }

    fn get_linux_command(&self) -> Option<String> {
        Some(""ps aux --no-headers"".to_string())
    }

    fn parse_output(&self, output: &ExecutionOutput) -> DiscoveryResult {
        let raw = String::from_utf8_lossy(&output.stdout).to_string();

        let processes: Vec<ProcessEntry> = if cfg!(target_os = ""windows"") {
            // Parse JSON
            serde_json::from_str::<Vec<serde_json::Value>>(&raw)
                .unwrap_or_default()
                .iter()
                .map(|p| ProcessEntry {
                    pid: p[""Id""].as_u64().unwrap_or(0) as u32,
                    name: p[""ProcessName""].as_str().unwrap_or("""").to_string(),
                    user: p[""UserName""].as_str().map(String::from),
                    memory: p[""WorkingSet64""].as_u64(),
                })
                .collect()
        } else {
            // Parse ps aux output
            raw.lines()
                .filter_map(|line| {
                    let parts: Vec<&str> = line.split_whitespace().collect();
                    if parts.len() >= 11 {
                        Some(ProcessEntry {
                            pid: parts[1].parse().unwrap_or(0),
                            name: parts[10..].join("" ""),
                            user: Some(parts[0].to_string()),
                            memory: parts[5].parse().ok(),
                        })
                    } else {
                        None
                    }
                })
                .collect()
        };

        DiscoveryResult {
            technique_id: self.technique_id().to_string(),
            success: output.exit_code == 0,
            data: DiscoveryData::ProcessList(processes),
            raw_output: raw,
        }
    }
}
```

**Fichiers:**
- agent/src/techniques/discovery/t1057_process_discovery.rs

**Definition of Done:**
- [ ] Struct T1057ProcessDiscovery
- [ ] Commande Windows (Get-Process ou tasklist)
- [ ] Commande Linux (ps aux)
- [ ] Parsing des processes en ProcessEntry
- [ ] Support filtrage par user/name
- [ ] Tests unitaires",agent;technique
"[AG-26] Creer module techniques/execution",Task,"**Objectif:**
Creer le module pour les techniques Execution MITRE ATT&CK.

**Code Rust exemple:**
```rust
// src/techniques/execution/mod.rs
pub mod t1059_command_scripting;

use crate::executor::traits::ExecutionOutput;

pub trait ExecutionTechnique {
    fn technique_id(&self) -> &str;
    fn sub_technique_id(&self) -> Option<&str>;
    fn name(&self) -> &str;
    fn description(&self) -> &str;

    fn get_executor_type(&self) -> &str;
    fn get_command(&self) -> String;

    fn validate_output(&self, output: &ExecutionOutput) -> ExecutionValidation;
}

#[derive(Debug, Clone)]
pub struct ExecutionValidation {
    pub technique_id: String,
    pub executed: bool,
    pub expected_artifacts: Vec<String>,
    pub observed_artifacts: Vec<String>,
}

pub enum CommandInterpretation {
    /// Execute command directly
    Direct(String),
    /// Execute script file
    ScriptFile { content: String, extension: String },
    /// Execute encoded command
    Encoded(String),
}

impl ExecutionValidation {
    pub fn success(technique_id: &str) -> Self {
        Self {
            technique_id: technique_id.to_string(),
            executed: true,
            expected_artifacts: vec![],
            observed_artifacts: vec![],
        }
    }

    pub fn failed(technique_id: &str) -> Self {
        Self {
            technique_id: technique_id.to_string(),
            executed: false,
            expected_artifacts: vec![],
            observed_artifacts: vec![],
        }
    }
}
```

**Fichiers:**
- agent/src/techniques/execution/mod.rs

**Definition of Done:**
- [ ] Module execution cree avec mod.rs
- [ ] Trait ExecutionTechnique defini
- [ ] Struct ExecutionValidation
- [ ] Enum CommandInterpretation
- [ ] Export des sous-modules
- [ ] Documentation",agent;technique
"[AG-27] Implementer T1059.001 PowerShell",Task,"**Objectif:**
Implementer la technique T1059.001 PowerShell execution.

**Code Rust exemple:**
```rust
// src/techniques/execution/t1059_command_scripting.rs
use super::{ExecutionTechnique, ExecutionValidation};
use crate::executor::traits::ExecutionOutput;

pub struct T1059001PowerShell {
    pub command: String,
    pub encoded: bool,
    pub bypass_execution_policy: bool,
}

impl T1059001PowerShell {
    pub fn new(command: &str) -> Self {
        Self {
            command: command.to_string(),
            encoded: false,
            bypass_execution_policy: true,
        }
    }

    pub fn encoded(command: &str) -> Self {
        let encoded = base64::encode(command.encode_utf16().flat_map(|c| c.to_le_bytes()).collect::<Vec<u8>>());
        Self {
            command: encoded,
            encoded: true,
            bypass_execution_policy: true,
        }
    }

    pub fn build_full_command(&self) -> String {
        let mut args = vec![""-NoProfile"", ""-NonInteractive""];

        if self.bypass_execution_policy {
            args.push(""-ExecutionPolicy"");
            args.push(""Bypass"");
        }

        if self.encoded {
            args.push(""-EncodedCommand"");
            args.push(&self.command);
        } else {
            args.push(""-Command"");
            args.push(&self.command);
        }

        format!(""powershell.exe {}"", args.join("" ""))
    }
}

impl ExecutionTechnique for T1059001PowerShell {
    fn technique_id(&self) -> &str {
        ""T1059""
    }

    fn sub_technique_id(&self) -> Option<&str> {
        Some(""001"")
    }

    fn name(&self) -> &str {
        ""PowerShell""
    }

    fn description(&self) -> &str {
        ""Execute commands via PowerShell interpreter.""
    }

    fn get_executor_type(&self) -> &str {
        ""psh""
    }

    fn get_command(&self) -> String {
        self.command.clone()
    }

    fn validate_output(&self, output: &ExecutionOutput) -> ExecutionValidation {
        if output.exit_code == 0 {
            ExecutionValidation::success(""T1059.001"")
        } else {
            ExecutionValidation::failed(""T1059.001"")
        }
    }
}
```

**Fichiers:**
- agent/src/techniques/execution/t1059_command_scripting.rs

**Definition of Done:**
- [ ] Struct T1059001PowerShell implementant ExecutionTechnique
- [ ] Support commandes encodees base64
- [ ] Support ExecutionPolicy Bypass
- [ ] Builder pour arguments PowerShell
- [ ] Validation de l'output
- [ ] Tests unitaires",agent;technique
"[AG-28] Implementer T1059.003 Windows CMD",Task,"**Objectif:**
Implementer la technique T1059.003 Windows Command Shell.

**Code Rust exemple:**
```rust
// src/techniques/execution/t1059_command_scripting.rs (suite)

pub struct T1059003WindowsCmd {
    pub command: String,
    pub working_directory: Option<String>,
}

impl T1059003WindowsCmd {
    pub fn new(command: &str) -> Self {
        Self {
            command: command.to_string(),
            working_directory: None,
        }
    }

    pub fn with_working_dir(mut self, dir: &str) -> Self {
        self.working_directory = Some(dir.to_string());
        self
    }

    pub fn build_full_command(&self) -> String {
        let cd_prefix = self.working_directory.as_ref()
            .map(|d| format!(""cd /d \""{}\""&& "", d))
            .unwrap_or_default();

        format!(""cmd.exe /c {}{}"", cd_prefix, self.command)
    }
}

impl ExecutionTechnique for T1059003WindowsCmd {
    fn technique_id(&self) -> &str {
        ""T1059""
    }

    fn sub_technique_id(&self) -> Option<&str> {
        Some(""003"")
    }

    fn name(&self) -> &str {
        ""Windows Command Shell""
    }

    fn description(&self) -> &str {
        ""Execute commands via cmd.exe command interpreter.""
    }

    fn get_executor_type(&self) -> &str {
        ""cmd""
    }

    fn get_command(&self) -> String {
        self.command.clone()
    }

    fn validate_output(&self, output: &ExecutionOutput) -> ExecutionValidation {
        if output.exit_code == 0 {
            ExecutionValidation::success(""T1059.003"")
        } else {
            ExecutionValidation::failed(""T1059.003"")
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cmd_command() {
        let tech = T1059003WindowsCmd::new(""echo hello"");
        assert_eq!(tech.get_executor_type(), ""cmd"");
    }
}
```

**Fichiers:**
- agent/src/techniques/execution/t1059_command_scripting.rs

**Definition of Done:**
- [ ] Struct T1059003WindowsCmd implementant ExecutionTechnique
- [ ] Support working directory
- [ ] Builder pour arguments cmd.exe
- [ ] Validation de l'output
- [ ] Tests unitaires
- [ ] Documentation",agent;technique
"[AG-29] Implementer T1059.004 Unix Shell",Task,"**Objectif:**
Implementer la technique T1059.004 Unix Shell execution.

**Code Rust exemple:**
```rust
// src/techniques/execution/t1059_command_scripting.rs (suite)

pub struct T1059004UnixShell {
    pub command: String,
    pub shell: UnixShellType,
    pub interactive: bool,
}

#[derive(Clone, Copy)]
pub enum UnixShellType {
    Bash,
    Sh,
    Zsh,
}

impl UnixShellType {
    pub fn path(&self) -> &str {
        match self {
            Self::Bash => ""/bin/bash"",
            Self::Sh => ""/bin/sh"",
            Self::Zsh => ""/bin/zsh"",
        }
    }

    pub fn name(&self) -> &str {
        match self {
            Self::Bash => ""bash"",
            Self::Sh => ""sh"",
            Self::Zsh => ""zsh"",
        }
    }
}

impl T1059004UnixShell {
    pub fn bash(command: &str) -> Self {
        Self {
            command: command.to_string(),
            shell: UnixShellType::Bash,
            interactive: false,
        }
    }

    pub fn sh(command: &str) -> Self {
        Self {
            command: command.to_string(),
            shell: UnixShellType::Sh,
            interactive: false,
        }
    }

    pub fn build_full_command(&self) -> String {
        let flag = if self.interactive { ""-ic"" } else { ""-c"" };
        format!(""{} {} '{}'"", self.shell.path(), flag, self.command)
    }
}

impl ExecutionTechnique for T1059004UnixShell {
    fn technique_id(&self) -> &str {
        ""T1059""
    }

    fn sub_technique_id(&self) -> Option<&str> {
        Some(""004"")
    }

    fn name(&self) -> &str {
        ""Unix Shell""
    }

    fn description(&self) -> &str {
        ""Execute commands via Unix shell interpreters (bash, sh, zsh).""
    }

    fn get_executor_type(&self) -> &str {
        self.shell.name()
    }

    fn get_command(&self) -> String {
        self.command.clone()
    }

    fn validate_output(&self, output: &ExecutionOutput) -> ExecutionValidation {
        if output.exit_code == 0 {
            ExecutionValidation::success(""T1059.004"")
        } else {
            ExecutionValidation::failed(""T1059.004"")
        }
    }
}
```

**Fichiers:**
- agent/src/techniques/execution/t1059_command_scripting.rs

**Definition of Done:**
- [ ] Struct T1059004UnixShell implementant ExecutionTechnique
- [ ] Support bash, sh, zsh
- [ ] Enum UnixShellType
- [ ] Mode interactif optionnel
- [ ] Validation de l'output
- [ ] Tests unitaires",agent;technique
"[AG-30] Creer module techniques/persistence",Task,"**Objectif:**
Creer le module pour les techniques Persistence MITRE ATT&CK.

**Code Rust exemple:**
```rust
// src/techniques/persistence/mod.rs
pub mod t1053_scheduled_task;
pub mod t1547_registry_run;

use crate::executor::traits::ExecutionOutput;

pub trait PersistenceTechnique {
    fn technique_id(&self) -> &str;
    fn sub_technique_id(&self) -> Option<&str>;
    fn name(&self) -> &str;
    fn description(&self) -> &str;

    /// Install persistence mechanism
    fn get_install_command(&self) -> String;

    /// Remove persistence mechanism (cleanup)
    fn get_cleanup_command(&self) -> String;

    /// Verify if persistence is active
    fn get_verify_command(&self) -> String;

    fn validate_installation(&self, output: &ExecutionOutput) -> PersistenceResult;
    fn validate_cleanup(&self, output: &ExecutionOutput) -> bool;
}

#[derive(Debug, Clone)]
pub struct PersistenceResult {
    pub technique_id: String,
    pub installed: bool,
    pub location: String,
    pub cleanup_required: bool,
    pub artifacts: Vec<PersistenceArtifact>,
}

#[derive(Debug, Clone)]
pub struct PersistenceArtifact {
    pub artifact_type: ArtifactType,
    pub path: String,
    pub value: Option<String>,
}

#[derive(Debug, Clone)]
pub enum ArtifactType {
    RegistryKey,
    ScheduledTask,
    Service,
    File,
    StartupItem,
}
```

**Fichiers:**
- agent/src/techniques/persistence/mod.rs

**Definition of Done:**
- [ ] Module persistence cree avec mod.rs
- [ ] Trait PersistenceTechnique defini
- [ ] Methodes install, cleanup, verify
- [ ] Struct PersistenceResult et PersistenceArtifact
- [ ] Enum ArtifactType
- [ ] Documentation",agent;technique
"[AG-31] Implementer T1053.005 Scheduled Task",Task,"**Objectif:**
Implementer la technique T1053.005 Scheduled Task/Job pour Windows.

**Code Rust exemple:**
```rust
// src/techniques/persistence/t1053_scheduled_task.rs
use super::{PersistenceTechnique, PersistenceResult, PersistenceArtifact, ArtifactType};
use crate::executor::traits::ExecutionOutput;

pub struct T1053005ScheduledTask {
    pub task_name: String,
    pub command: String,
    pub schedule: ScheduleType,
    pub run_level: RunLevel,
}

#[derive(Clone)]
pub enum ScheduleType {
    Once { time: String },         // HH:MM
    Daily { time: String },
    OnLogon,
    OnStartup,
    OnIdle,
}

#[derive(Clone)]
pub enum RunLevel {
    Limited,
    Highest,
}

impl T1053005ScheduledTask {
    pub fn new(task_name: &str, command: &str) -> Self {
        Self {
            task_name: task_name.to_string(),
            command: command.to_string(),
            schedule: ScheduleType::OnLogon,
            run_level: RunLevel::Limited,
        }
    }
}

impl PersistenceTechnique for T1053005ScheduledTask {
    fn technique_id(&self) -> &str { ""T1053"" }
    fn sub_technique_id(&self) -> Option<&str> { Some(""005"") }
    fn name(&self) -> &str { ""Scheduled Task/Job"" }
    fn description(&self) -> &str { ""Create scheduled task for persistence."" }

    fn get_install_command(&self) -> String {
        let schedule_arg = match &self.schedule {
            ScheduleType::Once { time } => format!(""/SC ONCE /ST {}"", time),
            ScheduleType::Daily { time } => format!(""/SC DAILY /ST {}"", time),
            ScheduleType::OnLogon => ""/SC ONLOGON"".to_string(),
            ScheduleType::OnStartup => ""/SC ONSTART"".to_string(),
            ScheduleType::OnIdle => ""/SC ONIDLE /I 10"".to_string(),
        };

        let run_level = match self.run_level {
            RunLevel::Limited => """",
            RunLevel::Highest => ""/RL HIGHEST"",
        };

        format!(
            ""schtasks /Create /TN \""{}\""  {} /TR \""{}\"" {} /F"",
            self.task_name, schedule_arg, self.command, run_level
        )
    }

    fn get_cleanup_command(&self) -> String {
        format!(""schtasks /Delete /TN \""{}\""  /F"", self.task_name)
    }

    fn get_verify_command(&self) -> String {
        format!(""schtasks /Query /TN \""{}\"" "", self.task_name)
    }

    fn validate_installation(&self, output: &ExecutionOutput) -> PersistenceResult {
        PersistenceResult {
            technique_id: ""T1053.005"".to_string(),
            installed: output.exit_code == 0,
            location: format!(""Task Scheduler: {}"", self.task_name),
            cleanup_required: output.exit_code == 0,
            artifacts: vec![PersistenceArtifact {
                artifact_type: ArtifactType::ScheduledTask,
                path: self.task_name.clone(),
                value: Some(self.command.clone()),
            }],
        }
    }

    fn validate_cleanup(&self, output: &ExecutionOutput) -> bool {
        output.exit_code == 0
    }
}
```

**Fichiers:**
- agent/src/techniques/persistence/t1053_scheduled_task.rs

**Definition of Done:**
- [ ] Struct T1053005ScheduledTask implementant PersistenceTechnique
- [ ] Support differents schedules (Once, Daily, OnLogon, OnStartup)
- [ ] Support run level (Limited, Highest)
- [ ] Commande d'installation (schtasks /Create)
- [ ] Commande de cleanup (schtasks /Delete)
- [ ] Commande de verification
- [ ] Tests unitaires",agent;technique
"[AG-32] Implementer T1547.001 Registry Run Keys",Task,"**Objectif:**
Implementer la technique T1547.001 Registry Run Keys / Startup Folder.

**Code Rust exemple:**
```rust
// src/techniques/persistence/t1547_registry_run.rs
use super::{PersistenceTechnique, PersistenceResult, PersistenceArtifact, ArtifactType};
use crate::executor::traits::ExecutionOutput;

pub struct T1547001RegistryRunKeys {
    pub key_name: String,
    pub command: String,
    pub registry_hive: RegistryHive,
    pub run_type: RunKeyType,
}

#[derive(Clone)]
pub enum RegistryHive {
    HKCU,  // Current User
    HKLM,  // Local Machine (requires admin)
}

#[derive(Clone)]
pub enum RunKeyType {
    Run,
    RunOnce,
}

impl T1547001RegistryRunKeys {
    pub fn hkcu_run(key_name: &str, command: &str) -> Self {
        Self {
            key_name: key_name.to_string(),
            command: command.to_string(),
            registry_hive: RegistryHive::HKCU,
            run_type: RunKeyType::Run,
        }
    }

    fn get_registry_path(&self) -> String {
        let hive = match self.registry_hive {
            RegistryHive::HKCU => ""HKCU"",
            RegistryHive::HKLM => ""HKLM"",
        };
        let subkey = match self.run_type {
            RunKeyType::Run => ""Software\\Microsoft\\Windows\\CurrentVersion\\Run"",
            RunKeyType::RunOnce => ""Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce"",
        };
        format!(""{}\\{}"", hive, subkey)
    }
}

impl PersistenceTechnique for T1547001RegistryRunKeys {
    fn technique_id(&self) -> &str { ""T1547"" }
    fn sub_technique_id(&self) -> Option<&str> { Some(""001"") }
    fn name(&self) -> &str { ""Registry Run Keys / Startup Folder"" }
    fn description(&self) -> &str { ""Add entry to registry Run keys for persistence."" }

    fn get_install_command(&self) -> String {
        format!(
            ""reg add \""{}\""  /v \""{}\""  /t REG_SZ /d \""{}\""  /f"",
            self.get_registry_path(), self.key_name, self.command
        )
    }

    fn get_cleanup_command(&self) -> String {
        format!(
            ""reg delete \""{}\""  /v \""{}\""  /f"",
            self.get_registry_path(), self.key_name
        )
    }

    fn get_verify_command(&self) -> String {
        format!(
            ""reg query \""{}\""  /v \""{}\"" "",
            self.get_registry_path(), self.key_name
        )
    }

    fn validate_installation(&self, output: &ExecutionOutput) -> PersistenceResult {
        PersistenceResult {
            technique_id: ""T1547.001"".to_string(),
            installed: output.exit_code == 0,
            location: format!(""{}\\{}"", self.get_registry_path(), self.key_name),
            cleanup_required: output.exit_code == 0,
            artifacts: vec![PersistenceArtifact {
                artifact_type: ArtifactType::RegistryKey,
                path: self.get_registry_path(),
                value: Some(self.command.clone()),
            }],
        }
    }

    fn validate_cleanup(&self, output: &ExecutionOutput) -> bool {
        output.exit_code == 0
    }
}
```

**Fichiers:**
- agent/src/techniques/persistence/t1547_registry_run.rs

**Definition of Done:**
- [ ] Struct T1547001RegistryRunKeys implementant PersistenceTechnique
- [ ] Support HKCU et HKLM
- [ ] Support Run et RunOnce
- [ ] Commande d'installation (reg add)
- [ ] Commande de cleanup (reg delete)
- [ ] Commande de verification (reg query)
- [ ] Tests unitaires",agent;technique
"[AG-33] Creer module techniques/defense_evasion",Task,"**Objectif:**
Creer le module pour les techniques Defense Evasion MITRE ATT&CK.

**Code Rust exemple:**
```rust
// src/techniques/defense_evasion/mod.rs
pub mod t1070_indicator_removal;

use crate::executor::traits::ExecutionOutput;

pub trait DefenseEvasionTechnique {
    fn technique_id(&self) -> &str;
    fn sub_technique_id(&self) -> Option<&str>;
    fn name(&self) -> &str;
    fn description(&self) -> &str;

    /// Get command to execute the evasion technique
    fn get_evasion_command(&self) -> String;

    /// Check if evasion was successful
    fn validate_evasion(&self, output: &ExecutionOutput) -> EvasionResult;

    /// Is this technique safe to run in production?
    fn is_safe(&self) -> bool;
}

#[derive(Debug, Clone)]
pub struct EvasionResult {
    pub technique_id: String,
    pub success: bool,
    pub artifacts_removed: Vec<String>,
    pub detection_risk: DetectionRisk,
}

#[derive(Debug, Clone)]
pub enum DetectionRisk {
    Low,
    Medium,
    High,
}

impl EvasionResult {
    pub fn success(technique_id: &str) -> Self {
        Self {
            technique_id: technique_id.to_string(),
            success: true,
            artifacts_removed: vec![],
            detection_risk: DetectionRisk::Low,
        }
    }

    pub fn failed(technique_id: &str) -> Self {
        Self {
            technique_id: technique_id.to_string(),
            success: false,
            artifacts_removed: vec![],
            detection_risk: DetectionRisk::Low,
        }
    }

    pub fn with_artifacts(mut self, artifacts: Vec<String>) -> Self {
        self.artifacts_removed = artifacts;
        self
    }
}
```

**Fichiers:**
- agent/src/techniques/defense_evasion/mod.rs

**Definition of Done:**
- [ ] Module defense_evasion cree avec mod.rs
- [ ] Trait DefenseEvasionTechnique defini
- [ ] Struct EvasionResult
- [ ] Enum DetectionRisk
- [ ] Methode is_safe() pour securite
- [ ] Documentation",agent;technique
"[AG-34] Implementer T1070.004 File Deletion",Task,"**Objectif:**
Implementer la technique T1070.004 Indicator Removal on Host: File Deletion.

**Code Rust exemple:**
```rust
// src/techniques/defense_evasion/t1070_indicator_removal.rs
use super::{DefenseEvasionTechnique, EvasionResult, DetectionRisk};
use crate::executor::traits::ExecutionOutput;

pub struct T1070004FileDeletion {
    pub target_paths: Vec<String>,
    pub secure_delete: bool,
    pub recursive: bool,
}

impl T1070004FileDeletion {
    pub fn new(paths: Vec<String>) -> Self {
        Self {
            target_paths: paths,
            secure_delete: false,
            recursive: false,
        }
    }

    pub fn secure(mut self) -> Self {
        self.secure_delete = true;
        self
    }

    pub fn recursive(mut self) -> Self {
        self.recursive = true;
        self
    }
}

impl DefenseEvasionTechnique for T1070004FileDeletion {
    fn technique_id(&self) -> &str { ""T1070"" }
    fn sub_technique_id(&self) -> Option<&str> { Some(""004"") }
    fn name(&self) -> &str { ""Indicator Removal on Host: File Deletion"" }
    fn description(&self) -> &str { ""Delete files to remove evidence of activity."" }

    fn get_evasion_command(&self) -> String {
        #[cfg(target_os = ""windows"")]
        {
            let force = ""/F"";
            let recurse = if self.recursive { ""/S /Q"" } else { """" };

            if self.secure_delete {
                // Use cipher for secure delete
                self.target_paths.iter()
                    .map(|p| format!(""cipher /w:\""{}\"""", p))
                    .collect::<Vec<_>>()
                    .join("" && "")
            } else {
                self.target_paths.iter()
                    .map(|p| format!(""del {} {} \""{}\"" "", force, recurse, p))
                    .collect::<Vec<_>>()
                    .join("" && "")
            }
        }

        #[cfg(any(target_os = ""linux"", target_os = ""macos""))]
        {
            let recurse = if self.recursive { ""-r"" } else { """" };

            if self.secure_delete {
                self.target_paths.iter()
                    .map(|p| format!(""shred -u '{}'"", p))
                    .collect::<Vec<_>>()
                    .join("" && "")
            } else {
                self.target_paths.iter()
                    .map(|p| format!(""rm -f {} '{}'"", recurse, p))
                    .collect::<Vec<_>>()
                    .join("" && "")
            }
        }
    }

    fn validate_evasion(&self, output: &ExecutionOutput) -> EvasionResult {
        if output.exit_code == 0 {
            EvasionResult::success(""T1070.004"")
                .with_artifacts(self.target_paths.clone())
        } else {
            EvasionResult::failed(""T1070.004"")
        }
    }

    fn is_safe(&self) -> bool {
        // Safe if only deleting known test artifacts
        self.target_paths.iter().all(|p|
            p.contains(""autostrike"") || p.contains(""test"") || p.contains(""tmp"")
        )
    }
}
```

**Fichiers:**
- agent/src/techniques/defense_evasion/t1070_indicator_removal.rs

**Definition of Done:**
- [ ] Struct T1070004FileDeletion implementant DefenseEvasionTechnique
- [ ] Support Windows (del, cipher /w)
- [ ] Support Linux (rm, shred)
- [ ] Option secure delete
- [ ] Option recursive
- [ ] Methode is_safe() implementee
- [ ] Tests unitaires",agent;technique
"[AG-35] Configurer cross-compilation Windows",Task,"**Objectif:**
Configurer la compilation croisee pour generer des binaires Windows depuis Linux.

**Code Rust exemple:**
```rust
// .cargo/config.toml
[target.x86_64-pc-windows-gnu]
linker = ""x86_64-w64-mingw32-gcc""

[target.i686-pc-windows-gnu]
linker = ""i686-w64-mingw32-gcc""

// build.rs
fn main() {
    // Set Windows-specific options
    #[cfg(target_os = ""windows"")]
    {
        // Embed Windows manifest
        embed_resource::compile(""windows/app.rc"", embed_resource::NONE);

        // Link Windows libraries
        println!(""cargo:rustc-link-lib=user32"");
        println!(""cargo:rustc-link-lib=kernel32"");
    }

    // Print build info
    println!(""cargo:rustc-env=BUILD_TARGET={}"", std::env::var(""TARGET"").unwrap_or_default());
    println!(""cargo:rustc-env=BUILD_DATE={}"", chrono::Utc::now().format(""%Y-%m-%d""));
}

// Makefile ou script
// Build commands:
// rustup target add x86_64-pc-windows-gnu
// cargo build --release --target x86_64-pc-windows-gnu
```

**Fichiers:**
- agent/.cargo/config.toml
- agent/build.rs
- agent/windows/app.rc (optionnel)

**Definition of Done:**
- [ ] Target x86_64-pc-windows-gnu configure
- [ ] Linker mingw-w64 configure
- [ ] cargo build --target x86_64-pc-windows-gnu fonctionne
- [ ] Binaire .exe genere
- [ ] build.rs avec metadata
- [ ] Documentation installation outils",agent;build
"[AG-36] Configurer cross-compilation Linux x64",Task,"**Objectif:**
Configurer la compilation pour Linux x64 avec binaire statique.

**Code Rust exemple:**
```rust
// .cargo/config.toml
[target.x86_64-unknown-linux-gnu]
rustflags = [""-C"", ""target-feature=+crt-static""]

[target.x86_64-unknown-linux-musl]
linker = ""x86_64-linux-musl-gcc""
rustflags = [""-C"", ""target-feature=+crt-static""]

// Cargo.toml
[profile.release]
opt-level = ""z""
lto = true
codegen-units = 1
panic = ""abort""
strip = true

// Build script example
#!/bin/bash
# build-linux.sh

set -e

# Install musl target
rustup target add x86_64-unknown-linux-musl

# Build static binary
RUSTFLAGS='-C target-feature=+crt-static' \
cargo build --release --target x86_64-unknown-linux-musl

# Check binary
file target/x86_64-unknown-linux-musl/release/autostrike-agent
ldd target/x86_64-unknown-linux-musl/release/autostrike-agent || echo ""Static binary - no dependencies""
```

**Fichiers:**
- agent/.cargo/config.toml
- scripts/build-linux.sh

**Definition of Done:**
- [ ] Target x86_64-unknown-linux-musl configure
- [ ] Binaire statique (pas de dependances dynamiques)
- [ ] cargo build --target x86_64-unknown-linux-musl fonctionne
- [ ] Binaire fonctionne sur differentes distros Linux
- [ ] Documentation",agent;build
"[AG-37] Configurer cross-compilation Linux ARM64",Task,"**Objectif:**
Configurer la compilation croisee pour Linux ARM64 (Raspberry Pi, serveurs ARM).

**Code Rust exemple:**
```rust
// .cargo/config.toml
[target.aarch64-unknown-linux-gnu]
linker = ""aarch64-linux-gnu-gcc""

[target.aarch64-unknown-linux-musl]
linker = ""aarch64-linux-musl-gcc""
rustflags = [""-C"", ""target-feature=+crt-static""]

// Build script
#!/bin/bash
# build-arm64.sh

set -e

# Install target
rustup target add aarch64-unknown-linux-musl

# Install cross-compiler (Debian/Ubuntu)
# apt-get install gcc-aarch64-linux-gnu

# Or use cross for easier setup
# cargo install cross

# Build with cross (recommended)
cross build --release --target aarch64-unknown-linux-musl

# Or native build
CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=aarch64-linux-musl-gcc \
cargo build --release --target aarch64-unknown-linux-musl

echo ""ARM64 binary built successfully""
```

**Fichiers:**
- agent/.cargo/config.toml
- scripts/build-arm64.sh

**Definition of Done:**
- [ ] Target aarch64-unknown-linux-musl configure
- [ ] Cross-compiler aarch64 installe
- [ ] cargo build --target aarch64-unknown-linux-musl fonctionne
- [ ] Binaire fonctionne sur Raspberry Pi / ARM servers
- [ ] Documentation",agent;build
"[AG-38] Optimiser taille binaire release",Task,"**Objectif:**
Optimiser la taille du binaire release avec LTO, strip et autres options.

**Code Rust exemple:**
```rust
// Cargo.toml
[profile.release]
opt-level = ""z""       # Optimize for size
lto = true             # Enable Link-Time Optimization
codegen-units = 1      # Better optimization, slower compile
panic = ""abort""        # Don't include unwinding code
strip = true           # Strip symbols

[profile.release.package.""*""]
opt-level = ""z""

// Alternative profile for smallest binary
[profile.min-size]
inherits = ""release""
opt-level = ""z""
lto = ""fat""
codegen-units = 1
panic = ""abort""
strip = ""symbols""

// build.rs
fn main() {
    // Enable dead code elimination
    println!(""cargo:rustc-link-arg=-Wl,--gc-sections"");

    #[cfg(target_os = ""linux"")]
    {
        // Aggressive stripping for Linux
        println!(""cargo:rustc-link-arg=-s"");
    }
}

// .cargo/config.toml
[build]
rustflags = [""-C"", ""link-arg=-s""]

// Usage:
// cargo build --profile min-size
```

**Fichiers:**
- agent/Cargo.toml
- agent/build.rs
- agent/.cargo/config.toml

**Definition of Done:**
- [ ] Profile release optimise pour taille
- [ ] LTO active (fat LTO)
- [ ] Strip symbols active
- [ ] opt-level z configure
- [ ] Taille binaire < 5MB (idealement < 2MB)
- [ ] Benchmark avant/apres optimisation
- [ ] Documentation",agent;build
"[AG-39] Creer script build-agent.sh",Task,"**Objectif:**
Creer un script de build multi-plateforme automatise.

**Code Rust exemple:**
```bash
#!/bin/bash
# scripts/build-agent.sh

set -e

VERSION=${1:-""0.1.0""}
OUTPUT_DIR=""dist""

echo ""=== Building AutoStrike Agent v${VERSION} ===""

# Create output directory
mkdir -p ""${OUTPUT_DIR}""

# Build Windows x64
echo ""Building Windows x64...""
cargo build --release --target x86_64-pc-windows-gnu
cp target/x86_64-pc-windows-gnu/release/autostrike-agent.exe \
   ""${OUTPUT_DIR}/autostrike-agent-${VERSION}-windows-x64.exe""

# Build Linux x64 (static)
echo ""Building Linux x64...""
cargo build --release --target x86_64-unknown-linux-musl
cp target/x86_64-unknown-linux-musl/release/autostrike-agent \
   ""${OUTPUT_DIR}/autostrike-agent-${VERSION}-linux-x64""

# Build Linux ARM64 (if available)
if rustup target list --installed | grep -q aarch64; then
    echo ""Building Linux ARM64...""
    cargo build --release --target aarch64-unknown-linux-musl
    cp target/aarch64-unknown-linux-musl/release/autostrike-agent \
       ""${OUTPUT_DIR}/autostrike-agent-${VERSION}-linux-arm64""
fi

# Generate checksums
echo ""Generating checksums...""
cd ""${OUTPUT_DIR}""
sha256sum autostrike-agent-* > checksums.sha256

echo ""=== Build complete ===""
echo ""Artifacts:""
ls -lh autostrike-agent-*
cat checksums.sha256
```

**Fichiers:**
- scripts/build-agent.sh

**Definition of Done:**
- [ ] Script build multi-plateforme
- [ ] Build Windows x64
- [ ] Build Linux x64 statique
- [ ] Build Linux ARM64 (optionnel)
- [ ] Generation checksums SHA256
- [ ] Versioning des binaires
- [ ] Output dans dossier dist/
- [ ] Documentation usage",agent;build
"[AG-40] Implementer collection infos systeme",Task,"**Objectif:**
Implementer la collecte complete des informations systeme pour l'enregistrement agent.

**Code Rust exemple:**
```rust
// src/utils/system.rs
use serde::Serialize;

#[derive(Serialize, Debug, Clone)]
pub struct SystemInfo {
    pub hostname: String,
    pub os_type: String,
    pub os_version: String,
    pub architecture: String,
    pub username: String,
    pub domain: Option<String>,
    pub ip_addresses: Vec<String>,
    pub cpu_info: Option<String>,
    pub memory_total: Option<u64>,
}

impl SystemInfo {
    pub fn collect() -> Self {
        Self {
            hostname: Self::get_hostname(),
            os_type: std::env::consts::OS.to_string(),
            os_version: Self::get_os_version(),
            architecture: std::env::consts::ARCH.to_string(),
            username: whoami::username(),
            domain: Self::get_domain(),
            ip_addresses: Self::get_ip_addresses(),
            cpu_info: Self::get_cpu_info(),
            memory_total: Self::get_total_memory(),
        }
    }

    fn get_hostname() -> String {
        hostname::get()
            .map(|h| h.to_string_lossy().to_string())
            .unwrap_or_else(|_| ""unknown"".to_string())
    }

    #[cfg(target_os = ""windows"")]
    fn get_os_version() -> String {
        // Use Windows API or registry
        std::process::Command::new(""cmd"")
            .args(&[""/c"", ""ver""])
            .output()
            .map(|o| String::from_utf8_lossy(&o.stdout).trim().to_string())
            .unwrap_or_else(|_| ""Windows"".to_string())
    }

    #[cfg(target_os = ""linux"")]
    fn get_os_version() -> String {
        std::fs::read_to_string(""/etc/os-release"")
            .ok()
            .and_then(|content| {
                content.lines()
                    .find(|l| l.starts_with(""PRETTY_NAME=""))
                    .map(|l| l.trim_start_matches(""PRETTY_NAME="").trim_matches('""').to_string())
            })
            .unwrap_or_else(|| ""Linux"".to_string())
    }

    #[cfg(target_os = ""macos"")]
    fn get_os_version() -> String {
        std::process::Command::new(""sw_vers"")
            .args(&[""-productVersion""])
            .output()
            .map(|o| format!(""macOS {}"", String::from_utf8_lossy(&o.stdout).trim()))
            .unwrap_or_else(|_| ""macOS"".to_string())
    }

    fn get_domain() -> Option<String> {
        #[cfg(target_os = ""windows"")]
        {
            std::env::var(""USERDOMAIN"").ok()
        }
        #[cfg(not(target_os = ""windows""))]
        {
            None
        }
    }

    fn get_ip_addresses() -> Vec<String> {
        // Simplified - use pnet or socket2 for real implementation
        vec![]
    }

    fn get_cpu_info() -> Option<String> {
        None // Implement with sysinfo crate if needed
    }

    fn get_total_memory() -> Option<u64> {
        None // Implement with sysinfo crate if needed
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_collect_system_info() {
        let info = SystemInfo::collect();
        assert!(!info.hostname.is_empty());
        assert!(!info.os_type.is_empty());
        assert!(!info.username.is_empty());
    }
}
```

**Fichiers:**
- agent/src/utils/system.rs
- agent/src/utils/mod.rs

**Definition of Done:**
- [ ] Struct SystemInfo avec tous les champs
- [ ] Collection hostname (cross-platform)
- [ ] Collection OS version (Windows, Linux, macOS)
- [ ] Collection architecture
- [ ] Collection username
- [ ] Collection domain (Windows)
- [ ] Collection IP addresses
- [ ] Tests unitaires
- [ ] Integration avec BeaconRequest",agent;core
"[FE-01] Initialiser projet React + Vite",Task,"**Objectif:** Initialiser le projet frontend AutoStrike Dashboard avec Vite, React 18 et TypeScript pour une base solide et performante.

**Exemple de code:**
\`\`\`tsx
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@pages': path.resolve(__dirname, './src/pages'),
      '@services': path.resolve(__dirname, './src/services'),
      '@stores': path.resolve(__dirname, './src/stores'),
      '@types': path.resolve(__dirname, './src/types'),
      '@hooks': path.resolve(__dirname, './src/hooks'),
    },
  },
  server: {
    port: 3000,
    proxy: {
      '/api': {
        target: 'http://localhost:8443',
        changeOrigin: true,
      },
    },
  },
})
\`\`\`

**Fichiers a creer:**
- dashboard/vite.config.ts
- dashboard/package.json
- dashboard/src/main.tsx
- dashboard/src/App.tsx
- dashboard/index.html

**Definition of Done:**
- [ ] npm create vite@latest dashboard -- --template react-ts execute
- [ ] Dependances installees (react, react-dom, react-router-dom, zustand, axios)
- [ ] Structure de dossiers creee (components, pages, services, stores, types, hooks)
- [ ] Application demarre sans erreur sur localhost:3000
- [ ] Alias de chemins configures et fonctionnels",dashboard;setup
"[FE-02] Configurer TypeScript strict mode",Task,"**Objectif:** Configurer TypeScript en mode strict avec les path aliases pour un code type-safe et une meilleure DX.

**Exemple de code:**
\`\`\`tsx
// tsconfig.json
{
  ""compilerOptions"": {
    ""target"": ""ES2020"",
    ""useDefineForClassFields"": true,
    ""lib"": [""ES2020"", ""DOM"", ""DOM.Iterable""],
    ""module"": ""ESNext"",
    ""skipLibCheck"": true,
    ""moduleResolution"": ""bundler"",
    ""allowImportingTsExtensions"": true,
    ""resolveJsonModule"": true,
    ""isolatedModules"": true,
    ""noEmit"": true,
    ""jsx"": ""react-jsx"",
    ""strict"": true,
    ""strictNullChecks"": true,
    ""noUnusedLocals"": true,
    ""noUnusedParameters"": true,
    ""noFallthroughCasesInSwitch"": true,
    ""baseUrl"": ""."",
    ""paths"": {
      ""@/*"": [""src/*""],
      ""@components/*"": [""src/components/*""],
      ""@pages/*"": [""src/pages/*""],
      ""@services/*"": [""src/services/*""],
      ""@stores/*"": [""src/stores/*""],
      ""@types/*"": [""src/types/*""],
      ""@hooks/*"": [""src/hooks/*""]
    }
  },
  ""include"": [""src""],
  ""references"": [{ ""path"": ""./tsconfig.node.json"" }]
}
\`\`\`

**Fichiers a creer:**
- dashboard/tsconfig.json
- dashboard/tsconfig.node.json

**Definition of Done:**
- [ ] strict mode active
- [ ] Path aliases configures et resolus par Vite
- [ ] Aucune erreur TypeScript au build
- [ ] Types stricts pour toutes les props de composants",dashboard;setup
"[FE-03] Configurer TailwindCSS",Task,"**Objectif:** Integrer TailwindCSS pour un design system coherent et rapide a implementer.

**Exemple de code:**
\`\`\`tsx
// tailwind.config.js
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
        },
        danger: {
          500: '#ef4444',
          600: '#dc2626',
        },
        success: {
          500: '#22c55e',
          600: '#16a34a',
        },
        warning: {
          500: '#f59e0b',
          600: '#d97706',
        },
        neutral: {
          800: '#1f2937',
          900: '#111827',
        },
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
        mono: ['JetBrains Mono', 'monospace'],
      },
    },
  },
  plugins: [],
}

// src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  .btn-primary {
    @apply bg-primary-600 hover:bg-primary-700 text-white font-medium py-2 px-4 rounded-lg transition-colors;
  }
  .card {
    @apply bg-white rounded-lg shadow-md p-6;
  }
}
\`\`\`

**Fichiers a creer:**
- dashboard/tailwind.config.js
- dashboard/postcss.config.js
- dashboard/src/index.css

**Definition of Done:**
- [ ] TailwindCSS installe et configure
- [ ] PostCSS configure
- [ ] Palette de couleurs AutoStrike definie
- [ ] Classes utilitaires personnalisees creees
- [ ] Styles appliques correctement dans l'application",dashboard;setup
"[FE-04] Configurer React Router v6",Task,"**Objectif:** Mettre en place le routing de l'application avec les routes principales et la protection des routes authentifiees.

**Exemple de code:**
\`\`\`tsx
// src/App.tsx
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom'
import { Layout } from '@components/Layout/Layout'
import { Login } from '@pages/Login'
import { Dashboard } from '@pages/Dashboard'
import { Agents } from '@pages/Agents'
import { Scenarios } from '@pages/Scenarios'
import { Matrix } from '@pages/Matrix'
import { Execution } from '@pages/Execution'
import { Reports } from '@pages/Reports'
import { useAuthStore } from '@stores/authStore'

const ProtectedRoute = ({ children }: { children: React.ReactNode }) => {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated)
  return isAuthenticated ? <>{children}</> : <Navigate to=""/login"" replace />
}

export function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path=""/login"" element={<Login />} />
        <Route
          path=""/*""
          element={
            <ProtectedRoute>
              <Layout>
                <Routes>
                  <Route path=""/"" element={<Dashboard />} />
                  <Route path=""/agents"" element={<Agents />} />
                  <Route path=""/scenarios"" element={<Scenarios />} />
                  <Route path=""/matrix"" element={<Matrix />} />
                  <Route path=""/execution/:id?"" element={<Execution />} />
                  <Route path=""/reports"" element={<Reports />} />
                </Routes>
              </Layout>
            </ProtectedRoute>
          }
        />
      </Routes>
    </BrowserRouter>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/App.tsx (mise a jour)
- dashboard/src/components/ProtectedRoute.tsx

**Definition of Done:**
- [ ] react-router-dom v6 installe
- [ ] Routes definies: /, /login, /agents, /scenarios, /matrix, /execution, /reports
- [ ] ProtectedRoute composant fonctionnel
- [ ] Redirections vers /login si non authentifie
- [ ] Navigation entre pages sans rechargement",dashboard;routing
"[FE-05] Creer composant Layout principal",Task,"**Objectif:** Creer le layout principal de l'application avec Sidebar, Header et zone de contenu responsive.

**Exemple de code:**
\`\`\`tsx
// src/components/Layout/Layout.tsx
import { ReactNode, useState } from 'react'
import { Sidebar } from './Sidebar'
import { Header } from './Header'

interface LayoutProps {
  children: ReactNode
}

export function Layout({ children }: LayoutProps) {
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false)

  return (
    <div className=""min-h-screen bg-neutral-100"">
      <Sidebar
        collapsed={sidebarCollapsed}
        onToggle={() => setSidebarCollapsed(!sidebarCollapsed)}
      />
      <div className={`transition-all duration-300 ${sidebarCollapsed ? 'ml-16' : 'ml-64'}`}>
        <Header onMenuClick={() => setSidebarCollapsed(!sidebarCollapsed)} />
        <main className=""p-6"">
          {children}
        </main>
      </div>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Layout/Layout.tsx
- dashboard/src/components/Layout/index.ts

**Definition of Done:**
- [ ] Layout responsive avec sidebar collapsible
- [ ] Zone de contenu principal avec padding correct
- [ ] Transition fluide lors du collapse/expand
- [ ] Support mobile avec sidebar en overlay
- [ ] Export via index.ts",dashboard;ui
"[FE-06] Creer composant Sidebar",Task,"**Objectif:** Creer la navigation laterale avec les liens vers les differentes sections, icones et indicateur de page active.

**Exemple de code:**
\`\`\`tsx
// src/components/Layout/Sidebar.tsx
import { NavLink } from 'react-router-dom'
import {
  HomeIcon,
  ServerIcon,
  DocumentIcon,
  TableCellsIcon,
  PlayIcon,
  ChartBarIcon,
  ChevronLeftIcon
} from '@heroicons/react/24/outline'

interface SidebarProps {
  collapsed: boolean
  onToggle: () => void
}

const navItems = [
  { to: '/', icon: HomeIcon, label: 'Dashboard' },
  { to: '/agents', icon: ServerIcon, label: 'Agents' },
  { to: '/scenarios', icon: DocumentIcon, label: 'Scenarios' },
  { to: '/matrix', icon: TableCellsIcon, label: 'MITRE Matrix' },
  { to: '/execution', icon: PlayIcon, label: 'Execution' },
  { to: '/reports', icon: ChartBarIcon, label: 'Reports' },
]

export function Sidebar({ collapsed, onToggle }: SidebarProps) {
  return (
    <aside className={`fixed left-0 top-0 h-full bg-neutral-900 text-white transition-all duration-300 ${collapsed ? 'w-16' : 'w-64'}`}>
      <div className=""flex items-center justify-between p-4 border-b border-neutral-700"">
        {!collapsed && <span className=""text-xl font-bold"">AutoStrike</span>}
        <button onClick={onToggle} className=""p-2 hover:bg-neutral-800 rounded"">
          <ChevronLeftIcon className={`w-5 h-5 transition-transform ${collapsed ? 'rotate-180' : ''}`} />
        </button>
      </div>
      <nav className=""mt-4"">
        {navItems.map((item) => (
          <NavLink
            key={item.to}
            to={item.to}
            className={({ isActive }) =>
              `flex items-center gap-3 px-4 py-3 hover:bg-neutral-800 transition-colors ${isActive ? 'bg-primary-600 border-r-4 border-primary-400' : ''}`
            }
          >
            <item.icon className=""w-6 h-6"" />
            {!collapsed && <span>{item.label}</span>}
          </NavLink>
        ))}
      </nav>
    </aside>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Layout/Sidebar.tsx

**Definition of Done:**
- [ ] Navigation avec tous les liens (Dashboard, Agents, Scenarios, Matrix, Execution, Reports)
- [ ] Icones Heroicons pour chaque lien
- [ ] Indicateur visuel de page active (background + bordure)
- [ ] Mode collapsed avec icones seules
- [ ] Logo/titre AutoStrike en haut
- [ ] Animation de transition smooth",dashboard;ui
"[FE-07] Creer composant Header",Task,"**Objectif:** Creer le header avec titre de page dynamique, menu utilisateur et notifications.

**Exemple de code:**
\`\`\`tsx
// src/components/Layout/Header.tsx
import { useState } from 'react'
import { useLocation } from 'react-router-dom'
import {
  Bars3Icon,
  BellIcon,
  UserCircleIcon,
  ArrowRightOnRectangleIcon
} from '@heroicons/react/24/outline'
import { useAuthStore } from '@stores/authStore'

interface HeaderProps {
  onMenuClick: () => void
}

const pageTitles: Record<string, string> = {
  '/': 'Dashboard',
  '/agents': 'Agents',
  '/scenarios': 'Scenarios',
  '/matrix': 'MITRE ATT&CK Matrix',
  '/execution': 'Execution Monitor',
  '/reports': 'Reports',
}

export function Header({ onMenuClick }: HeaderProps) {
  const location = useLocation()
  const { user, logout } = useAuthStore()
  const [showUserMenu, setShowUserMenu] = useState(false)
  const [notifications] = useState(3)

  const pageTitle = pageTitles[location.pathname] || 'AutoStrike'

  return (
    <header className=""sticky top-0 z-10 bg-white shadow-sm px-6 py-4"">
      <div className=""flex items-center justify-between"">
        <div className=""flex items-center gap-4"">
          <button onClick={onMenuClick} className=""lg:hidden p-2 hover:bg-neutral-100 rounded"">
            <Bars3Icon className=""w-6 h-6"" />
          </button>
          <h1 className=""text-2xl font-semibold text-neutral-800"">{pageTitle}</h1>
        </div>
        <div className=""flex items-center gap-4"">
          <button className=""relative p-2 hover:bg-neutral-100 rounded"">
            <BellIcon className=""w-6 h-6 text-neutral-600"" />
            {notifications > 0 && (
              <span className=""absolute -top-1 -right-1 bg-danger-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center"">
                {notifications}
              </span>
            )}
          </button>
          <div className=""relative"">
            <button onClick={() => setShowUserMenu(!showUserMenu)} className=""flex items-center gap-2 p-2 hover:bg-neutral-100 rounded"">
              <UserCircleIcon className=""w-8 h-8 text-neutral-600"" />
              <span className=""hidden md:block text-sm font-medium"">{user?.email}</span>
            </button>
            {showUserMenu && (
              <div className=""absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg border"">
                <button onClick={logout} className=""flex items-center gap-2 w-full px-4 py-2 text-left hover:bg-neutral-100"">
                  <ArrowRightOnRectangleIcon className=""w-5 h-5"" />
                  Logout
                </button>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Layout/Header.tsx

**Definition of Done:**
- [ ] Titre de page dynamique selon la route
- [ ] Bouton menu hamburger pour mobile
- [ ] Icone notifications avec badge compteur
- [ ] Menu utilisateur dropdown avec logout
- [ ] Affichage email utilisateur connecte
- [ ] Style sticky en haut de page",dashboard;ui
"[FE-08] Creer composants UI de base",Task,"**Objectif:** Creer les composants UI reutilisables: Button, Card, Modal, Input, Select, Loading.

**Exemple de code:**
\`\`\`tsx
// src/components/common/Button.tsx
import { ButtonHTMLAttributes, ReactNode } from 'react'

interface ButtonProps extends ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'secondary' | 'danger' | 'ghost'
  size?: 'sm' | 'md' | 'lg'
  loading?: boolean
  children: ReactNode
}

export function Button({
  variant = 'primary',
  size = 'md',
  loading = false,
  children,
  className = '',
  disabled,
  ...props
}: ButtonProps) {
  const variants = {
    primary: 'bg-primary-600 hover:bg-primary-700 text-white',
    secondary: 'bg-neutral-200 hover:bg-neutral-300 text-neutral-800',
    danger: 'bg-danger-500 hover:bg-danger-600 text-white',
    ghost: 'bg-transparent hover:bg-neutral-100 text-neutral-600',
  }

  const sizes = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg',
  }

  return (
    <button
      className={`inline-flex items-center justify-center gap-2 font-medium rounded-lg transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${variants[variant]} ${sizes[size]} ${className}`}
      disabled={disabled || loading}
      {...props}
    >
      {loading && <span className=""w-4 h-4 border-2 border-current border-t-transparent rounded-full animate-spin"" />}
      {children}
    </button>
  )
}

// src/components/common/Card.tsx
interface CardProps {
  children: ReactNode
  title?: string
  className?: string
}

export function Card({ children, title, className = '' }: CardProps) {
  return (
    <div className={`bg-white rounded-lg shadow-md ${className}`}>
      {title && (
        <div className=""px-6 py-4 border-b border-neutral-200"">
          <h3 className=""text-lg font-semibold text-neutral-800"">{title}</h3>
        </div>
      )}
      <div className=""p-6"">{children}</div>
    </div>
  )
}

// src/components/common/Modal.tsx
interface ModalProps {
  isOpen: boolean
  onClose: () => void
  title: string
  children: ReactNode
}

export function Modal({ isOpen, onClose, title, children }: ModalProps) {
  if (!isOpen) return null

  return (
    <div className=""fixed inset-0 z-50 flex items-center justify-center"">
      <div className=""fixed inset-0 bg-black/50"" onClick={onClose} />
      <div className=""relative bg-white rounded-lg shadow-xl max-w-lg w-full mx-4"">
        <div className=""flex items-center justify-between px-6 py-4 border-b"">
          <h2 className=""text-xl font-semibold"">{title}</h2>
          <button onClick={onClose} className=""text-neutral-400 hover:text-neutral-600"">×</button>
        </div>
        <div className=""p-6"">{children}</div>
      </div>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/common/Button.tsx
- dashboard/src/components/common/Card.tsx
- dashboard/src/components/common/Modal.tsx
- dashboard/src/components/common/Input.tsx
- dashboard/src/components/common/Select.tsx
- dashboard/src/components/common/Loading.tsx
- dashboard/src/components/common/index.ts

**Definition of Done:**
- [ ] Button avec variants (primary, secondary, danger, ghost) et sizes (sm, md, lg)
- [ ] Card avec titre optionnel
- [ ] Modal avec backdrop et fermeture au clic exterieur
- [ ] Input avec label, error state, placeholder
- [ ] Select avec options typees
- [ ] Loading spinner anime
- [ ] Tous composants exportes via index.ts",dashboard;ui
"[FE-09] Configurer client HTTP Axios",Task,"**Objectif:** Configurer Axios avec base URL, interceptors pour auth et gestion des erreurs globale.

**Exemple de code:**
\`\`\`tsx
// src/services/api.ts
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios'
import { useAuthStore } from '@stores/authStore'

const API_BASE_URL = import.meta.env.VITE_API_URL || 'http://localhost:8443/api/v1'

export const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
})

// Request interceptor - ajout du token
api.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const token = useAuthStore.getState().token
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Response interceptor - gestion erreurs
api.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    if (error.response?.status === 401) {
      // Token expire - deconnexion
      useAuthStore.getState().logout()
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

// Types de reponse API
export interface ApiResponse<T> {
  data: T
  message?: string
}

export interface ApiError {
  message: string
  code: string
  details?: Record<string, string>
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/services/api.ts
- dashboard/.env.example

**Definition of Done:**
- [ ] Axios installe et configure
- [ ] Base URL configurable via variable d'environnement
- [ ] Interceptor request pour ajouter le token JWT
- [ ] Interceptor response pour gerer les erreurs 401
- [ ] Types TypeScript pour les reponses API
- [ ] Fichier .env.example avec les variables necessaires",dashboard;api
"[FE-10] Creer service API agents",Task,"**Objectif:** Creer le service pour interagir avec l'API des agents (CRUD).

**Exemple de code:**
\`\`\`tsx
// src/services/agentService.ts
import { api, ApiResponse } from './api'
import type { Agent } from '@types/agent'

export interface AgentFilters {
  status?: 'online' | 'offline' | 'busy'
  platform?: 'windows' | 'linux' | 'darwin'
}

export const agentService = {
  async getAgents(filters?: AgentFilters): Promise<Agent[]> {
    const params = new URLSearchParams()
    if (filters?.status) params.append('status', filters.status)
    if (filters?.platform) params.append('platform', filters.platform)

    const response = await api.get<ApiResponse<Agent[]>>('/agents', { params })
    return response.data.data
  },

  async getAgent(paw: string): Promise<Agent> {
    const response = await api.get<ApiResponse<Agent>>(`/agents/${paw}`)
    return response.data.data
  },

  async deleteAgent(paw: string): Promise<void> {
    await api.delete(`/agents/${paw}`)
  },

  async getAgentTasks(paw: string): Promise<AgentTask[]> {
    const response = await api.get<ApiResponse<AgentTask[]>>(`/agents/${paw}/tasks`)
    return response.data.data
  },

  async trustAgent(paw: string): Promise<Agent> {
    const response = await api.post<ApiResponse<Agent>>(`/agents/${paw}/trust`)
    return response.data.data
  },
}

// src/types/agent.ts
export interface Agent {
  paw: string
  hostname: string
  platform: 'windows' | 'linux' | 'darwin'
  username: string
  executors: string[]
  status: 'online' | 'offline' | 'busy' | 'untrusted'
  lastSeen: string
  ipAddress: string
  osVersion: string
  metadata?: Record<string, string>
}

export interface AgentTask {
  id: string
  techniqueId: string
  status: 'pending' | 'running' | 'completed' | 'failed'
  output?: string
  startedAt?: string
  completedAt?: string
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/services/agentService.ts
- dashboard/src/types/agent.ts

**Definition of Done:**
- [ ] getAgents() avec filtres optionnels (status, platform)
- [ ] getAgent(paw) pour un agent specifique
- [ ] deleteAgent(paw) pour supprimer un agent
- [ ] getAgentTasks(paw) pour les taches d'un agent
- [ ] trustAgent(paw) pour approuver un agent
- [ ] Types Agent et AgentTask definis",dashboard;api
"[FE-11] Creer service API techniques",Task,"**Objectif:** Creer le service pour recuperer les techniques MITRE ATT&CK depuis l'API.

**Exemple de code:**
\`\`\`tsx
// src/services/techniqueService.ts
import { api, ApiResponse } from './api'
import type { Technique, TacticType } from '@types/technique'

export const techniqueService = {
  async getTechniques(): Promise<Technique[]> {
    const response = await api.get<ApiResponse<Technique[]>>('/techniques')
    return response.data.data
  },

  async getTechnique(id: string): Promise<Technique> {
    const response = await api.get<ApiResponse<Technique>>(`/techniques/${id}`)
    return response.data.data
  },

  async getByTactic(tactic: TacticType): Promise<Technique[]> {
    const response = await api.get<ApiResponse<Technique[]>>(`/techniques/tactic/${tactic}`)
    return response.data.data
  },

  async searchTechniques(query: string): Promise<Technique[]> {
    const response = await api.get<ApiResponse<Technique[]>>('/techniques/search', {
      params: { q: query }
    })
    return response.data.data
  },
}

// src/types/technique.ts
export type TacticType =
  | 'reconnaissance'
  | 'resource-development'
  | 'initial-access'
  | 'execution'
  | 'persistence'
  | 'privilege-escalation'
  | 'defense-evasion'
  | 'credential-access'
  | 'discovery'
  | 'lateral-movement'
  | 'collection'
  | 'command-and-control'
  | 'exfiltration'
  | 'impact'

export interface Technique {
  id: string
  name: string
  tactic: TacticType
  description: string
  platforms: string[]
  isSafe: boolean
  detection?: Detection[]
  references?: string[]
}

export interface Detection {
  source: string
  indicator: string
}

export const TACTICS_ORDER: TacticType[] = [
  'reconnaissance',
  'resource-development',
  'initial-access',
  'execution',
  'persistence',
  'privilege-escalation',
  'defense-evasion',
  'credential-access',
  'discovery',
  'lateral-movement',
  'collection',
  'command-and-control',
  'exfiltration',
  'impact',
]
\`\`\`

**Fichiers a creer:**
- dashboard/src/services/techniqueService.ts
- dashboard/src/types/technique.ts

**Definition of Done:**
- [ ] getTechniques() retourne toutes les techniques
- [ ] getTechnique(id) retourne une technique par ID
- [ ] getByTactic(tactic) filtre par tactique
- [ ] searchTechniques(query) recherche textuelle
- [ ] Types Technique et TacticType definis
- [ ] Liste ordonnee des tactiques MITRE",dashboard;api
"[FE-12] Creer service API scenarios",Task,"**Objectif:** Creer le service CRUD complet pour les scenarios d'attaque.

**Exemple de code:**
\`\`\`tsx
// src/services/scenarioService.ts
import { api, ApiResponse } from './api'
import type { Scenario, CreateScenarioDto, UpdateScenarioDto } from '@types/scenario'

export const scenarioService = {
  async getScenarios(): Promise<Scenario[]> {
    const response = await api.get<ApiResponse<Scenario[]>>('/scenarios')
    return response.data.data
  },

  async getScenario(id: string): Promise<Scenario> {
    const response = await api.get<ApiResponse<Scenario>>(`/scenarios/${id}`)
    return response.data.data
  },

  async createScenario(data: CreateScenarioDto): Promise<Scenario> {
    const response = await api.post<ApiResponse<Scenario>>('/scenarios', data)
    return response.data.data
  },

  async updateScenario(id: string, data: UpdateScenarioDto): Promise<Scenario> {
    const response = await api.put<ApiResponse<Scenario>>(`/scenarios/${id}`, data)
    return response.data.data
  },

  async deleteScenario(id: string): Promise<void> {
    await api.delete(`/scenarios/${id}`)
  },

  async duplicateScenario(id: string): Promise<Scenario> {
    const response = await api.post<ApiResponse<Scenario>>(`/scenarios/${id}/duplicate`)
    return response.data.data
  },
}

// src/types/scenario.ts
export interface Scenario {
  id: string
  name: string
  description: string
  phases: Phase[]
  createdAt: string
  updatedAt: string
}

export interface Phase {
  name: string
  description: string
  techniques: string[]
  order: number
}

export interface CreateScenarioDto {
  name: string
  description: string
  phases: Omit<Phase, 'order'>[]
}

export interface UpdateScenarioDto {
  name?: string
  description?: string
  phases?: Omit<Phase, 'order'>[]
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/services/scenarioService.ts
- dashboard/src/types/scenario.ts

**Definition of Done:**
- [ ] getScenarios() liste tous les scenarios
- [ ] getScenario(id) retourne un scenario
- [ ] createScenario(data) cree un nouveau scenario
- [ ] updateScenario(id, data) met a jour un scenario
- [ ] deleteScenario(id) supprime un scenario
- [ ] duplicateScenario(id) duplique un scenario
- [ ] Types Scenario, Phase et DTOs definis",dashboard;api
"[FE-13] Creer service API executions",Task,"**Objectif:** Creer le service pour gerer les executions de scenarios.

**Exemple de code:**
\`\`\`tsx
// src/services/executionService.ts
import { api, ApiResponse } from './api'
import type { Execution, ExecutionResult, StartExecutionDto } from '@types/execution'

export const executionService = {
  async getExecutions(): Promise<Execution[]> {
    const response = await api.get<ApiResponse<Execution[]>>('/executions')
    return response.data.data
  },

  async getExecution(id: string): Promise<Execution> {
    const response = await api.get<ApiResponse<Execution>>(`/executions/${id}`)
    return response.data.data
  },

  async startExecution(scenarioId: string, data: StartExecutionDto): Promise<Execution> {
    const response = await api.post<ApiResponse<Execution>>(
      `/scenarios/${scenarioId}/execute`,
      data
    )
    return response.data.data
  },

  async stopExecution(id: string): Promise<Execution> {
    const response = await api.post<ApiResponse<Execution>>(`/executions/${id}/stop`)
    return response.data.data
  },

  async getExecutionResults(id: string): Promise<ExecutionResult[]> {
    const response = await api.get<ApiResponse<ExecutionResult[]>>(`/executions/${id}/results`)
    return response.data.data
  },
}

// src/types/execution.ts
export type ExecutionStatus = 'pending' | 'running' | 'completed' | 'failed' | 'cancelled'

export interface Execution {
  id: string
  scenarioId: string
  scenarioName: string
  status: ExecutionStatus
  startedAt: string
  completedAt?: string
  progress: {
    current: number
    total: number
  }
  agents: string[]
  safeMode: boolean
}

export interface ExecutionResult {
  id: string
  executionId: string
  agentPaw: string
  techniqueId: string
  techniqueName: string
  status: 'success' | 'blocked' | 'detected' | 'failed'
  output?: string
  detectedBy?: string
  executedAt: string
  duration: number
}

export interface StartExecutionDto {
  agentPaws: string[]
  safeMode?: boolean
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/services/executionService.ts
- dashboard/src/types/execution.ts

**Definition of Done:**
- [ ] getExecutions() liste les executions
- [ ] getExecution(id) retourne une execution
- [ ] startExecution(scenarioId, data) demarre une execution
- [ ] stopExecution(id) arrete une execution
- [ ] getExecutionResults(id) retourne les resultats
- [ ] Types Execution, ExecutionResult et DTOs definis",dashboard;api
"[FE-14] Creer service API auth",Task,"**Objectif:** Creer le service d'authentification avec login, logout et refresh token.

**Exemple de code:**
\`\`\`tsx
// src/services/authService.ts
import { api, ApiResponse } from './api'
import type { User, LoginCredentials, AuthResponse } from '@types/auth'

export const authService = {
  async login(credentials: LoginCredentials): Promise<AuthResponse> {
    const response = await api.post<ApiResponse<AuthResponse>>('/auth/login', credentials)
    return response.data.data
  },

  async logout(): Promise<void> {
    await api.post('/auth/logout')
  },

  async refreshToken(): Promise<AuthResponse> {
    const response = await api.post<ApiResponse<AuthResponse>>('/auth/refresh')
    return response.data.data
  },

  async getCurrentUser(): Promise<User> {
    const response = await api.get<ApiResponse<User>>('/auth/me')
    return response.data.data
  },

  async changePassword(currentPassword: string, newPassword: string): Promise<void> {
    await api.post('/auth/change-password', { currentPassword, newPassword })
  },
}

// src/types/auth.ts
export interface User {
  id: string
  email: string
  name: string
  role: 'admin' | 'operator' | 'viewer'
  createdAt: string
  lastLogin?: string
}

export interface LoginCredentials {
  email: string
  password: string
}

export interface AuthResponse {
  user: User
  token: string
  expiresAt: string
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/services/authService.ts
- dashboard/src/types/auth.ts

**Definition of Done:**
- [ ] login(credentials) authentifie et retourne token + user
- [ ] logout() deconnecte l'utilisateur
- [ ] refreshToken() rafraichit le token JWT
- [ ] getCurrentUser() retourne l'utilisateur courant
- [ ] changePassword() permet de changer le mot de passe
- [ ] Types User, LoginCredentials et AuthResponse definis",dashboard;api
"[FE-15] Configurer Zustand state management",Task,"**Objectif:** Configurer Zustand comme state manager global avec persistance et devtools.

**Exemple de code:**
\`\`\`tsx
// src/stores/index.ts
export { useAgentStore } from './agentStore'
export { useScenarioStore } from './scenarioStore'
export { useTechniqueStore } from './techniqueStore'
export { useResultStore } from './resultStore'
export { useAuthStore } from './authStore'

// Configuration commune pour les stores
import { create, StateCreator } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

// Helper pour creer un store avec devtools
export function createStore<T>(
  name: string,
  storeCreator: StateCreator<T>
) {
  return create<T>()(
    devtools(storeCreator, { name })
  )
}

// Helper pour creer un store avec persistance
export function createPersistentStore<T>(
  name: string,
  storeCreator: StateCreator<T>
) {
  return create<T>()(
    devtools(
      persist(storeCreator, { name }),
      { name }
    )
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/stores/index.ts

**Definition of Done:**
- [ ] Zustand installe
- [ ] Middleware devtools configure pour debug
- [ ] Helper createStore pour stores simples
- [ ] Helper createPersistentStore pour stores persistes
- [ ] Export centralise de tous les stores",dashboard;state
"[FE-16] Creer agentStore Zustand",Task,"**Objectif:** Creer le store Zustand pour gerer l'etat des agents avec actions async.

**Exemple de code:**
\`\`\`tsx
// src/stores/agentStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { agentService, AgentFilters } from '@services/agentService'
import type { Agent } from '@types/agent'

interface AgentState {
  agents: Agent[]
  selectedAgent: Agent | null
  loading: boolean
  error: string | null
  filters: AgentFilters
}

interface AgentActions {
  fetchAgents: (filters?: AgentFilters) => Promise<void>
  fetchAgent: (paw: string) => Promise<void>
  selectAgent: (agent: Agent | null) => void
  deleteAgent: (paw: string) => Promise<void>
  trustAgent: (paw: string) => Promise<void>
  setFilters: (filters: AgentFilters) => void
  clearError: () => void
}

export const useAgentStore = create<AgentState & AgentActions>()(
  devtools(
    (set, get) => ({
      // State
      agents: [],
      selectedAgent: null,
      loading: false,
      error: null,
      filters: {},

      // Actions
      fetchAgents: async (filters) => {
        set({ loading: true, error: null })
        try {
          const appliedFilters = filters || get().filters
          const agents = await agentService.getAgents(appliedFilters)
          set({ agents, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      fetchAgent: async (paw) => {
        set({ loading: true, error: null })
        try {
          const agent = await agentService.getAgent(paw)
          set({ selectedAgent: agent, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      selectAgent: (agent) => set({ selectedAgent: agent }),

      deleteAgent: async (paw) => {
        try {
          await agentService.deleteAgent(paw)
          set((state) => ({
            agents: state.agents.filter((a) => a.paw !== paw),
            selectedAgent: state.selectedAgent?.paw === paw ? null : state.selectedAgent,
          }))
        } catch (error) {
          set({ error: (error as Error).message })
        }
      },

      trustAgent: async (paw) => {
        try {
          const updatedAgent = await agentService.trustAgent(paw)
          set((state) => ({
            agents: state.agents.map((a) => (a.paw === paw ? updatedAgent : a)),
            selectedAgent: state.selectedAgent?.paw === paw ? updatedAgent : state.selectedAgent,
          }))
        } catch (error) {
          set({ error: (error as Error).message })
        }
      },

      setFilters: (filters) => set({ filters }),
      clearError: () => set({ error: null }),
    }),
    { name: 'agent-store' }
  )
)
\`\`\`

**Fichiers a creer:**
- dashboard/src/stores/agentStore.ts

**Definition of Done:**
- [ ] State: agents[], selectedAgent, loading, error, filters
- [ ] fetchAgents() avec filtres optionnels
- [ ] fetchAgent(paw) pour un agent specifique
- [ ] selectAgent() pour selection UI
- [ ] deleteAgent() avec mise a jour optimiste
- [ ] trustAgent() pour approuver un agent
- [ ] clearError() pour reset des erreurs",dashboard;state
"[FE-17] Creer scenarioStore Zustand",Task,"**Objectif:** Creer le store Zustand pour gerer l'etat des scenarios avec CRUD complet.

**Exemple de code:**
\`\`\`tsx
// src/stores/scenarioStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { scenarioService } from '@services/scenarioService'
import type { Scenario, CreateScenarioDto, UpdateScenarioDto } from '@types/scenario'

interface ScenarioState {
  scenarios: Scenario[]
  currentScenario: Scenario | null
  loading: boolean
  error: string | null
}

interface ScenarioActions {
  fetchScenarios: () => Promise<void>
  fetchScenario: (id: string) => Promise<void>
  createScenario: (data: CreateScenarioDto) => Promise<Scenario>
  updateScenario: (id: string, data: UpdateScenarioDto) => Promise<void>
  deleteScenario: (id: string) => Promise<void>
  duplicateScenario: (id: string) => Promise<Scenario>
  setCurrentScenario: (scenario: Scenario | null) => void
  clearError: () => void
}

export const useScenarioStore = create<ScenarioState & ScenarioActions>()(
  devtools(
    (set, get) => ({
      // State
      scenarios: [],
      currentScenario: null,
      loading: false,
      error: null,

      // Actions
      fetchScenarios: async () => {
        set({ loading: true, error: null })
        try {
          const scenarios = await scenarioService.getScenarios()
          set({ scenarios, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      fetchScenario: async (id) => {
        set({ loading: true, error: null })
        try {
          const scenario = await scenarioService.getScenario(id)
          set({ currentScenario: scenario, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      createScenario: async (data) => {
        set({ loading: true, error: null })
        try {
          const newScenario = await scenarioService.createScenario(data)
          set((state) => ({
            scenarios: [...state.scenarios, newScenario],
            loading: false,
          }))
          return newScenario
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
          throw error
        }
      },

      updateScenario: async (id, data) => {
        set({ loading: true, error: null })
        try {
          const updated = await scenarioService.updateScenario(id, data)
          set((state) => ({
            scenarios: state.scenarios.map((s) => (s.id === id ? updated : s)),
            currentScenario: state.currentScenario?.id === id ? updated : state.currentScenario,
            loading: false,
          }))
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      deleteScenario: async (id) => {
        try {
          await scenarioService.deleteScenario(id)
          set((state) => ({
            scenarios: state.scenarios.filter((s) => s.id !== id),
            currentScenario: state.currentScenario?.id === id ? null : state.currentScenario,
          }))
        } catch (error) {
          set({ error: (error as Error).message })
        }
      },

      duplicateScenario: async (id) => {
        const duplicated = await scenarioService.duplicateScenario(id)
        set((state) => ({ scenarios: [...state.scenarios, duplicated] }))
        return duplicated
      },

      setCurrentScenario: (scenario) => set({ currentScenario: scenario }),
      clearError: () => set({ error: null }),
    }),
    { name: 'scenario-store' }
  )
)
\`\`\`

**Fichiers a creer:**
- dashboard/src/stores/scenarioStore.ts

**Definition of Done:**
- [ ] State: scenarios[], currentScenario, loading, error
- [ ] fetchScenarios() liste tous les scenarios
- [ ] fetchScenario(id) charge un scenario
- [ ] createScenario(data) cree et ajoute au state
- [ ] updateScenario(id, data) met a jour
- [ ] deleteScenario(id) supprime
- [ ] duplicateScenario(id) duplique un scenario",dashboard;state
"[FE-18] Creer techniqueStore Zustand",Task,"**Objectif:** Creer le store pour les techniques MITRE avec filtrage par tactique.

**Exemple de code:**
\`\`\`tsx
// src/stores/techniqueStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { techniqueService } from '@services/techniqueService'
import type { Technique, TacticType, TACTICS_ORDER } from '@types/technique'

interface TechniqueState {
  techniques: Technique[]
  byTactic: Record<TacticType, Technique[]>
  loading: boolean
  error: string | null
  searchQuery: string
  selectedTechnique: Technique | null
}

interface TechniqueActions {
  fetchTechniques: () => Promise<void>
  getTechniqueById: (id: string) => Technique | undefined
  searchTechniques: (query: string) => Promise<void>
  setSearchQuery: (query: string) => void
  selectTechnique: (technique: Technique | null) => void
  clearError: () => void
}

export const useTechniqueStore = create<TechniqueState & TechniqueActions>()(
  devtools(
    (set, get) => ({
      // State
      techniques: [],
      byTactic: {} as Record<TacticType, Technique[]>,
      loading: false,
      error: null,
      searchQuery: '',
      selectedTechnique: null,

      // Actions
      fetchTechniques: async () => {
        set({ loading: true, error: null })
        try {
          const techniques = await techniqueService.getTechniques()

          // Grouper par tactique
          const byTactic = techniques.reduce((acc, tech) => {
            if (!acc[tech.tactic]) {
              acc[tech.tactic] = []
            }
            acc[tech.tactic].push(tech)
            return acc
          }, {} as Record<TacticType, Technique[]>)

          set({ techniques, byTactic, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      getTechniqueById: (id) => {
        return get().techniques.find((t) => t.id === id)
      },

      searchTechniques: async (query) => {
        set({ loading: true, searchQuery: query })
        try {
          const techniques = await techniqueService.searchTechniques(query)
          set({ techniques, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      setSearchQuery: (query) => set({ searchQuery: query }),
      selectTechnique: (technique) => set({ selectedTechnique: technique }),
      clearError: () => set({ error: null }),
    }),
    { name: 'technique-store' }
  )
)
\`\`\`

**Fichiers a creer:**
- dashboard/src/stores/techniqueStore.ts

**Definition of Done:**
- [ ] State: techniques[], byTactic{}, loading, error, searchQuery
- [ ] fetchTechniques() charge et groupe par tactique
- [ ] getTechniqueById(id) getter synchrone
- [ ] searchTechniques(query) recherche async
- [ ] Groupement automatique par tactique
- [ ] selectTechnique() pour afficher les details",dashboard;state
"[FE-19] Creer resultStore Zustand",Task,"**Objectif:** Creer le store pour les resultats d'execution avec statistiques.

**Exemple de code:**
\`\`\`tsx
// src/stores/resultStore.ts
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { executionService } from '@services/executionService'
import type { Execution, ExecutionResult } from '@types/execution'

interface ResultStats {
  total: number
  success: number
  blocked: number
  detected: number
  failed: number
  securityScore: number
}

interface ResultState {
  executions: Execution[]
  currentExecution: Execution | null
  results: ExecutionResult[]
  resultsByExecution: Record<string, ExecutionResult[]>
  stats: ResultStats
  loading: boolean
  error: string | null
}

interface ResultActions {
  fetchExecutions: () => Promise<void>
  fetchExecution: (id: string) => Promise<void>
  fetchResults: (executionId: string) => Promise<void>
  addResult: (result: ExecutionResult) => void
  calculateStats: () => void
  clearError: () => void
}

const calculateSecurityScore = (results: ExecutionResult[]): number => {
  if (results.length === 0) return 0
  const blocked = results.filter((r) => r.status === 'blocked').length
  const detected = results.filter((r) => r.status === 'detected').length
  return Math.round(((blocked * 100 + detected * 50) / (results.length * 100)) * 100)
}

export const useResultStore = create<ResultState & ResultActions>()(
  devtools(
    (set, get) => ({
      // State
      executions: [],
      currentExecution: null,
      results: [],
      resultsByExecution: {},
      stats: { total: 0, success: 0, blocked: 0, detected: 0, failed: 0, securityScore: 0 },
      loading: false,
      error: null,

      // Actions
      fetchExecutions: async () => {
        set({ loading: true, error: null })
        try {
          const executions = await executionService.getExecutions()
          set({ executions, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      fetchExecution: async (id) => {
        set({ loading: true, error: null })
        try {
          const execution = await executionService.getExecution(id)
          set({ currentExecution: execution, loading: false })
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      fetchResults: async (executionId) => {
        set({ loading: true, error: null })
        try {
          const results = await executionService.getExecutionResults(executionId)
          set((state) => ({
            results,
            resultsByExecution: {
              ...state.resultsByExecution,
              [executionId]: results,
            },
            loading: false,
          }))
          get().calculateStats()
        } catch (error) {
          set({ error: (error as Error).message, loading: false })
        }
      },

      addResult: (result) => {
        set((state) => ({
          results: [...state.results, result],
          resultsByExecution: {
            ...state.resultsByExecution,
            [result.executionId]: [
              ...(state.resultsByExecution[result.executionId] || []),
              result,
            ],
          },
        }))
        get().calculateStats()
      },

      calculateStats: () => {
        const results = get().results
        set({
          stats: {
            total: results.length,
            success: results.filter((r) => r.status === 'success').length,
            blocked: results.filter((r) => r.status === 'blocked').length,
            detected: results.filter((r) => r.status === 'detected').length,
            failed: results.filter((r) => r.status === 'failed').length,
            securityScore: calculateSecurityScore(results),
          },
        })
      },

      clearError: () => set({ error: null }),
    }),
    { name: 'result-store' }
  )
)
\`\`\`

**Fichiers a creer:**
- dashboard/src/stores/resultStore.ts

**Definition of Done:**
- [ ] State: executions[], currentExecution, results[], resultsByExecution{}, stats
- [ ] fetchExecutions() liste les executions
- [ ] fetchResults(executionId) charge les resultats
- [ ] addResult() pour ajout temps reel (WebSocket)
- [ ] calculateStats() calcule les statistiques et score securite
- [ ] Formule score: (blocked*100 + detected*50) / (total*100)",dashboard;state
"[FE-20] Creer authStore Zustand",Task,"**Objectif:** Creer le store d'authentification avec persistance du token.

**Exemple de code:**
\`\`\`tsx
// src/stores/authStore.ts
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { authService } from '@services/authService'
import type { User, LoginCredentials } from '@types/auth'

interface AuthState {
  user: User | null
  token: string | null
  isAuthenticated: boolean
  loading: boolean
  error: string | null
}

interface AuthActions {
  login: (credentials: LoginCredentials) => Promise<void>
  logout: () => void
  refreshToken: () => Promise<void>
  checkAuth: () => Promise<void>
  clearError: () => void
}

export const useAuthStore = create<AuthState & AuthActions>()(
  devtools(
    persist(
      (set, get) => ({
        // State
        user: null,
        token: null,
        isAuthenticated: false,
        loading: false,
        error: null,

        // Actions
        login: async (credentials) => {
          set({ loading: true, error: null })
          try {
            const response = await authService.login(credentials)
            set({
              user: response.user,
              token: response.token,
              isAuthenticated: true,
              loading: false,
            })
          } catch (error) {
            set({
              error: (error as Error).message || 'Login failed',
              loading: false,
            })
            throw error
          }
        },

        logout: () => {
          authService.logout().catch(() => {})
          set({
            user: null,
            token: null,
            isAuthenticated: false,
            error: null,
          })
        },

        refreshToken: async () => {
          try {
            const response = await authService.refreshToken()
            set({
              token: response.token,
              user: response.user,
            })
          } catch (error) {
            get().logout()
          }
        },

        checkAuth: async () => {
          const token = get().token
          if (!token) {
            set({ isAuthenticated: false })
            return
          }

          set({ loading: true })
          try {
            const user = await authService.getCurrentUser()
            set({ user, isAuthenticated: true, loading: false })
          } catch (error) {
            set({
              user: null,
              token: null,
              isAuthenticated: false,
              loading: false,
            })
          }
        },

        clearError: () => set({ error: null }),
      }),
      {
        name: 'auth-storage',
        partialize: (state) => ({
          token: state.token,
          user: state.user,
        }),
      }
    ),
    { name: 'auth-store' }
  )
)
\`\`\`

**Fichiers a creer:**
- dashboard/src/stores/authStore.ts

**Definition of Done:**
- [ ] State: user, token, isAuthenticated, loading, error
- [ ] login(credentials) authentifie et stocke le token
- [ ] logout() deconnecte et clear le state
- [ ] refreshToken() rafraichit le token
- [ ] checkAuth() verifie la validite du token au demarrage
- [ ] Persistance du token et user dans localStorage
- [ ] partialize pour ne persister que token et user",dashboard;state
"[FE-21] Creer page Login",Task,"**Objectif:** Creer la page de connexion avec formulaire, validation et gestion des erreurs.

**Exemple de code:**
\`\`\`tsx
// src/pages/Login.tsx
import { useState, FormEvent } from 'react'
import { useNavigate } from 'react-router-dom'
import { useAuthStore } from '@stores/authStore'
import { Button, Input, Card } from '@components/common'

export function Login() {
  const navigate = useNavigate()
  const { login, loading, error, clearError } = useAuthStore()
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [validationError, setValidationError] = useState('')

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault()
    setValidationError('')
    clearError()

    if (!email || !password) {
      setValidationError('Email and password are required')
      return
    }

    try {
      await login({ email, password })
      navigate('/')
    } catch (err) {
      // Error is handled by the store
    }
  }

  return (
    <div className=""min-h-screen bg-neutral-900 flex items-center justify-center p-4"">
      <div className=""w-full max-w-md"">
        <div className=""text-center mb-8"">
          <h1 className=""text-4xl font-bold text-white mb-2"">AutoStrike</h1>
          <p className=""text-neutral-400"">Breach and Attack Simulation Platform</p>
        </div>

        <Card>
          <form onSubmit={handleSubmit} className=""space-y-6"">
            <div>
              <label className=""block text-sm font-medium text-neutral-700 mb-2"">
                Email
              </label>
              <Input
                type=""email""
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder=""admin@autostrike.io""
                autoComplete=""email""
              />
            </div>

            <div>
              <label className=""block text-sm font-medium text-neutral-700 mb-2"">
                Password
              </label>
              <Input
                type=""password""
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder=""Enter your password""
                autoComplete=""current-password""
              />
            </div>

            {(error || validationError) && (
              <div className=""bg-danger-50 border border-danger-200 text-danger-600 px-4 py-3 rounded"">
                {validationError || error}
              </div>
            )}

            <Button type=""submit"" className=""w-full"" loading={loading}>
              Sign In
            </Button>
          </form>
        </Card>

        <p className=""text-center text-neutral-500 mt-6 text-sm"">
          AutoStrike v1.0 - MITRE ATT&CK Validation
        </p>
      </div>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/pages/Login.tsx

**Definition of Done:**
- [ ] Formulaire email/password avec validation
- [ ] Affichage erreurs de validation et API
- [ ] Bouton avec etat loading
- [ ] Redirection vers Dashboard apres login
- [ ] Design sombre avec branding AutoStrike
- [ ] Accessibilite (labels, autocomplete)",dashboard;page
"[FE-22] Creer page Dashboard (home)",Task,"**Objectif:** Creer la page d'accueil avec overview des stats, agents en ligne, dernieres executions.

**Exemple de code:**
\`\`\`tsx
// src/pages/Dashboard.tsx
import { useEffect } from 'react'
import { Link } from 'react-router-dom'
import { Card } from '@components/common'
import { useAgentStore } from '@stores/agentStore'
import { useResultStore } from '@stores/resultStore'
import {
  ServerIcon,
  ShieldCheckIcon,
  PlayIcon,
  ExclamationTriangleIcon
} from '@heroicons/react/24/outline'

export function Dashboard() {
  const { agents, fetchAgents } = useAgentStore()
  const { executions, stats, fetchExecutions } = useResultStore()

  useEffect(() => {
    fetchAgents()
    fetchExecutions()
  }, [fetchAgents, fetchExecutions])

  const onlineAgents = agents.filter((a) => a.status === 'online').length
  const recentExecutions = executions.slice(0, 5)

  const statCards = [
    {
      title: 'Agents Online',
      value: `${onlineAgents}/${agents.length}`,
      icon: ServerIcon,
      color: 'bg-primary-500',
    },
    {
      title: 'Security Score',
      value: `${stats.securityScore}%`,
      icon: ShieldCheckIcon,
      color: stats.securityScore >= 70 ? 'bg-success-500' : 'bg-warning-500',
    },
    {
      title: 'Techniques Blocked',
      value: stats.blocked.toString(),
      icon: ShieldCheckIcon,
      color: 'bg-success-500',
    },
    {
      title: 'Techniques Detected',
      value: stats.detected.toString(),
      icon: ExclamationTriangleIcon,
      color: 'bg-warning-500',
    },
  ]

  return (
    <div className=""space-y-6"">
      {/* Stats Cards */}
      <div className=""grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4"">
        {statCards.map((stat) => (
          <Card key={stat.title} className=""flex items-center gap-4"">
            <div className={`p-3 rounded-lg ${stat.color}`}>
              <stat.icon className=""w-6 h-6 text-white"" />
            </div>
            <div>
              <p className=""text-sm text-neutral-500"">{stat.title}</p>
              <p className=""text-2xl font-bold text-neutral-800"">{stat.value}</p>
            </div>
          </Card>
        ))}
      </div>

      {/* Recent Executions */}
      <Card title=""Recent Executions"">
        <div className=""space-y-3"">
          {recentExecutions.map((exec) => (
            <Link
              key={exec.id}
              to={`/execution/${exec.id}`}
              className=""flex items-center justify-between p-3 hover:bg-neutral-50 rounded-lg""
            >
              <div className=""flex items-center gap-3"">
                <PlayIcon className=""w-5 h-5 text-primary-500"" />
                <div>
                  <p className=""font-medium"">{exec.scenarioName}</p>
                  <p className=""text-sm text-neutral-500"">{new Date(exec.startedAt).toLocaleString()}</p>
                </div>
              </div>
              <span className={`px-2 py-1 text-sm rounded ${
                exec.status === 'completed' ? 'bg-success-100 text-success-700' :
                exec.status === 'running' ? 'bg-primary-100 text-primary-700' :
                'bg-neutral-100 text-neutral-700'
              }`}>
                {exec.status}
              </span>
            </Link>
          ))}
        </div>
      </Card>

      {/* Quick Actions */}
      <div className=""grid grid-cols-1 md:grid-cols-3 gap-4"">
        <Link to=""/scenarios"" className=""p-6 bg-primary-600 text-white rounded-lg hover:bg-primary-700 transition"">
          <h3 className=""text-lg font-semibold mb-2"">Create Scenario</h3>
          <p className=""text-primary-100"">Build a new attack scenario</p>
        </Link>
        <Link to=""/agents"" className=""p-6 bg-neutral-800 text-white rounded-lg hover:bg-neutral-700 transition"">
          <h3 className=""text-lg font-semibold mb-2"">Deploy Agent</h3>
          <p className=""text-neutral-400"">Add new endpoints to test</p>
        </Link>
        <Link to=""/matrix"" className=""p-6 bg-success-600 text-white rounded-lg hover:bg-success-700 transition"">
          <h3 className=""text-lg font-semibold mb-2"">View Coverage</h3>
          <p className=""text-success-100"">See MITRE ATT&CK coverage</p>
        </Link>
      </div>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/pages/Dashboard.tsx

**Definition of Done:**
- [ ] Cards stats: agents online, security score, techniques blocked/detected
- [ ] Liste des 5 dernieres executions avec lien
- [ ] Quick actions: Create Scenario, Deploy Agent, View Coverage
- [ ] Chargement des donnees au montage
- [ ] Design responsive grid",dashboard;page
"[FE-23] Creer page Agents",Task,"**Objectif:** Creer la page de gestion des agents avec liste, filtres et actions.

**Exemple de code:**
\`\`\`tsx
// src/pages/Agents.tsx
import { useEffect, useState } from 'react'
import { useAgentStore } from '@stores/agentStore'
import { AgentList } from '@components/Agents/AgentList'
import { AgentCard } from '@components/Agents/AgentCard'
import { DeployInstructions } from '@components/Agents/DeployInstructions'
import { Button, Card, Modal } from '@components/common'
import { PlusIcon, Squares2X2Icon, ListBulletIcon } from '@heroicons/react/24/outline'

type ViewMode = 'grid' | 'list'

export function Agents() {
  const { agents, selectedAgent, loading, filters, fetchAgents, setFilters, selectAgent } = useAgentStore()
  const [viewMode, setViewMode] = useState<ViewMode>('grid')
  const [showDeployModal, setShowDeployModal] = useState(false)

  useEffect(() => {
    fetchAgents()
  }, [fetchAgents])

  const handleFilterChange = (key: string, value: string) => {
    setFilters({ ...filters, [key]: value || undefined })
    fetchAgents()
  }

  return (
    <div className=""space-y-6"">
      {/* Header avec actions */}
      <div className=""flex flex-col sm:flex-row justify-between gap-4"">
        <div className=""flex gap-2"">
          <select
            className=""border rounded-lg px-3 py-2""
            value={filters.status || ''}
            onChange={(e) => handleFilterChange('status', e.target.value)}
          >
            <option value="""">All Status</option>
            <option value=""online"">Online</option>
            <option value=""offline"">Offline</option>
            <option value=""busy"">Busy</option>
          </select>
          <select
            className=""border rounded-lg px-3 py-2""
            value={filters.platform || ''}
            onChange={(e) => handleFilterChange('platform', e.target.value)}
          >
            <option value="""">All Platforms</option>
            <option value=""windows"">Windows</option>
            <option value=""linux"">Linux</option>
          </select>
        </div>
        <div className=""flex gap-2"">
          <div className=""flex border rounded-lg"">
            <button
              onClick={() => setViewMode('grid')}
              className={`p-2 ${viewMode === 'grid' ? 'bg-neutral-100' : ''}`}
            >
              <Squares2X2Icon className=""w-5 h-5"" />
            </button>
            <button
              onClick={() => setViewMode('list')}
              className={`p-2 ${viewMode === 'list' ? 'bg-neutral-100' : ''}`}
            >
              <ListBulletIcon className=""w-5 h-5"" />
            </button>
          </div>
          <Button onClick={() => setShowDeployModal(true)}>
            <PlusIcon className=""w-5 h-5"" />
            Deploy Agent
          </Button>
        </div>
      </div>

      {/* Liste des agents */}
      {loading ? (
        <div className=""flex justify-center py-12"">
          <div className=""animate-spin w-8 h-8 border-4 border-primary-500 border-t-transparent rounded-full"" />
        </div>
      ) : viewMode === 'grid' ? (
        <div className=""grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"">
          {agents.map((agent) => (
            <AgentCard key={agent.paw} agent={agent} onClick={() => selectAgent(agent)} />
          ))}
        </div>
      ) : (
        <AgentList agents={agents} onSelect={selectAgent} />
      )}

      {/* Modal deploiement */}
      <Modal
        isOpen={showDeployModal}
        onClose={() => setShowDeployModal(false)}
        title=""Deploy New Agent""
      >
        <DeployInstructions />
      </Modal>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/pages/Agents.tsx

**Definition of Done:**
- [ ] Affichage liste agents en mode grid ou list
- [ ] Filtres par status (online, offline, busy) et platform
- [ ] Bouton switch vue grid/list
- [ ] Bouton Deploy Agent ouvrant modal
- [ ] Chargement avec spinner
- [ ] Selection d'un agent pour voir details",dashboard;page
"[FE-24] Creer composant AgentList",Task,"**Objectif:** Creer le composant table/liste des agents avec sorting et pagination.

**Exemple de code:**
\`\`\`tsx
// src/components/Agents/AgentList.tsx
import { useState } from 'react'
import { Agent } from '@types/agent'
import { AgentStatus } from './AgentStatus'
import { ChevronUpIcon, ChevronDownIcon } from '@heroicons/react/24/outline'

interface AgentListProps {
  agents: Agent[]
  onSelect: (agent: Agent) => void
}

type SortKey = 'hostname' | 'platform' | 'status' | 'lastSeen'
type SortOrder = 'asc' | 'desc'

export function AgentList({ agents, onSelect }: AgentListProps) {
  const [sortKey, setSortKey] = useState<SortKey>('hostname')
  const [sortOrder, setSortOrder] = useState<SortOrder>('asc')
  const [page, setPage] = useState(1)
  const perPage = 10

  const handleSort = (key: SortKey) => {
    if (sortKey === key) {
      setSortOrder(sortOrder === 'asc' ? 'desc' : 'asc')
    } else {
      setSortKey(key)
      setSortOrder('asc')
    }
  }

  const sortedAgents = [...agents].sort((a, b) => {
    const aVal = a[sortKey]
    const bVal = b[sortKey]
    const compare = aVal < bVal ? -1 : aVal > bVal ? 1 : 0
    return sortOrder === 'asc' ? compare : -compare
  })

  const paginatedAgents = sortedAgents.slice((page - 1) * perPage, page * perPage)
  const totalPages = Math.ceil(agents.length / perPage)

  const SortIcon = ({ column }: { column: SortKey }) => {
    if (sortKey !== column) return null
    return sortOrder === 'asc' ?
      <ChevronUpIcon className=""w-4 h-4"" /> :
      <ChevronDownIcon className=""w-4 h-4"" />
  }

  return (
    <div className=""bg-white rounded-lg shadow overflow-hidden"">
      <table className=""min-w-full divide-y divide-neutral-200"">
        <thead className=""bg-neutral-50"">
          <tr>
            {[
              { key: 'hostname', label: 'Hostname' },
              { key: 'platform', label: 'Platform' },
              { key: 'status', label: 'Status' },
              { key: 'lastSeen', label: 'Last Seen' },
            ].map(({ key, label }) => (
              <th
                key={key}
                onClick={() => handleSort(key as SortKey)}
                className=""px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase tracking-wider cursor-pointer hover:bg-neutral-100""
              >
                <div className=""flex items-center gap-1"">
                  {label}
                  <SortIcon column={key as SortKey} />
                </div>
              </th>
            ))}
            <th className=""px-6 py-3""></th>
          </tr>
        </thead>
        <tbody className=""bg-white divide-y divide-neutral-200"">
          {paginatedAgents.map((agent) => (
            <tr
              key={agent.paw}
              onClick={() => onSelect(agent)}
              className=""hover:bg-neutral-50 cursor-pointer""
            >
              <td className=""px-6 py-4 whitespace-nowrap"">
                <div className=""font-medium text-neutral-900"">{agent.hostname}</div>
                <div className=""text-sm text-neutral-500"">{agent.ipAddress}</div>
              </td>
              <td className=""px-6 py-4 whitespace-nowrap text-sm text-neutral-500"">
                {agent.platform}
              </td>
              <td className=""px-6 py-4 whitespace-nowrap"">
                <AgentStatus status={agent.status} />
              </td>
              <td className=""px-6 py-4 whitespace-nowrap text-sm text-neutral-500"">
                {new Date(agent.lastSeen).toLocaleString()}
              </td>
              <td className=""px-6 py-4 whitespace-nowrap text-right text-sm font-medium"">
                <button className=""text-primary-600 hover:text-primary-900"">View</button>
              </td>
            </tr>
          ))}
        </tbody>
      </table>

      {/* Pagination */}
      <div className=""bg-white px-4 py-3 flex items-center justify-between border-t"">
        <div className=""text-sm text-neutral-500"">
          Showing {(page - 1) * perPage + 1} to {Math.min(page * perPage, agents.length)} of {agents.length}
        </div>
        <div className=""flex gap-2"">
          <button
            onClick={() => setPage(page - 1)}
            disabled={page === 1}
            className=""px-3 py-1 border rounded disabled:opacity-50""
          >
            Previous
          </button>
          <button
            onClick={() => setPage(page + 1)}
            disabled={page === totalPages}
            className=""px-3 py-1 border rounded disabled:opacity-50""
          >
            Next
          </button>
        </div>
      </div>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Agents/AgentList.tsx
- dashboard/src/components/Agents/index.ts

**Definition of Done:**
- [ ] Table avec colonnes: Hostname, Platform, Status, Last Seen
- [ ] Sorting par clic sur header
- [ ] Indicateur visuel de tri (chevron)
- [ ] Pagination 10 elements par page
- [ ] Ligne cliquable pour selection
- [ ] Affichage IP en sous-titre du hostname",dashboard;component
"[FE-25] Creer composant AgentCard",Task,"**Objectif:** Creer la card agent pour la vue grid avec infos essentielles et status.

**Exemple de code:**
\`\`\`tsx
// src/components/Agents/AgentCard.tsx
import { Agent } from '@types/agent'
import { AgentStatus } from './AgentStatus'
import { Card } from '@components/common'
import {
  ComputerDesktopIcon,
  ServerIcon,
  UserIcon,
  ClockIcon
} from '@heroicons/react/24/outline'

interface AgentCardProps {
  agent: Agent
  onClick: () => void
}

const PlatformIcon = ({ platform }: { platform: string }) => {
  switch (platform) {
    case 'windows':
      return <ComputerDesktopIcon className=""w-8 h-8 text-blue-500"" />
    case 'linux':
      return <ServerIcon className=""w-8 h-8 text-orange-500"" />
    default:
      return <ComputerDesktopIcon className=""w-8 h-8 text-neutral-500"" />
  }
}

export function AgentCard({ agent, onClick }: AgentCardProps) {
  const timeSinceLastSeen = () => {
    const diff = Date.now() - new Date(agent.lastSeen).getTime()
    const minutes = Math.floor(diff / 60000)
    if (minutes < 1) return 'Just now'
    if (minutes < 60) return `${minutes}m ago`
    const hours = Math.floor(minutes / 60)
    if (hours < 24) return `${hours}h ago`
    return `${Math.floor(hours / 24)}d ago`
  }

  return (
    <Card
      className=""cursor-pointer hover:shadow-lg transition-shadow""
      onClick={onClick}
    >
      <div className=""flex items-start justify-between"">
        <div className=""flex items-center gap-3"">
          <PlatformIcon platform={agent.platform} />
          <div>
            <h3 className=""font-semibold text-neutral-900"">{agent.hostname}</h3>
            <p className=""text-sm text-neutral-500"">{agent.ipAddress}</p>
          </div>
        </div>
        <AgentStatus status={agent.status} />
      </div>

      <div className=""mt-4 space-y-2"">
        <div className=""flex items-center gap-2 text-sm text-neutral-600"">
          <UserIcon className=""w-4 h-4"" />
          <span>{agent.username}</span>
        </div>
        <div className=""flex items-center gap-2 text-sm text-neutral-600"">
          <ClockIcon className=""w-4 h-4"" />
          <span>Last seen: {timeSinceLastSeen()}</span>
        </div>
      </div>

      <div className=""mt-4 pt-4 border-t"">
        <div className=""flex flex-wrap gap-1"">
          {agent.executors.map((exec) => (
            <span
              key={exec}
              className=""px-2 py-0.5 text-xs bg-neutral-100 text-neutral-600 rounded""
            >
              {exec}
            </span>
          ))}
        </div>
      </div>
    </Card>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Agents/AgentCard.tsx

**Definition of Done:**
- [ ] Affichage hostname, IP, username
- [ ] Icone plateforme (Windows/Linux) coloree
- [ ] Badge status avec AgentStatus
- [ ] Temps relatif depuis lastSeen
- [ ] Tags executors disponibles
- [ ] Hover effect avec shadow",dashboard;component
"[FE-26] Creer composant AgentStatus",Task,"**Objectif:** Creer le badge status colore pour les agents.

**Exemple de code:**
\`\`\`tsx
// src/components/Agents/AgentStatus.tsx
import type { Agent } from '@types/agent'

interface AgentStatusProps {
  status: Agent['status']
  showLabel?: boolean
}

const statusConfig = {
  online: {
    color: 'bg-success-500',
    bgColor: 'bg-success-100',
    textColor: 'text-success-700',
    label: 'Online',
  },
  offline: {
    color: 'bg-neutral-400',
    bgColor: 'bg-neutral-100',
    textColor: 'text-neutral-700',
    label: 'Offline',
  },
  busy: {
    color: 'bg-warning-500',
    bgColor: 'bg-warning-100',
    textColor: 'text-warning-700',
    label: 'Busy',
  },
  untrusted: {
    color: 'bg-danger-500',
    bgColor: 'bg-danger-100',
    textColor: 'text-danger-700',
    label: 'Untrusted',
  },
}

export function AgentStatus({ status, showLabel = true }: AgentStatusProps) {
  const config = statusConfig[status]

  return (
    <div className={`inline-flex items-center gap-2 px-2.5 py-1 rounded-full ${config.bgColor}`}>
      <span className={`w-2 h-2 rounded-full ${config.color} ${status === 'online' ? 'animate-pulse' : ''}`} />
      {showLabel && (
        <span className={`text-xs font-medium ${config.textColor}`}>
          {config.label}
        </span>
      )}
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Agents/AgentStatus.tsx

**Definition of Done:**
- [ ] Badge colore selon status: online (vert), offline (gris), busy (jaune), untrusted (rouge)
- [ ] Point colore avec animation pulse pour online
- [ ] Label optionnel (showLabel prop)
- [ ] Couleurs coherentes avec le design system
- [ ] Composant reutilisable",dashboard;component
"[FE-27] Creer composant DeployInstructions",Task,"**Objectif:** Creer le modal avec les instructions de deploiement d'agent a copier.

**Exemple de code:**
\`\`\`tsx
// src/components/Agents/DeployInstructions.tsx
import { useState } from 'react'
import { Button } from '@components/common'
import { ClipboardIcon, CheckIcon } from '@heroicons/react/24/outline'

type Platform = 'windows' | 'linux'

export function DeployInstructions() {
  const [platform, setPlatform] = useState<Platform>('windows')
  const [copied, setCopied] = useState(false)

  const serverUrl = import.meta.env.VITE_API_URL || 'https://localhost:8443'

  const commands: Record<Platform, string> = {
    windows: `powershell -ExecutionPolicy Bypass -Command ""IEX(New-Object Net.WebClient).DownloadString('${serverUrl}/deploy/agent.ps1')""`,
    linux: `curl -sSL ${serverUrl}/deploy/agent.sh | sudo bash`,
  }

  const handleCopy = async () => {
    await navigator.clipboard.writeText(commands[platform])
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  return (
    <div className=""space-y-6"">
      <p className=""text-neutral-600"">
        Deploy an AutoStrike agent on your target endpoint to enable attack simulation.
      </p>

      {/* Platform Selection */}
      <div className=""flex gap-2"">
        <button
          onClick={() => setPlatform('windows')}
          className={`flex-1 py-3 px-4 rounded-lg border-2 transition ${
            platform === 'windows'
              ? 'border-primary-500 bg-primary-50'
              : 'border-neutral-200 hover:border-neutral-300'
          }`}
        >
          <div className=""font-medium"">Windows</div>
          <div className=""text-sm text-neutral-500"">Windows 10/11, Server 2016+</div>
        </button>
        <button
          onClick={() => setPlatform('linux')}
          className={`flex-1 py-3 px-4 rounded-lg border-2 transition ${
            platform === 'linux'
              ? 'border-primary-500 bg-primary-50'
              : 'border-neutral-200 hover:border-neutral-300'
          }`}
        >
          <div className=""font-medium"">Linux</div>
          <div className=""text-sm text-neutral-500"">Ubuntu 20+, Debian, CentOS</div>
        </button>
      </div>

      {/* Command */}
      <div>
        <label className=""block text-sm font-medium text-neutral-700 mb-2"">
          Run this command as Administrator:
        </label>
        <div className=""relative"">
          <pre className=""bg-neutral-900 text-green-400 p-4 rounded-lg text-sm overflow-x-auto font-mono"">
            {commands[platform]}
          </pre>
          <button
            onClick={handleCopy}
            className=""absolute top-2 right-2 p-2 bg-neutral-700 hover:bg-neutral-600 rounded text-white""
            title=""Copy to clipboard""
          >
            {copied ? (
              <CheckIcon className=""w-5 h-5 text-green-400"" />
            ) : (
              <ClipboardIcon className=""w-5 h-5"" />
            )}
          </button>
        </div>
      </div>

      {/* Requirements */}
      <div className=""bg-warning-50 border border-warning-200 rounded-lg p-4"">
        <h4 className=""font-medium text-warning-800 mb-2"">Requirements</h4>
        <ul className=""list-disc list-inside text-sm text-warning-700 space-y-1"">
          <li>Administrator/root privileges required</li>
          <li>Network access to {serverUrl}</li>
          <li>Port 8443 must be open outbound</li>
          {platform === 'windows' && <li>PowerShell 5.1+ installed</li>}
          {platform === 'linux' && <li>curl and bash installed</li>}
        </ul>
      </div>

      <div className=""flex justify-end gap-3"">
        <Button variant=""secondary"" onClick={handleCopy}>
          {copied ? 'Copied!' : 'Copy Command'}
        </Button>
      </div>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Agents/DeployInstructions.tsx

**Definition of Done:**
- [ ] Selection plateforme Windows/Linux
- [ ] Commande one-liner a copier
- [ ] Bouton copier avec feedback visuel
- [ ] Liste des prerequis par plateforme
- [ ] Style terminal pour la commande
- [ ] URL serveur configurable via env",dashboard;component
"[FE-28] Creer page Scenarios",Task,"**Objectif:** Creer la page de gestion des scenarios avec liste et actions CRUD.

**Exemple de code:**
\`\`\`tsx
// src/pages/Scenarios.tsx
import { useEffect, useState } from 'react'
import { useNavigate } from 'react-router-dom'
import { useScenarioStore } from '@stores/scenarioStore'
import { ScenarioList } from '@components/Scenarios/ScenarioList'
import { ScenarioBuilder } from '@components/Scenarios/ScenarioBuilder'
import { Button, Modal, Card } from '@components/common'
import { PlusIcon } from '@heroicons/react/24/outline'

export function Scenarios() {
  const navigate = useNavigate()
  const { scenarios, loading, fetchScenarios, deleteScenario, duplicateScenario } = useScenarioStore()
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [editingScenario, setEditingScenario] = useState<string | null>(null)

  useEffect(() => {
    fetchScenarios()
  }, [fetchScenarios])

  const handleDelete = async (id: string) => {
    if (confirm('Are you sure you want to delete this scenario?')) {
      await deleteScenario(id)
    }
  }

  const handleDuplicate = async (id: string) => {
    const duplicated = await duplicateScenario(id)
    setEditingScenario(duplicated.id)
    setShowCreateModal(true)
  }

  const handleExecute = (id: string) => {
    navigate(`/execution?scenario=${id}`)
  }

  return (
    <div className=""space-y-6"">
      {/* Header */}
      <div className=""flex justify-between items-center"">
        <div>
          <h2 className=""text-lg font-semibold text-neutral-900"">Attack Scenarios</h2>
          <p className=""text-neutral-500"">Create and manage attack simulation scenarios</p>
        </div>
        <Button onClick={() => { setEditingScenario(null); setShowCreateModal(true); }}>
          <PlusIcon className=""w-5 h-5"" />
          New Scenario
        </Button>
      </div>

      {/* Liste */}
      {loading ? (
        <div className=""flex justify-center py-12"">
          <div className=""animate-spin w-8 h-8 border-4 border-primary-500 border-t-transparent rounded-full"" />
        </div>
      ) : scenarios.length === 0 ? (
        <Card className=""text-center py-12"">
          <p className=""text-neutral-500 mb-4"">No scenarios yet. Create your first attack scenario!</p>
          <Button onClick={() => setShowCreateModal(true)}>
            <PlusIcon className=""w-5 h-5"" />
            Create Scenario
          </Button>
        </Card>
      ) : (
        <ScenarioList
          scenarios={scenarios}
          onEdit={(id) => { setEditingScenario(id); setShowCreateModal(true); }}
          onDelete={handleDelete}
          onDuplicate={handleDuplicate}
          onExecute={handleExecute}
        />
      )}

      {/* Modal Create/Edit */}
      <Modal
        isOpen={showCreateModal}
        onClose={() => { setShowCreateModal(false); setEditingScenario(null); }}
        title={editingScenario ? 'Edit Scenario' : 'Create Scenario'}
      >
        <ScenarioBuilder
          scenarioId={editingScenario}
          onClose={() => { setShowCreateModal(false); setEditingScenario(null); }}
        />
      </Modal>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/pages/Scenarios.tsx

**Definition of Done:**
- [ ] Liste des scenarios avec ScenarioList
- [ ] Bouton creation ouvrant modal ScenarioBuilder
- [ ] Actions: Edit, Delete, Duplicate, Execute
- [ ] Confirmation avant suppression
- [ ] State vide avec call-to-action
- [ ] Redirection vers Execution avec scenario ID",dashboard;page
"[FE-29] Creer composant ScenarioList",Task,"**Objectif:** Creer le composant table des scenarios avec colonnes et actions.

**Exemple de code:**
\`\`\`tsx
// src/components/Scenarios/ScenarioList.tsx
import { Scenario } from '@types/scenario'
import { Button } from '@components/common'
import {
  PencilIcon,
  TrashIcon,
  DocumentDuplicateIcon,
  PlayIcon,
} from '@heroicons/react/24/outline'

interface ScenarioListProps {
  scenarios: Scenario[]
  onEdit: (id: string) => void
  onDelete: (id: string) => void
  onDuplicate: (id: string) => void
  onExecute: (id: string) => void
}

export function ScenarioList({
  scenarios,
  onEdit,
  onDelete,
  onDuplicate,
  onExecute,
}: ScenarioListProps) {
  const getTechniqueCount = (scenario: Scenario): number => {
    return scenario.phases.reduce((acc, phase) => acc + phase.techniques.length, 0)
  }

  return (
    <div className=""bg-white rounded-lg shadow overflow-hidden"">
      <table className=""min-w-full divide-y divide-neutral-200"">
        <thead className=""bg-neutral-50"">
          <tr>
            <th className=""px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase"">
              Name
            </th>
            <th className=""px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase"">
              Phases
            </th>
            <th className=""px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase"">
              Techniques
            </th>
            <th className=""px-6 py-3 text-left text-xs font-medium text-neutral-500 uppercase"">
              Updated
            </th>
            <th className=""px-6 py-3 text-right text-xs font-medium text-neutral-500 uppercase"">
              Actions
            </th>
          </tr>
        </thead>
        <tbody className=""bg-white divide-y divide-neutral-200"">
          {scenarios.map((scenario) => (
            <tr key={scenario.id} className=""hover:bg-neutral-50"">
              <td className=""px-6 py-4"">
                <div className=""font-medium text-neutral-900"">{scenario.name}</div>
                <div className=""text-sm text-neutral-500 truncate max-w-xs"">
                  {scenario.description}
                </div>
              </td>
              <td className=""px-6 py-4 whitespace-nowrap text-sm text-neutral-500"">
                {scenario.phases.length} phases
              </td>
              <td className=""px-6 py-4 whitespace-nowrap text-sm text-neutral-500"">
                {getTechniqueCount(scenario)} techniques
              </td>
              <td className=""px-6 py-4 whitespace-nowrap text-sm text-neutral-500"">
                {new Date(scenario.updatedAt).toLocaleDateString()}
              </td>
              <td className=""px-6 py-4 whitespace-nowrap text-right"">
                <div className=""flex justify-end gap-2"">
                  <button
                    onClick={() => onExecute(scenario.id)}
                    className=""p-2 text-success-600 hover:bg-success-50 rounded""
                    title=""Execute""
                  >
                    <PlayIcon className=""w-5 h-5"" />
                  </button>
                  <button
                    onClick={() => onEdit(scenario.id)}
                    className=""p-2 text-primary-600 hover:bg-primary-50 rounded""
                    title=""Edit""
                  >
                    <PencilIcon className=""w-5 h-5"" />
                  </button>
                  <button
                    onClick={() => onDuplicate(scenario.id)}
                    className=""p-2 text-neutral-600 hover:bg-neutral-100 rounded""
                    title=""Duplicate""
                  >
                    <DocumentDuplicateIcon className=""w-5 h-5"" />
                  </button>
                  <button
                    onClick={() => onDelete(scenario.id)}
                    className=""p-2 text-danger-600 hover:bg-danger-50 rounded""
                    title=""Delete""
                  >
                    <TrashIcon className=""w-5 h-5"" />
                  </button>
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </table>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Scenarios/ScenarioList.tsx
- dashboard/src/components/Scenarios/index.ts

**Definition of Done:**
- [ ] Table avec colonnes: Name, Phases, Techniques, Updated, Actions
- [ ] Affichage description tronquee
- [ ] Comptage techniques total (somme des phases)
- [ ] Boutons actions: Execute (play), Edit, Duplicate, Delete
- [ ] Hover effect sur les lignes
- [ ] Icons Heroicons coherentes",dashboard;component
"[FE-30] Creer composant ScenarioBuilder",Task,"**Objectif:** Creer le formulaire de creation/edition de scenario avec phases et selection techniques.

**Exemple de code:**
\`\`\`tsx
// src/components/Scenarios/ScenarioBuilder.tsx
import { useState, useEffect } from 'react'
import { useScenarioStore } from '@stores/scenarioStore'
import { useTechniqueStore } from '@stores/techniqueStore'
import { Button, Input } from '@components/common'
import { PhaseEditor } from './PhaseEditor'
import { PlusIcon } from '@heroicons/react/24/outline'
import type { Phase, CreateScenarioDto } from '@types/scenario'

interface ScenarioBuilderProps {
  scenarioId: string | null
  onClose: () => void
}

export function ScenarioBuilder({ scenarioId, onClose }: ScenarioBuilderProps) {
  const { currentScenario, fetchScenario, createScenario, updateScenario, loading } = useScenarioStore()
  const { techniques, fetchTechniques } = useTechniqueStore()

  const [name, setName] = useState('')
  const [description, setDescription] = useState('')
  const [phases, setPhases] = useState<Omit<Phase, 'order'>[]>([
    { name: 'Initial Access', description: '', techniques: [] }
  ])
  const [errors, setErrors] = useState<Record<string, string>>({})

  useEffect(() => {
    fetchTechniques()
    if (scenarioId) {
      fetchScenario(scenarioId)
    }
  }, [scenarioId, fetchScenario, fetchTechniques])

  useEffect(() => {
    if (scenarioId && currentScenario) {
      setName(currentScenario.name)
      setDescription(currentScenario.description)
      setPhases(currentScenario.phases.map(({ order, ...p }) => p))
    }
  }, [currentScenario, scenarioId])

  const validate = (): boolean => {
    const newErrors: Record<string, string> = {}
    if (!name.trim()) newErrors.name = 'Name is required'
    if (phases.length === 0) newErrors.phases = 'At least one phase is required'
    if (phases.some(p => p.techniques.length === 0)) {
      newErrors.phases = 'Each phase must have at least one technique'
    }
    setErrors(newErrors)
    return Object.keys(newErrors).length === 0
  }

  const handleSubmit = async () => {
    if (!validate()) return

    const data: CreateScenarioDto = { name, description, phases }

    try {
      if (scenarioId) {
        await updateScenario(scenarioId, data)
      } else {
        await createScenario(data)
      }
      onClose()
    } catch (error) {
      setErrors({ submit: (error as Error).message })
    }
  }

  const addPhase = () => {
    setPhases([...phases, { name: `Phase ${phases.length + 1}`, description: '', techniques: [] }])
  }

  const updatePhase = (index: number, phase: Omit<Phase, 'order'>) => {
    setPhases(phases.map((p, i) => i === index ? phase : p))
  }

  const removePhase = (index: number) => {
    setPhases(phases.filter((_, i) => i !== index))
  }

  return (
    <div className=""space-y-6 max-h-[70vh] overflow-y-auto"">
      {/* Name & Description */}
      <div className=""space-y-4"">
        <div>
          <label className=""block text-sm font-medium text-neutral-700 mb-1"">
            Scenario Name *
          </label>
          <Input
            value={name}
            onChange={(e) => setName(e.target.value)}
            placeholder=""e.g., Ransomware Simulation""
            error={errors.name}
          />
        </div>
        <div>
          <label className=""block text-sm font-medium text-neutral-700 mb-1"">
            Description
          </label>
          <textarea
            value={description}
            onChange={(e) => setDescription(e.target.value)}
            placeholder=""Describe the attack scenario...""
            className=""w-full border rounded-lg px-3 py-2 h-24 resize-none""
          />
        </div>
      </div>

      {/* Phases */}
      <div>
        <div className=""flex items-center justify-between mb-4"">
          <h3 className=""font-medium text-neutral-900"">Phases</h3>
          <Button variant=""ghost"" size=""sm"" onClick={addPhase}>
            <PlusIcon className=""w-4 h-4"" />
            Add Phase
          </Button>
        </div>
        {errors.phases && (
          <p className=""text-danger-500 text-sm mb-2"">{errors.phases}</p>
        )}
        <div className=""space-y-4"">
          {phases.map((phase, index) => (
            <PhaseEditor
              key={index}
              phase={phase}
              techniques={techniques}
              onChange={(updated) => updatePhase(index, updated)}
              onRemove={() => removePhase(index)}
              canRemove={phases.length > 1}
            />
          ))}
        </div>
      </div>

      {/* Actions */}
      {errors.submit && (
        <p className=""text-danger-500 text-sm"">{errors.submit}</p>
      )}
      <div className=""flex justify-end gap-3 pt-4 border-t"">
        <Button variant=""secondary"" onClick={onClose}>
          Cancel
        </Button>
        <Button onClick={handleSubmit} loading={loading}>
          {scenarioId ? 'Update Scenario' : 'Create Scenario'}
        </Button>
      </div>
    </div>
  )
}
\`\`\`

**Fichiers a creer:**
- dashboard/src/components/Scenarios/ScenarioBuilder.tsx

**Definition of Done:**
- [ ] Formulaire nom et description
- [ ] Gestion des phases (ajout, suppression, edition)
- [ ] Integration PhaseEditor pour chaque phase
- [ ] Validation: nom requis, au moins 1 phase, au moins 1 technique par phase
- [ ] Mode creation et edition (selon scenarioId)
- [ ] Chargement du scenario existant en mode edit
- [ ] Gestion des erreurs et loading state",dashboard;component
"[FE-31] Creer page Matrix (Matrice ATT&CK)",Task,"**Objectif:** Creer la page principale affichant la matrice MITRE ATT&CK interactive avec visualisation de la couverture de securite.

**Code TSX exemple:**
```tsx
import React, { useState } from 'react';
import { MitreMatrix } from '../components/AttackMatrix/MitreMatrix';
import { TechniqueDetails } from '../components/AttackMatrix/TechniqueDetails';
import { useScenarios } from '../hooks/useScenarios';
import { Technique } from '../types';

export const MatrixPage: React.FC = () => {
  const { techniques, results, isLoading } = useScenarios();
  const [selectedTechnique, setSelectedTechnique] = useState<Technique | null>(null);

  if (isLoading) return <div className=""flex justify-center p-8""><Spinner /></div>;

  return (
    <div className=""container mx-auto p-6"">
      <h1 className=""text-2xl font-bold mb-6"">Matrice MITRE ATT&CK</h1>
      <div className=""grid grid-cols-1 lg:grid-cols-4 gap-6"">
        <div className=""lg:col-span-3"">
          <MitreMatrix
            techniques={techniques}
            results={results}
            onTechniqueClick={setSelectedTechnique}
          />
        </div>
        <div className=""lg:col-span-1"">
          {selectedTechnique && (
            <TechniqueDetails technique={selectedTechnique} />
          )}
        </div>
      </div>
    </div>
  );
};
```

**Fichiers:**
- src/pages/MatrixPage.tsx
- src/routes/index.tsx (ajout route /matrix)

**Definition of Done:**
- [ ] Page accessible via /matrix
- [ ] Matrice MITRE affichee avec toutes les tactics
- [ ] Couleurs selon status (blocked, detected, success, untested)
- [ ] Panel details visible au clic sur technique
- [ ] Loading state implemente
- [ ] Tests unitaires passes",dashboard;page
"[FE-32] Creer composant MitreMatrix",Task,"**Objectif:** Creer le composant principal de la matrice MITRE ATT&CK avec D3.js pour afficher les 14 tactics et leurs techniques avec code couleur.

**Code TSX exemple:**
```tsx
import React, { useMemo } from 'react';
import * as d3 from 'd3';
import { TacticColumn } from './TacticColumn';
import { HeatmapLegend } from './HeatmapLegend';
import { Technique, ExecutionResult } from '../../types';

interface MitreMatrixProps {
  techniques: Technique[];
  results: ExecutionResult[];
  onTechniqueClick: (technique: Technique) => void;
}

const TACTICS_ORDER = [
  'reconnaissance', 'resource-development', 'initial-access',
  'execution', 'persistence', 'privilege-escalation',
  'defense-evasion', 'credential-access', 'discovery',
  'lateral-movement', 'collection', 'command-and-control',
  'exfiltration', 'impact'
];

export const MitreMatrix: React.FC<MitreMatrixProps> = ({
  techniques, results, onTechniqueClick
}) => {
  const techniquesByTactic = useMemo(() => {
    const grouped: Record<string, Technique[]> = {};
    TACTICS_ORDER.forEach(tactic => {
      grouped[tactic] = techniques.filter(t => t.tactic === tactic);
    });
    return grouped;
  }, [techniques]);

  const colorScale = useMemo(() => {
    return d3.scaleOrdinal<string>()
      .domain(['success', 'blocked', 'detected', 'untested'])
      .range(['#ef4444', '#22c55e', '#f59e0b', '#6b7280']);
  }, []);

  return (
    <div className=""overflow-x-auto bg-white rounded-xl shadow-lg p-4"">
      <div className=""flex gap-1 min-w-max"">
        {TACTICS_ORDER.map(tactic => (
          <TacticColumn
            key={tactic}
            tactic={tactic}
            techniques={techniquesByTactic[tactic] || []}
            colorScale={colorScale}
            onTechniqueClick={onTechniqueClick}
          />
        ))}
      </div>
      <HeatmapLegend colorScale={colorScale} />
    </div>
  );
};
```

**Fichiers:**
- src/components/AttackMatrix/MitreMatrix.tsx
- src/components/AttackMatrix/index.ts

**Definition of Done:**
- [ ] Composant affiche les 14 tactics MITRE
- [ ] Techniques groupees par tactic
- [ ] Scale de couleurs D3.js fonctionnelle
- [ ] Scroll horizontal pour petits ecrans
- [ ] Props TypeScript correctement types
- [ ] Tests unitaires passes",dashboard;d3
"[FE-33] Creer composant TacticColumn",Task,"**Objectif:** Creer le composant colonne pour une tactic MITRE affichant le nom de la tactic et la liste verticale de ses techniques.

**Code TSX exemple:**
```tsx
import React from 'react';
import { TechniqueCell } from './TechniqueCell';
import { Technique } from '../../types';

interface TacticColumnProps {
  tactic: string;
  techniques: Technique[];
  colorScale: d3.ScaleOrdinal<string, string>;
  getStatus: (techniqueId: string) => string;
  onTechniqueClick: (technique: Technique) => void;
}

const TACTIC_LABELS: Record<string, string> = {
  'reconnaissance': 'Reconnaissance',
  'initial-access': 'Initial Access',
  'execution': 'Execution',
  'persistence': 'Persistence',
  'privilege-escalation': 'Privilege Escalation',
  'defense-evasion': 'Defense Evasion',
  'credential-access': 'Credential Access',
  'discovery': 'Discovery',
  'lateral-movement': 'Lateral Movement',
  'collection': 'Collection',
  'command-and-control': 'Command & Control',
  'exfiltration': 'Exfiltration',
  'impact': 'Impact'
};

export const TacticColumn: React.FC<TacticColumnProps> = ({
  tactic, techniques, colorScale, getStatus, onTechniqueClick
}) => {
  return (
    <div className=""flex flex-col min-w-[140px]"">
      <div className=""bg-slate-800 text-white text-xs font-semibold p-2 rounded-t text-center"">
        {TACTIC_LABELS[tactic] || tactic}
      </div>
      <div className=""flex flex-col gap-1 p-1 bg-slate-100 rounded-b"">
        {techniques.map(technique => (
          <TechniqueCell
            key={technique.id}
            technique={technique}
            status={getStatus(technique.id)}
            color={colorScale(getStatus(technique.id))}
            onClick={() => onTechniqueClick(technique)}
          />
        ))}
      </div>
    </div>
  );
};
```

**Fichiers:**
- src/components/AttackMatrix/TacticColumn.tsx

**Definition of Done:**
- [ ] Header avec nom de la tactic
- [ ] Liste verticale des techniques
- [ ] Mapping des labels tactics correct
- [ ] Style coherent avec design system
- [ ] Props TypeScript types
- [ ] Tests unitaires passes",dashboard;d3
"[FE-34] Creer composant TechniqueCell",Task,"**Objectif:** Creer le composant cellule pour une technique MITRE avec couleur de status, tooltip et accessibilite.

**Code TSX exemple:**
```tsx
import React from 'react';
import { Technique } from '../../types';

interface TechniqueCellProps {
  technique: Technique;
  status: string;
  color: string;
  onClick: () => void;
}

const STATUS_ICONS: Record<string, string> = {
  blocked: 'checkmark',
  detected: 'warning',
  success: 'x',
  untested: 'circle'
};

export const TechniqueCell: React.FC<TechniqueCellProps> = ({
  technique, status, color, onClick
}) => {
  return (
    <div
      className=""p-2 rounded cursor-pointer transition-all hover:scale-105 hover:shadow-lg focus:ring-2 focus:ring-blue-500""
      style={{ backgroundColor: color }}
      onClick={onClick}
      onKeyDown={(e) => e.key === 'Enter' && onClick()}
      tabIndex={0}
      role=""button""
      aria-label={`${technique.id}: ${technique.name} - Status: ${status}`}
      title={`${technique.id}: ${technique.name}\nStatus: ${status}`}
    >
      <div className=""text-xs font-mono text-white opacity-75"">
        {technique.id}
      </div>
      <div className=""text-sm text-white font-medium truncate"">
        {technique.name}
      </div>
      <span className=""sr-only"">{status}</span>
    </div>
  );
};
```

**Fichiers:**
- src/components/AttackMatrix/TechniqueCell.tsx

**Definition of Done:**
- [ ] Affiche ID et nom technique
- [ ] Couleur selon status
- [ ] Tooltip au hover
- [ ] Accessible au clavier (Tab + Enter)
- [ ] ARIA labels pour lecteurs ecran
- [ ] Animation hover fluide
- [ ] Tests unitaires passes",dashboard;d3
"[FE-35] Creer composant HeatmapLegend",Task,"**Objectif:** Creer la legende de la heatmap expliquant les couleurs: bloque (vert), detecte (jaune), succes attaque (rouge), non teste (gris).

**Code TSX exemple:**
```tsx
import React from 'react';
import * as d3 from 'd3';

interface HeatmapLegendProps {
  colorScale: d3.ScaleOrdinal<string, string>;
}

const LEGEND_ITEMS = [
  { status: 'blocked', label: 'Bloque', description: 'Attaque bloquee par les defenses' },
  { status: 'detected', label: 'Detecte', description: 'Attaque detectee mais non bloquee' },
  { status: 'success', label: 'Succes', description: 'Attaque reussie sans detection' },
  { status: 'untested', label: 'Non teste', description: 'Technique non encore testee' }
];

export const HeatmapLegend: React.FC<HeatmapLegendProps> = ({ colorScale }) => {
  return (
    <div className=""flex flex-wrap gap-4 mt-4 p-4 bg-slate-50 rounded-lg"">
      <span className=""text-sm font-semibold text-slate-700"">Legende:</span>
      {LEGEND_ITEMS.map(({ status, label, description }) => (
        <div
          key={status}
          className=""flex items-center gap-2""
          title={description}
        >
          <div
            className=""w-4 h-4 rounded""
            style={{ backgroundColor: colorScale(status) }}
          />
          <span className=""text-sm text-slate-600"">{label}</span>
        </div>
      ))}
    </div>
  );
};
```

**Fichiers:**
- src/components/AttackMatrix/HeatmapLegend.tsx

**Definition of Done:**
- [ ] 4 items de legende affiches
- [ ] Couleurs coherentes avec colorScale
- [ ] Tooltips descriptifs
- [ ] Layout responsive (wrap sur mobile)
- [ ] Tests unitaires passes",dashboard;d3
"[FE-36] Creer composant TechniqueDetails",Task,"**Objectif:** Creer le panel lateral affichant les details d'une technique selectionnee: description, resultats precedents, commandes executees.

**Code TSX exemple:**
```tsx
import React from 'react';
import { Technique, ExecutionResult } from '../../types';
import { ResultBadge } from '../Execution/ResultBadge';

interface TechniqueDetailsProps {
  technique: Technique;
  results?: ExecutionResult[];
}

export const TechniqueDetails: React.FC<TechniqueDetailsProps> = ({
  technique, results = []
}) => {
  return (
    <div className=""bg-white rounded-xl shadow-lg p-6"">
      <div className=""flex items-start justify-between mb-4"">
        <div>
          <span className=""text-xs font-mono text-slate-500"">{technique.id}</span>
          <h3 className=""text-lg font-semibold text-slate-800"">{technique.name}</h3>
        </div>
        <span className=""px-2 py-1 bg-slate-100 rounded text-xs"">{technique.tactic}</span>
      </div>

      <p className=""text-sm text-slate-600 mb-4"">{technique.description}</p>

      <div className=""mb-4"">
        <h4 className=""text-sm font-semibold mb-2"">Plateformes</h4>
        <div className=""flex gap-2"">
          {technique.platforms.map(p => (
            <span key={p} className=""px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs"">{p}</span>
          ))}
        </div>
      </div>

      {results.length > 0 && (
        <div>
          <h4 className=""text-sm font-semibold mb-2"">Derniers resultats</h4>
          <div className=""space-y-2"">
            {results.slice(0, 5).map(r => (
              <div key={r.id} className=""flex items-center justify-between p-2 bg-slate-50 rounded"">
                <span className=""text-xs text-slate-500"">{new Date(r.timestamp).toLocaleString()}</span>
                <ResultBadge status={r.status} />
              </div>
            ))}
          </div>
        </div>
      )}

      <a
        href={`https://attack.mitre.org/techniques/${technique.id.replace('.', '/')}`}
        target=""_blank""
        rel=""noopener noreferrer""
        className=""mt-4 block text-sm text-blue-600 hover:underline""
      >
        Voir sur MITRE ATT&CK
      </a>
    </div>
  );
};
```

**Fichiers:**
- src/components/AttackMatrix/TechniqueDetails.tsx

**Definition of Done:**
- [ ] Affiche ID, nom, description technique
- [ ] Liste des plateformes supportees
- [ ] Historique des 5 derniers resultats
- [ ] Lien externe vers MITRE ATT&CK
- [ ] Tests unitaires passes",dashboard;component
"[FE-37] Configurer D3.js",Task,"**Objectif:** Installer et configurer D3.js avec les types TypeScript et creer les helpers utilitaires pour la visualisation.

**Code TSX exemple:**
```tsx
// src/lib/d3-helpers.ts
import * as d3 from 'd3';

export const STATUS_COLORS = {
  blocked: '#22c55e',   // green-500
  detected: '#f59e0b',  // amber-500
  success: '#ef4444',   // red-500
  untested: '#6b7280',  // gray-500
  error: '#8b5cf6'      // violet-500
} as const;

export type StatusType = keyof typeof STATUS_COLORS;

export const createStatusColorScale = () => {
  return d3.scaleOrdinal<StatusType, string>()
    .domain(Object.keys(STATUS_COLORS) as StatusType[])
    .range(Object.values(STATUS_COLORS));
};

export const createCoverageScale = () => {
  return d3.scaleSequential(d3.interpolateRdYlGn)
    .domain([0, 100]);
};

export const formatPercentage = (value: number): string => {
  return d3.format('.1%')(value / 100);
};

// Hook pour utiliser D3 avec React
export const useD3 = (
  renderFn: (svg: d3.Selection<SVGSVGElement, unknown, null, undefined>) => void,
  dependencies: React.DependencyList
) => {
  const ref = React.useRef<SVGSVGElement>(null);

  React.useEffect(() => {
    if (ref.current) {
      renderFn(d3.select(ref.current));
    }
  }, dependencies);

  return ref;
};
```

**Fichiers:**
- src/lib/d3-helpers.ts
- package.json (ajout d3, @types/d3)
- tsconfig.json (verification config)

**Definition of Done:**
- [ ] d3 et @types/d3 installes
- [ ] Helper createStatusColorScale fonctionnel
- [ ] Hook useD3 pour integration React
- [ ] Types TypeScript corrects
- [ ] Export depuis index.ts
- [ ] Tests unitaires passes",dashboard;d3
"[FE-38] Implementer color scale D3",Task,"**Objectif:** Implementer les scales de couleurs D3.js pour les differents status de resultats et la couverture MITRE.

**Code TSX exemple:**
```tsx
// src/lib/color-scales.ts
import * as d3 from 'd3';
import { StatusType, STATUS_COLORS } from './d3-helpers';

export interface ColorScaleConfig {
  domain: string[];
  range: string[];
}

// Scale pour les status de resultats
export const resultStatusScale = d3.scaleOrdinal<string>()
  .domain(['blocked', 'detected', 'success', 'untested', 'error', 'skipped'])
  .range(['#22c55e', '#f59e0b', '#ef4444', '#6b7280', '#8b5cf6', '#94a3b8']);

// Scale pour la couverture (0-100%)
export const coverageScale = d3.scaleThreshold<number, string>()
  .domain([25, 50, 75])
  .range(['#ef4444', '#f59e0b', '#84cc16', '#22c55e']);

// Scale pour le score de securite
export const securityScoreScale = d3.scaleLinear<string>()
  .domain([0, 40, 60, 80, 100])
  .range(['#ef4444', '#f97316', '#eab308', '#84cc16', '#22c55e']);

// Fonction pour obtenir la couleur d'un status
export const getStatusColor = (status: string): string => {
  return resultStatusScale(status) || STATUS_COLORS.untested;
};

// Fonction pour obtenir la couleur de couverture
export const getCoverageColor = (percentage: number): string => {
  return coverageScale(percentage);
};

// Fonction pour obtenir le label textuel du status
export const getStatusLabel = (status: string): string => {
  const labels: Record<string, string> = {
    blocked: 'Bloque',
    detected: 'Detecte',
    success: 'Succes attaque',
    untested: 'Non teste',
    error: 'Erreur',
    skipped: 'Ignore'
  };
  return labels[status] || status;
};
```

**Fichiers:**
- src/lib/color-scales.ts
- src/lib/index.ts (export)

**Definition of Done:**
- [ ] Scale resultStatusScale fonctionnelle
- [ ] Scale coverageScale fonctionnelle
- [ ] Scale securityScoreScale fonctionnelle
- [ ] Fonctions helper getStatusColor/getCoverageColor
- [ ] Couleurs coherentes avec design system
- [ ] Tests unitaires passes",dashboard;d3
"[FE-39] Creer page Execution",Task,"**Objectif:** Creer la page de monitoring temps reel d'une execution de scenario avec progression, logs live et resultats.

**Code TSX exemple:**
```tsx
import React from 'react';
import { useParams, Navigate } from 'react-router-dom';
import { ExecutionMonitor } from '../components/Execution/ExecutionMonitor';
import { useExecution } from '../hooks/useExecution';

export const ExecutionPage: React.FC = () => {
  const { executionId } = useParams<{ executionId: string }>();
  const { execution, isLoading, error } = useExecution(executionId);

  if (!executionId) return <Navigate to=""/scenarios"" />;
  if (isLoading) return <div className=""flex justify-center p-8""><Spinner /></div>;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div className=""container mx-auto p-6"">
      <div className=""flex items-center justify-between mb-6"">
        <div>
          <h1 className=""text-2xl font-bold"">Execution en cours</h1>
          <p className=""text-slate-500"">Scenario: {execution?.scenarioName}</p>
        </div>
        <button
          onClick={() => {/* cancel execution */}}
          className=""px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600""
        >
          Annuler
        </button>
      </div>

      <ExecutionMonitor executionId={executionId} />
    </div>
  );
};
```

**Fichiers:**
- src/pages/ExecutionPage.tsx
- src/routes/index.tsx (ajout route /execution/:executionId)

**Definition of Done:**
- [ ] Page accessible via /execution/:id
- [ ] Recuperation executionId depuis URL
- [ ] Affichage ExecutionMonitor
- [ ] Bouton annulation fonctionnel
- [ ] Gestion erreur et loading
- [ ] Redirection si ID invalide
- [ ] Tests unitaires passes",dashboard;page
"[FE-40] Creer composant ExecutionMonitor",Task,"**Objectif:** Creer le composant principal de monitoring affichant la progression, les logs temps reel et les resultats d'une execution.

**Code TSX exemple:**
```tsx
import React, { useEffect, useState } from 'react';
import { useWebSocket } from '../../hooks/useWebSocket';
import { LiveLogs } from './LiveLogs';
import { ProgressBar } from './ProgressBar';
import { ResultBadge } from './ResultBadge';

interface ExecutionMonitorProps {
  executionId: string;
}

interface ExecutionEvent {
  type: 'started' | 'technique_complete' | 'completed' | 'error';
  techniqueId?: string;
  techniqueName?: string;
  status?: string;
  output?: string;
  timestamp: string;
}

export const ExecutionMonitor: React.FC<ExecutionMonitorProps> = ({ executionId }) => {
  const [events, setEvents] = useState<ExecutionEvent[]>([]);
  const [progress, setProgress] = useState({ current: 0, total: 0 });
  const [results, setResults] = useState<Record<string, string>>({});

  const { lastMessage, connectionStatus } = useWebSocket(
    `wss://localhost:8443/ws/live?execution=${executionId}`
  );

  useEffect(() => {
    if (lastMessage) {
      const event: ExecutionEvent = JSON.parse(lastMessage.data);
      setEvents(prev => [...prev, event]);

      if (event.type === 'technique_complete') {
        setProgress(prev => ({ ...prev, current: prev.current + 1 }));
        if (event.techniqueId && event.status) {
          setResults(prev => ({ ...prev, [event.techniqueId!]: event.status! }));
        }
      }
    }
  }, [lastMessage]);

  return (
    <div className=""bg-white rounded-xl shadow-lg p-6"">
      <div className=""flex items-center justify-between mb-4"">
        <h2 className=""text-lg font-semibold"">Execution en cours</h2>
        <ConnectionStatus status={connectionStatus} />
      </div>
      <ProgressBar current={progress.current} total={progress.total} />
      <ResultsSummary results={results} />
      <LiveLogs events={events} />
    </div>
  );
};
```

**Fichiers:**
- src/components/Execution/ExecutionMonitor.tsx
- src/components/Execution/index.ts

**Definition of Done:**
- [ ] Connexion WebSocket etablie
- [ ] Progression mise a jour en temps reel
- [ ] Events affiches dans LiveLogs
- [ ] Resultats accumules et affiches
- [ ] Status connexion visible
- [ ] Tests unitaires passes",dashboard;component
"[FE-41] Creer composant ProgressBar",Task,"**Objectif:** Creer une barre de progression animee affichant le pourcentage et le nombre de techniques restantes.

**Code TSX exemple:**
```tsx
import React from 'react';

interface ProgressBarProps {
  current: number;
  total: number;
  showLabel?: boolean;
}

export const ProgressBar: React.FC<ProgressBarProps> = ({
  current, total, showLabel = true
}) => {
  const percentage = total > 0 ? Math.round((current / total) * 100) : 0;
  const remaining = total - current;

  return (
    <div className=""mb-6"">
      {showLabel && (
        <div className=""flex justify-between text-sm text-slate-600 mb-2"">
          <span>{current} / {total} techniques</span>
          <span>{percentage}%</span>
        </div>
      )}

      <div className=""h-4 bg-slate-200 rounded-full overflow-hidden"">
        <div
          className=""h-full bg-gradient-to-r from-blue-500 to-blue-600 transition-all duration-500 ease-out""
          style={{ width: `${percentage}%` }}
          role=""progressbar""
          aria-valuenow={percentage}
          aria-valuemin={0}
          aria-valuemax={100}
        />
      </div>

      {remaining > 0 && (
        <p className=""text-xs text-slate-500 mt-1"">
          {remaining} technique{remaining > 1 ? 's' : ''} restante{remaining > 1 ? 's' : ''}
        </p>
      )}
    </div>
  );
};
```

**Fichiers:**
- src/components/Execution/ProgressBar.tsx

**Definition of Done:**
- [ ] Affiche progression visuelle
- [ ] Pourcentage calcule et affiche
- [ ] Animation fluide de la barre
- [ ] ARIA attributes pour accessibilite
- [ ] Texte techniques restantes
- [ ] Tests unitaires passes",dashboard;component
"[FE-42] Creer composant LiveLogs",Task,"**Objectif:** Creer une zone de logs scrollable avec mise a jour temps reel et auto-scroll vers le bas.

**Code TSX exemple:**
```tsx
import React, { useRef, useEffect } from 'react';
import { ResultBadge } from './ResultBadge';

interface LogEvent {
  type: string;
  techniqueId?: string;
  techniqueName?: string;
  status?: string;
  output?: string;
  timestamp: string;
}

interface LiveLogsProps {
  events: LogEvent[];
  maxHeight?: string;
}

export const LiveLogs: React.FC<LiveLogsProps> = ({
  events, maxHeight = '400px'
}) => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (containerRef.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight;
    }
  }, [events]);

  const formatTime = (timestamp: string) => {
    return new Date(timestamp).toLocaleTimeString('fr-FR');
  };

  return (
    <div
      ref={containerRef}
      className=""bg-slate-900 rounded-lg p-4 font-mono text-sm overflow-y-auto""
      style={{ maxHeight }}
    >
      {events.length === 0 ? (
        <p className=""text-slate-500"">En attente des evenements...</p>
      ) : (
        events.map((event, index) => (
          <div key={index} className=""flex items-start gap-3 mb-2"">
            <span className=""text-slate-500 shrink-0"">[{formatTime(event.timestamp)}]</span>
            <span className=""text-blue-400"">{event.techniqueId}</span>
            <span className=""text-slate-300"">{event.techniqueName}</span>
            {event.status && <ResultBadge status={event.status} size=""sm"" />}
          </div>
        ))
      )}
    </div>
  );
};
```

**Fichiers:**
- src/components/Execution/LiveLogs.tsx

**Definition of Done:**
- [ ] Zone scrollable avec hauteur max
- [ ] Auto-scroll vers nouveaux logs
- [ ] Format timestamp lisible
- [ ] Style terminal/console
- [ ] Badge status pour chaque event
- [ ] Tests unitaires passes",dashboard;component
"[FE-43] Creer composant ResultBadge",Task,"**Objectif:** Creer un badge affichant le resultat d'une technique avec couleur et icone selon le status.

**Code TSX exemple:**
```tsx
import React from 'react';
import { CheckCircle, AlertTriangle, XCircle, Circle, AlertOctagon } from 'lucide-react';

type ResultStatus = 'success' | 'blocked' | 'detected' | 'failed' | 'untested' | 'error';

interface ResultBadgeProps {
  status: ResultStatus;
  size?: 'sm' | 'md' | 'lg';
  showLabel?: boolean;
}

const STATUS_CONFIG: Record<ResultStatus, { label: string; color: string; icon: React.ElementType }> = {
  blocked: { label: 'Bloque', color: 'bg-green-100 text-green-700', icon: CheckCircle },
  detected: { label: 'Detecte', color: 'bg-amber-100 text-amber-700', icon: AlertTriangle },
  success: { label: 'Succes', color: 'bg-red-100 text-red-700', icon: XCircle },
  failed: { label: 'Echec', color: 'bg-slate-100 text-slate-700', icon: Circle },
  untested: { label: 'Non teste', color: 'bg-slate-100 text-slate-500', icon: Circle },
  error: { label: 'Erreur', color: 'bg-violet-100 text-violet-700', icon: AlertOctagon }
};

const SIZE_CLASSES = {
  sm: 'px-1.5 py-0.5 text-xs',
  md: 'px-2 py-1 text-sm',
  lg: 'px-3 py-1.5 text-base'
};

export const ResultBadge: React.FC<ResultBadgeProps> = ({
  status, size = 'md', showLabel = true
}) => {
  const config = STATUS_CONFIG[status] || STATUS_CONFIG.untested;
  const Icon = config.icon;

  return (
    <span className={`inline-flex items-center gap-1 rounded-full font-medium ${config.color} ${SIZE_CLASSES[size]}`}>
      <Icon className={size === 'sm' ? 'w-3 h-3' : 'w-4 h-4'} />
      {showLabel && <span>{config.label}</span>}
    </span>
  );
};
```

**Fichiers:**
- src/components/Execution/ResultBadge.tsx

**Definition of Done:**
- [ ] 6 status supportes avec couleurs
- [ ] Icones distinctes par status
- [ ] 3 tailles disponibles (sm, md, lg)
- [ ] Option showLabel
- [ ] Accessible (contraste couleurs)
- [ ] Tests unitaires passes",dashboard;component
"[FE-44] Configurer WebSocket client",Task,"**Objectif:** Configurer le client WebSocket avec connexion, reconnexion automatique et gestion des evenements.

**Code TSX exemple:**
```tsx
// src/lib/websocket.ts
export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';

export interface WebSocketConfig {
  url: string;
  reconnectInterval?: number;
  maxReconnectAttempts?: number;
  onMessage?: (event: MessageEvent) => void;
  onStatusChange?: (status: ConnectionStatus) => void;
}

export class WebSocketClient {
  private ws: WebSocket | null = null;
  private config: Required<WebSocketConfig>;
  private reconnectAttempts = 0;
  private reconnectTimeout: NodeJS.Timeout | null = null;

  constructor(config: WebSocketConfig) {
    this.config = {
      reconnectInterval: 3000,
      maxReconnectAttempts: 5,
      onMessage: () => {},
      onStatusChange: () => {},
      ...config
    };
  }

  connect(): void {
    this.config.onStatusChange('connecting');
    this.ws = new WebSocket(this.config.url);

    this.ws.onopen = () => {
      this.reconnectAttempts = 0;
      this.config.onStatusChange('connected');
    };

    this.ws.onmessage = (event) => {
      this.config.onMessage(event);
    };

    this.ws.onclose = () => {
      this.config.onStatusChange('disconnected');
      this.scheduleReconnect();
    };

    this.ws.onerror = () => {
      this.config.onStatusChange('error');
    };
  }

  private scheduleReconnect(): void {
    if (this.reconnectAttempts < this.config.maxReconnectAttempts) {
      this.reconnectTimeout = setTimeout(() => {
        this.reconnectAttempts++;
        this.connect();
      }, this.config.reconnectInterval);
    }
  }

  disconnect(): void {
    if (this.reconnectTimeout) clearTimeout(this.reconnectTimeout);
    this.ws?.close();
  }

  send(data: unknown): void {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify(data));
    }
  }
}
```

**Fichiers:**
- src/lib/websocket.ts
- src/lib/index.ts (export)

**Definition of Done:**
- [ ] Classe WebSocketClient implementee
- [ ] Reconnexion automatique fonctionnelle
- [ ] Callbacks onMessage et onStatusChange
- [ ] Methodes connect, disconnect, send
- [ ] Gestion max tentatives reconnexion
- [ ] Tests unitaires passes",dashboard;websocket
"[FE-45] Creer hook useWebSocket",Task,"**Objectif:** Creer un hook React pour gerer la connexion WebSocket avec state reactif et cleanup automatique.

**Code TSX exemple:**
```tsx
// src/hooks/useWebSocket.ts
import { useState, useEffect, useCallback, useRef } from 'react';
import { WebSocketClient, ConnectionStatus } from '../lib/websocket';

interface UseWebSocketResult {
  lastMessage: MessageEvent | null;
  connectionStatus: ConnectionStatus;
  sendMessage: (data: unknown) => void;
  reconnect: () => void;
}

export const useWebSocket = (url: string): UseWebSocketResult => {
  const [lastMessage, setLastMessage] = useState<MessageEvent | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('disconnected');
  const clientRef = useRef<WebSocketClient | null>(null);

  useEffect(() => {
    const client = new WebSocketClient({
      url,
      onMessage: (event) => setLastMessage(event),
      onStatusChange: (status) => setConnectionStatus(status)
    });

    client.connect();
    clientRef.current = client;

    return () => {
      client.disconnect();
    };
  }, [url]);

  const sendMessage = useCallback((data: unknown) => {
    clientRef.current?.send(data);
  }, []);

  const reconnect = useCallback(() => {
    clientRef.current?.disconnect();
    clientRef.current?.connect();
  }, []);

  return { lastMessage, connectionStatus, sendMessage, reconnect };
};

// Hook specialise pour les events d'execution
export const useExecutionWebSocket = (executionId: string) => {
  const url = `wss://${window.location.host}/ws/execution/${executionId}`;
  return useWebSocket(url);
};

// Hook specialise pour les events agents
export const useAgentsWebSocket = () => {
  const url = `wss://${window.location.host}/ws/agents`;
  return useWebSocket(url);
};
```

**Fichiers:**
- src/hooks/useWebSocket.ts

**Definition of Done:**
- [ ] Hook useWebSocket fonctionnel
- [ ] State lastMessage reactif
- [ ] State connectionStatus reactif
- [ ] Cleanup sur unmount
- [ ] Fonctions sendMessage et reconnect
- [ ] Hooks specialises (execution, agents)
- [ ] Tests unitaires passes",dashboard;hook
"[FE-46] Creer hook useAgents",Task,"**Objectif:** Creer un hook React pour fetch et gerer l'etat des agents avec mise a jour temps reel via WebSocket.

**Code TSX exemple:**
```tsx
// src/hooks/useAgents.ts
import { useState, useEffect, useCallback } from 'react';
import { useAgentsWebSocket } from './useWebSocket';
import { api } from '../lib/api';

export interface Agent {
  paw: string;
  hostname: string;
  platform: 'windows' | 'linux' | 'darwin';
  status: 'online' | 'offline';
  lastSeen: string;
  ip: string;
  username: string;
}

interface UseAgentsResult {
  agents: Agent[];
  isLoading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
  onlineCount: number;
  offlineCount: number;
}

export const useAgents = (): UseAgentsResult => {
  const [agents, setAgents] = useState<Agent[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { lastMessage } = useAgentsWebSocket();

  const fetchAgents = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await api.get<Agent[]>('/api/agents');
      setAgents(response.data);
      setError(null);
    } catch (err) {
      setError('Erreur lors du chargement des agents');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchAgents();
  }, [fetchAgents]);

  useEffect(() => {
    if (lastMessage) {
      const event = JSON.parse(lastMessage.data);
      if (event.type === 'agent_connected' || event.type === 'agent_disconnected') {
        setAgents(prev => prev.map(a =>
          a.paw === event.payload.paw
            ? { ...a, status: event.type === 'agent_connected' ? 'online' : 'offline' }
            : a
        ));
      }
    }
  }, [lastMessage]);

  return {
    agents,
    isLoading,
    error,
    refetch: fetchAgents,
    onlineCount: agents.filter(a => a.status === 'online').length,
    offlineCount: agents.filter(a => a.status === 'offline').length
  };
};
```

**Fichiers:**
- src/hooks/useAgents.ts

**Definition of Done:**
- [ ] Fetch initial des agents
- [ ] Mise a jour temps reel via WebSocket
- [ ] States isLoading et error
- [ ] Fonction refetch disponible
- [ ] Compteurs online/offline calcules
- [ ] Types Agent exportes
- [ ] Tests unitaires passes",dashboard;hook
"[FE-47] Creer hook useScenarios",Task,"**Objectif:** Creer un hook React pour fetch et gerer l'etat des scenarios avec filtres et actions CRUD.

**Code TSX exemple:**
```tsx
// src/hooks/useScenarios.ts
import { useState, useEffect, useCallback } from 'react';
import { api } from '../lib/api';

export interface Scenario {
  id: string;
  name: string;
  description: string;
  techniques: string[];
  createdAt: string;
  updatedAt: string;
  isDefault: boolean;
}

interface UseScenariosResult {
  scenarios: Scenario[];
  isLoading: boolean;
  error: string | null;
  refetch: () => Promise<void>;
  createScenario: (data: Partial<Scenario>) => Promise<Scenario>;
  deleteScenario: (id: string) => Promise<void>;
  executeScenario: (id: string, agentPaws: string[]) => Promise<string>;
}

export const useScenarios = (): UseScenariosResult => {
  const [scenarios, setScenarios] = useState<Scenario[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchScenarios = useCallback(async () => {
    try {
      setIsLoading(true);
      const response = await api.get<Scenario[]>('/api/scenarios');
      setScenarios(response.data);
      setError(null);
    } catch (err) {
      setError('Erreur lors du chargement des scenarios');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchScenarios();
  }, [fetchScenarios]);

  const createScenario = async (data: Partial<Scenario>): Promise<Scenario> => {
    const response = await api.post<Scenario>('/api/scenarios', data);
    setScenarios(prev => [...prev, response.data]);
    return response.data;
  };

  const deleteScenario = async (id: string): Promise<void> => {
    await api.delete(`/api/scenarios/${id}`);
    setScenarios(prev => prev.filter(s => s.id !== id));
  };

  const executeScenario = async (id: string, agentPaws: string[]): Promise<string> => {
    const response = await api.post<{ executionId: string }>(`/api/scenarios/${id}/execute`, { agentPaws });
    return response.data.executionId;
  };

  return { scenarios, isLoading, error, refetch: fetchScenarios, createScenario, deleteScenario, executeScenario };
};
```

**Fichiers:**
- src/hooks/useScenarios.ts

**Definition of Done:**
- [ ] Fetch initial des scenarios
- [ ] CRUD operations (create, delete)
- [ ] Fonction executeScenario
- [ ] States isLoading et error
- [ ] Types Scenario exportes
- [ ] Tests unitaires passes",dashboard;hook
"[FE-48] Creer hook useExecution",Task,"**Objectif:** Creer un hook React pour monitorer une execution en temps reel avec progression, resultats et logs.

**Code TSX exemple:**
```tsx
// src/hooks/useExecution.ts
import { useState, useEffect, useCallback } from 'react';
import { useExecutionWebSocket } from './useWebSocket';
import { api } from '../lib/api';

export interface Execution {
  id: string;
  scenarioId: string;
  scenarioName: string;
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  progress: { current: number; total: number };
  results: ExecutionResult[];
  startedAt: string;
  completedAt?: string;
}

export interface ExecutionResult {
  techniqueId: string;
  techniqueName: string;
  agentPaw: string;
  status: string;
  output: string;
  duration: number;
  timestamp: string;
}

interface UseExecutionResult {
  execution: Execution | null;
  isLoading: boolean;
  error: string | null;
  cancel: () => Promise<void>;
}

export const useExecution = (executionId?: string): UseExecutionResult => {
  const [execution, setExecution] = useState<Execution | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const { lastMessage } = useExecutionWebSocket(executionId || '');

  useEffect(() => {
    if (!executionId) return;

    const fetchExecution = async () => {
      try {
        const response = await api.get<Execution>(`/api/executions/${executionId}`);
        setExecution(response.data);
      } catch (err) {
        setError('Erreur chargement execution');
      } finally {
        setIsLoading(false);
      }
    };

    fetchExecution();
  }, [executionId]);

  useEffect(() => {
    if (lastMessage && execution) {
      const event = JSON.parse(lastMessage.data);
      // Mise a jour selon type event
      if (event.type === 'technique_complete') {
        setExecution(prev => prev ? {
          ...prev,
          progress: { ...prev.progress, current: prev.progress.current + 1 },
          results: [...prev.results, event.payload]
        } : null);
      }
    }
  }, [lastMessage, execution]);

  const cancel = useCallback(async () => {
    if (executionId) {
      await api.post(`/api/executions/${executionId}/cancel`);
    }
  }, [executionId]);

  return { execution, isLoading, error, cancel };
};
```

**Fichiers:**
- src/hooks/useExecution.ts

**Definition of Done:**
- [ ] Fetch execution par ID
- [ ] Mise a jour temps reel via WebSocket
- [ ] Progression calculee
- [ ] Resultats accumules
- [ ] Fonction cancel
- [ ] Types Execution exportes
- [ ] Tests unitaires passes",dashboard;hook
"[FE-49] Creer page Reports",Task,"**Objectif:** Creer la page de rapports affichant le score de securite, la couverture MITRE et les options d'export.

**Code TSX exemple:**
```tsx
import React, { useState } from 'react';
import { SecurityScore } from '../components/Reports/SecurityScore';
import { CoverageReport } from '../components/Reports/CoverageReport';
import { ExportPDF } from '../components/Reports/ExportPDF';
import { useScenarios } from '../hooks/useScenarios';
import { DateRangePicker } from '../components/ui/DateRangePicker';

export const ReportsPage: React.FC = () => {
  const { techniques, results, isLoading } = useScenarios();
  const [dateRange, setDateRange] = useState({ from: null, to: null });

  if (isLoading) return <Spinner />;

  return (
    <div className=""container mx-auto p-6"">
      <div className=""flex items-center justify-between mb-6"">
        <h1 className=""text-2xl font-bold"">Rapports de Securite</h1>
        <div className=""flex gap-4"">
          <DateRangePicker value={dateRange} onChange={setDateRange} />
          <ExportPDF results={results} techniques={techniques} />
        </div>
      </div>

      <div className=""grid grid-cols-1 lg:grid-cols-3 gap-6"">
        <div className=""lg:col-span-1"">
          <SecurityScore results={results} totalTechniques={techniques.length} />
        </div>
        <div className=""lg:col-span-2"">
          <CoverageReport techniques={techniques} results={results} />
        </div>
      </div>

      <div className=""mt-6"">
        <TrendChart results={results} dateRange={dateRange} />
      </div>
    </div>
  );
};
```

**Fichiers:**
- src/pages/ReportsPage.tsx
- src/routes/index.tsx (ajout route /reports)

**Definition of Done:**
- [ ] Page accessible via /reports
- [ ] Score de securite affiche
- [ ] Rapport couverture affiche
- [ ] Filtre par date fonctionnel
- [ ] Export PDF disponible
- [ ] Layout responsive
- [ ] Tests unitaires passes",dashboard;page
"[FE-50] Creer composant SecurityScore",Task,"**Objectif:** Creer un composant gauge affichant le score de securite 0-100 avec couleur selon niveau et tendance.

**Code TSX exemple:**
```tsx
import React, { useMemo } from 'react';
import { TrendingUp, TrendingDown, Minus } from 'lucide-react';
import { ExecutionResult } from '../../types';

interface SecurityScoreProps {
  results: ExecutionResult[];
  totalTechniques: number;
  previousScore?: number;
}

export const SecurityScore: React.FC<SecurityScoreProps> = ({
  results, totalTechniques, previousScore
}) => {
  const score = useMemo(() => {
    if (results.length === 0) return 0;
    const blocked = results.filter(r => r.status === 'blocked').length;
    const detected = results.filter(r => r.status === 'detected').length;
    const points = (blocked * 100) + (detected * 50);
    return Math.round((points / (results.length * 100)) * 100);
  }, [results]);

  const getScoreColor = (s: number) => {
    if (s >= 80) return 'text-green-500';
    if (s >= 60) return 'text-yellow-500';
    if (s >= 40) return 'text-orange-500';
    return 'text-red-500';
  };

  const trend = previousScore !== undefined ? score - previousScore : 0;

  return (
    <div className=""bg-white rounded-xl shadow-lg p-6"">
      <h2 className=""text-lg font-semibold text-gray-700 mb-4"">Score de Securite</h2>
      <div className=""flex items-center justify-center"">
        <div className=""relative"">
          <svg className=""w-32 h-32 transform -rotate-90"">
            <circle cx=""64"" cy=""64"" r=""56"" stroke=""#e5e7eb"" strokeWidth=""12"" fill=""none"" />
            <circle cx=""64"" cy=""64"" r=""56"" stroke=""currentColor"" strokeWidth=""12"" fill=""none""
              className={getScoreColor(score)}
              strokeDasharray={`${(score / 100) * 352} 352`} strokeLinecap=""round"" />
          </svg>
          <div className=""absolute inset-0 flex flex-col items-center justify-center"">
            <span className={`text-3xl font-bold ${getScoreColor(score)}`}>{score}%</span>
            {trend !== 0 && (
              <span className={`flex items-center text-sm ${trend > 0 ? 'text-green-500' : 'text-red-500'}`}>
                {trend > 0 ? <TrendingUp className=""w-4 h-4"" /> : <TrendingDown className=""w-4 h-4"" />}
                {Math.abs(trend)}%
              </span>
            )}
          </div>
        </div>
      </div>
      <p className=""text-center text-sm text-gray-400 mt-4"">{results.length} / {totalTechniques} testees</p>
    </div>
  );
};
```

**Fichiers:**
- src/components/Reports/SecurityScore.tsx

**Definition of Done:**
- [ ] Gauge circulaire SVG
- [ ] Score calcule correctement
- [ ] Couleur selon niveau (vert/jaune/orange/rouge)
- [ ] Affichage tendance si previousScore fourni
- [ ] Nombre techniques testees affiche
- [ ] Tests unitaires passes",dashboard;component
"[FE-51] Creer composant CoverageReport",Task,"**Objectif:** Creer un rapport de couverture MITRE affichant le pourcentage par tactic avec barres de progression.

**Code TSX exemple:**
```tsx
import React, { useMemo } from 'react';
import { Technique, ExecutionResult } from '../../types';

interface CoverageReportProps {
  techniques: Technique[];
  results: ExecutionResult[];
}

const TACTICS = [
  'reconnaissance', 'initial-access', 'execution', 'persistence',
  'privilege-escalation', 'defense-evasion', 'credential-access',
  'discovery', 'lateral-movement', 'collection', 'exfiltration', 'impact'
];

export const CoverageReport: React.FC<CoverageReportProps> = ({ techniques, results }) => {
  const coverageByTactic = useMemo(() => {
    return TACTICS.map(tactic => {
      const tacticTechniques = techniques.filter(t => t.tactic === tactic);
      const testedIds = new Set(results.map(r => r.techniqueId));
      const tested = tacticTechniques.filter(t => testedIds.has(t.id)).length;
      const total = tacticTechniques.length;
      const percentage = total > 0 ? Math.round((tested / total) * 100) : 0;
      return { tactic, tested, total, percentage };
    });
  }, [techniques, results]);

  const getCoverageColor = (pct: number) => {
    if (pct >= 75) return 'bg-green-500';
    if (pct >= 50) return 'bg-yellow-500';
    if (pct >= 25) return 'bg-orange-500';
    return 'bg-red-500';
  };

  return (
    <div className=""bg-white rounded-xl shadow-lg p-6"">
      <h2 className=""text-lg font-semibold text-gray-700 mb-4"">Couverture par Tactic</h2>
      <div className=""space-y-3"">
        {coverageByTactic.map(({ tactic, tested, total, percentage }) => (
          <div key={tactic}>
            <div className=""flex justify-between text-sm mb-1"">
              <span className=""capitalize"">{tactic.replace('-', ' ')}</span>
              <span className=""text-gray-500"">{tested}/{total} ({percentage}%)</span>
            </div>
            <div className=""h-2 bg-gray-200 rounded-full overflow-hidden"">
              <div className={`h-full ${getCoverageColor(percentage)} transition-all`}
                style={{ width: `${percentage}%` }} />
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
```

**Fichiers:**
- src/components/Reports/CoverageReport.tsx

**Definition of Done:**
- [ ] Liste des 12+ tactics MITRE
- [ ] Barre progression par tactic
- [ ] Pourcentage et compteur affiches
- [ ] Couleur selon niveau couverture
- [ ] Tri par couverture optionnel
- [ ] Tests unitaires passes",dashboard;component
"[FE-52] Creer composant ExportPDF",Task,"**Objectif:** Creer un bouton d'export PDF avec options (periode, format, contenu) generant un rapport telechargeable.

**Code TSX exemple:**
```tsx
import React, { useState } from 'react';
import { FileDown, Loader2 } from 'lucide-react';
import { api } from '../../lib/api';

interface ExportPDFProps {
  results: ExecutionResult[];
  techniques: Technique[];
  dateRange?: { from: Date | null; to: Date | null };
}

export const ExportPDF: React.FC<ExportPDFProps> = ({ results, techniques, dateRange }) => {
  const [isExporting, setIsExporting] = useState(false);
  const [showOptions, setShowOptions] = useState(false);
  const [options, setOptions] = useState({
    includeMatrix: true,
    includeDetails: true,
    includeRecommendations: true
  });

  const handleExport = async () => {
    setIsExporting(true);
    try {
      const response = await api.post('/api/reports/export', {
        format: 'pdf',
        dateRange,
        options,
        techniqueIds: techniques.map(t => t.id)
      }, { responseType: 'blob' });

      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.download = `autostrike-report-${new Date().toISOString().split('T')[0]}.pdf`;
      link.click();
      window.URL.revokeObjectURL(url);
    } catch (error) {
      console.error('Export failed:', error);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <div className=""relative"">
      <button
        onClick={() => setShowOptions(!showOptions)}
        className=""flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700""
        disabled={isExporting}
      >
        {isExporting ? <Loader2 className=""w-4 h-4 animate-spin"" /> : <FileDown className=""w-4 h-4"" />}
        Exporter PDF
      </button>
      {showOptions && (
        <div className=""absolute right-0 mt-2 w-64 bg-white rounded-lg shadow-lg p-4 z-10"">
          <label className=""flex items-center gap-2 mb-2"">
            <input type=""checkbox"" checked={options.includeMatrix}
              onChange={e => setOptions(o => ({ ...o, includeMatrix: e.target.checked }))} />
            Inclure matrice MITRE
          </label>
          <button onClick={handleExport} className=""w-full mt-2 px-4 py-2 bg-blue-600 text-white rounded"">
            Telecharger
          </button>
        </div>
      )}
    </div>
  );
};
```

**Fichiers:**
- src/components/Reports/ExportPDF.tsx

**Definition of Done:**
- [ ] Bouton export avec icone
- [ ] Options configurables (matrice, details, recommandations)
- [ ] Appel API pour generation PDF
- [ ] Telechargement automatique du fichier
- [ ] Loading state pendant export
- [ ] Gestion erreur
- [ ] Tests unitaires passes",dashboard;component
"[FE-53] Implementer protected routes",Task,"**Objectif:** Creer un systeme de routes protegees redirigeant vers login si l'utilisateur n'est pas authentifie.

**Code TSX exemple:**
```tsx
// src/components/auth/ProtectedRoute.tsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';

interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRole?: 'viewer' | 'operator' | 'admin';
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({
  children, requiredRole
}) => {
  const { isAuthenticated, user, isLoading } = useAuth();
  const location = useLocation();

  if (isLoading) {
    return <div className=""flex justify-center items-center h-screen""><Spinner /></div>;
  }

  if (!isAuthenticated) {
    return <Navigate to=""/login"" state={{ from: location }} replace />;
  }

  if (requiredRole && user && !hasRequiredRole(user.role, requiredRole)) {
    return <Navigate to=""/unauthorized"" replace />;
  }

  return <>{children}</>;
};

const ROLE_HIERARCHY = ['viewer', 'operator', 'admin'];

function hasRequiredRole(userRole: string, requiredRole: string): boolean {
  return ROLE_HIERARCHY.indexOf(userRole) >= ROLE_HIERARCHY.indexOf(requiredRole);
}

// src/routes/index.tsx
import { ProtectedRoute } from '../components/auth/ProtectedRoute';

export const AppRoutes = () => (
  <Routes>
    <Route path=""/login"" element={<LoginPage />} />
    <Route path=""/"" element={<ProtectedRoute><DashboardLayout /></ProtectedRoute>}>
      <Route index element={<DashboardPage />} />
      <Route path=""agents"" element={<AgentsPage />} />
      <Route path=""scenarios"" element={<ProtectedRoute requiredRole=""operator""><ScenariosPage /></ProtectedRoute>} />
      <Route path=""admin"" element={<ProtectedRoute requiredRole=""admin""><AdminPage /></ProtectedRoute>} />
    </Route>
  </Routes>
);
```

**Fichiers:**
- src/components/auth/ProtectedRoute.tsx
- src/routes/index.tsx
- src/hooks/useAuth.ts

**Definition of Done:**
- [ ] Composant ProtectedRoute cree
- [ ] Redirection vers /login si non authentifie
- [ ] Support des roles (viewer, operator, admin)
- [ ] Hierarchie des roles respectee
- [ ] Loading state pendant verification
- [ ] State from pour redirection post-login
- [ ] Tests unitaires passes",dashboard;auth
"[FE-54] Implementer token storage",Task,"**Objectif:** Gerer le stockage securise du token JWT dans localStorage avec refresh automatique avant expiration.

**Code TSX exemple:**
```tsx
// src/lib/auth.ts
import { jwtDecode } from 'jwt-decode';

const TOKEN_KEY = 'autostrike_token';
const REFRESH_KEY = 'autostrike_refresh';

interface TokenPayload {
  sub: string;
  exp: number;
  role: string;
  username: string;
}

export const tokenStorage = {
  getToken: (): string | null => localStorage.getItem(TOKEN_KEY),
  setToken: (token: string): void => localStorage.setItem(TOKEN_KEY, token),
  removeToken: (): void => localStorage.removeItem(TOKEN_KEY),

  getRefreshToken: (): string | null => localStorage.getItem(REFRESH_KEY),
  setRefreshToken: (token: string): void => localStorage.setItem(REFRESH_KEY, token),
  removeRefreshToken: (): void => localStorage.removeItem(REFRESH_KEY),

  clearAll: (): void => {
    localStorage.removeItem(TOKEN_KEY);
    localStorage.removeItem(REFRESH_KEY);
  },

  isTokenExpired: (): boolean => {
    const token = localStorage.getItem(TOKEN_KEY);
    if (!token) return true;
    try {
      const decoded = jwtDecode<TokenPayload>(token);
      return decoded.exp * 1000 < Date.now();
    } catch {
      return true;
    }
  },

  getTokenPayload: (): TokenPayload | null => {
    const token = localStorage.getItem(TOKEN_KEY);
    if (!token) return null;
    try {
      return jwtDecode<TokenPayload>(token);
    } catch {
      return null;
    }
  },

  shouldRefresh: (): boolean => {
    const token = localStorage.getItem(TOKEN_KEY);
    if (!token) return false;
    try {
      const decoded = jwtDecode<TokenPayload>(token);
      const expiresIn = decoded.exp * 1000 - Date.now();
      return expiresIn < 5 * 60 * 1000; // Refresh si < 5 min
    } catch {
      return false;
    }
  }
};

// Intercepteur Axios pour refresh auto
api.interceptors.response.use(
  response => response,
  async error => {
    if (error.response?.status === 401 && tokenStorage.getRefreshToken()) {
      const newToken = await refreshToken();
      if (newToken) {
        error.config.headers.Authorization = `Bearer ${newToken}`;
        return api.request(error.config);
      }
    }
    return Promise.reject(error);
  }
);
```

**Fichiers:**
- src/lib/auth.ts
- src/lib/api.ts (intercepteur)

**Definition of Done:**
- [ ] Fonctions get/set/remove token
- [ ] Decodage JWT avec jwt-decode
- [ ] Detection expiration token
- [ ] Refresh automatique avant expiration
- [ ] Intercepteur Axios pour 401
- [ ] clearAll pour logout
- [ ] Tests unitaires passes",dashboard;auth
"[FE-55] Creer theme sombre/clair",Task,"**Objectif:** Implementer un toggle theme dark/light avec persistance de la preference utilisateur.

**Code TSX exemple:**
```tsx
// src/contexts/ThemeContext.tsx
import React, { createContext, useContext, useEffect, useState } from 'react';

type Theme = 'light' | 'dark' | 'system';

interface ThemeContextType {
  theme: Theme;
  resolvedTheme: 'light' | 'dark';
  setTheme: (theme: Theme) => void;
  toggleTheme: () => void;
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined);

export const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setThemeState] = useState<Theme>(() => {
    const stored = localStorage.getItem('theme') as Theme;
    return stored || 'system';
  });

  const [resolvedTheme, setResolvedTheme] = useState<'light' | 'dark'>('light');

  useEffect(() => {
    const root = document.documentElement;
    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');

    const updateTheme = () => {
      const isDark = theme === 'dark' || (theme === 'system' && mediaQuery.matches);
      setResolvedTheme(isDark ? 'dark' : 'light');
      root.classList.toggle('dark', isDark);
    };

    updateTheme();
    mediaQuery.addEventListener('change', updateTheme);
    return () => mediaQuery.removeEventListener('change', updateTheme);
  }, [theme]);

  const setTheme = (newTheme: Theme) => {
    setThemeState(newTheme);
    localStorage.setItem('theme', newTheme);
  };

  const toggleTheme = () => {
    setTheme(resolvedTheme === 'light' ? 'dark' : 'light');
  };

  return (
    <ThemeContext.Provider value={{ theme, resolvedTheme, setTheme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) throw new Error('useTheme must be used within ThemeProvider');
  return context;
};

// Composant Toggle
export const ThemeToggle: React.FC = () => {
  const { resolvedTheme, toggleTheme } = useTheme();
  return (
    <button onClick={toggleTheme} className=""p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800"">
      {resolvedTheme === 'light' ? <Moon className=""w-5 h-5"" /> : <Sun className=""w-5 h-5"" />}
    </button>
  );
};
```

**Fichiers:**
- src/contexts/ThemeContext.tsx
- src/components/ui/ThemeToggle.tsx
- tailwind.config.js (darkMode: 'class')

**Definition of Done:**
- [ ] Context ThemeProvider cree
- [ ] Support light/dark/system
- [ ] Persistance localStorage
- [ ] Respect preference systeme
- [ ] Composant ThemeToggle
- [ ] Classes Tailwind dark: fonctionnelles
- [ ] Tests unitaires passes",dashboard;ui
"[FE-56] Implementer responsive design",Task,"**Objectif:** Adapter tous les composants pour mobile, tablet et desktop avec breakpoints Tailwind.

**Code TSX exemple:**
```tsx
// src/components/layout/DashboardLayout.tsx
import React, { useState } from 'react';
import { Menu, X } from 'lucide-react';
import { Sidebar } from './Sidebar';
import { Header } from './Header';

export const DashboardLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [sidebarOpen, setSidebarOpen] = useState(false);

  return (
    <div className=""min-h-screen bg-gray-50 dark:bg-gray-900"">
      {/* Mobile sidebar overlay */}
      {sidebarOpen && (
        <div
          className=""fixed inset-0 z-40 bg-black/50 lg:hidden""
          onClick={() => setSidebarOpen(false)}
        />
      )}

      {/* Sidebar */}
      <aside className={`
        fixed inset-y-0 left-0 z-50 w-64 bg-white dark:bg-gray-800 transform transition-transform
        lg:translate-x-0 lg:static lg:z-auto
        ${sidebarOpen ? 'translate-x-0' : '-translate-x-full'}
      `}>
        <Sidebar onClose={() => setSidebarOpen(false)} />
      </aside>

      {/* Main content */}
      <div className=""lg:pl-64"">
        <Header onMenuClick={() => setSidebarOpen(true)} />
        <main className=""p-4 sm:p-6 lg:p-8"">
          {children}
        </main>
      </div>
    </div>
  );
};

// Breakpoints utilises:
// sm: 640px - Mobile large
// md: 768px - Tablet
// lg: 1024px - Desktop
// xl: 1280px - Large desktop

// Exemple grille responsive
<div className=""grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"">
  {items.map(item => <Card key={item.id} {...item} />)}
</div>
```

**Fichiers:**
- src/components/layout/DashboardLayout.tsx
- src/components/layout/Sidebar.tsx
- src/components/layout/Header.tsx
- Tous les composants (ajout classes responsive)

**Definition of Done:**
- [ ] Sidebar collapsible sur mobile
- [ ] Menu hamburger fonctionnel
- [ ] Grilles adaptatives (1->2->3->4 cols)
- [ ] Padding/margin responsifs
- [ ] Texte lisible sur tous ecrans
- [ ] Touch targets 44px minimum
- [ ] Tests sur emulateurs mobile
- [ ] Tests unitaires passes",dashboard;ui
"[FE-57] Creer composant NotificationToast",Task,"**Objectif:** Creer un systeme de toasts pour afficher les notifications de feedback utilisateur (succes, erreur, info, warning).

**Code TSX exemple:**
```tsx
// src/components/ui/NotificationToast.tsx
import React, { useEffect } from 'react';
import { CheckCircle, XCircle, AlertTriangle, Info, X } from 'lucide-react';
import { create } from 'zustand';

type ToastType = 'success' | 'error' | 'warning' | 'info';

interface Toast {
  id: string;
  type: ToastType;
  title: string;
  message?: string;
  duration?: number;
}

interface ToastStore {
  toasts: Toast[];
  addToast: (toast: Omit<Toast, 'id'>) => void;
  removeToast: (id: string) => void;
}

export const useToastStore = create<ToastStore>((set) => ({
  toasts: [],
  addToast: (toast) => set((state) => ({
    toasts: [...state.toasts, { ...toast, id: crypto.randomUUID() }]
  })),
  removeToast: (id) => set((state) => ({
    toasts: state.toasts.filter(t => t.id !== id)
  }))
}));

const ICONS: Record<ToastType, React.ElementType> = {
  success: CheckCircle,
  error: XCircle,
  warning: AlertTriangle,
  info: Info
};

const COLORS: Record<ToastType, string> = {
  success: 'bg-green-50 border-green-500 text-green-800',
  error: 'bg-red-50 border-red-500 text-red-800',
  warning: 'bg-amber-50 border-amber-500 text-amber-800',
  info: 'bg-blue-50 border-blue-500 text-blue-800'
};

export const ToastContainer: React.FC = () => {
  const { toasts, removeToast } = useToastStore();

  return (
    <div className=""fixed bottom-4 right-4 z-50 flex flex-col gap-2"">
      {toasts.map(toast => (
        <ToastItem key={toast.id} toast={toast} onClose={() => removeToast(toast.id)} />
      ))}
    </div>
  );
};

const ToastItem: React.FC<{ toast: Toast; onClose: () => void }> = ({ toast, onClose }) => {
  const Icon = ICONS[toast.type];

  useEffect(() => {
    const timer = setTimeout(onClose, toast.duration || 5000);
    return () => clearTimeout(timer);
  }, [toast.duration, onClose]);

  return (
    <div className={`flex items-start gap-3 p-4 rounded-lg border-l-4 shadow-lg ${COLORS[toast.type]} animate-slide-in`}>
      <Icon className=""w-5 h-5 shrink-0"" />
      <div className=""flex-1"">
        <p className=""font-medium"">{toast.title}</p>
        {toast.message && <p className=""text-sm opacity-80"">{toast.message}</p>}
      </div>
      <button onClick={onClose}><X className=""w-4 h-4"" /></button>
    </div>
  );
};

// Helper
export const toast = {
  success: (title: string, message?: string) => useToastStore.getState().addToast({ type: 'success', title, message }),
  error: (title: string, message?: string) => useToastStore.getState().addToast({ type: 'error', title, message }),
  warning: (title: string, message?: string) => useToastStore.getState().addToast({ type: 'warning', title, message }),
  info: (title: string, message?: string) => useToastStore.getState().addToast({ type: 'info', title, message })
};
```

**Fichiers:**
- src/components/ui/NotificationToast.tsx
- src/components/ui/ToastContainer.tsx
- src/styles/animations.css (slide-in)

**Definition of Done:**
- [ ] 4 types de toast (success, error, warning, info)
- [ ] Auto-dismiss apres duration
- [ ] Bouton fermeture manuelle
- [ ] Animation entree/sortie
- [ ] Store Zustand pour state global
- [ ] Helper toast.success/error/etc
- [ ] Tests unitaires passes",dashboard;ui
"[FE-58] Creer composant ConfirmModal",Task,"**Objectif:** Creer une modal de confirmation pour les actions destructives avec titre, message et boutons confirmer/annuler.

**Code TSX exemple:**
```tsx
// src/components/ui/ConfirmModal.tsx
import React, { useEffect, useRef } from 'react';
import { AlertTriangle, X } from 'lucide-react';
import { createPortal } from 'react-dom';

interface ConfirmModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConfirm: () => void;
  title: string;
  message: string;
  confirmText?: string;
  cancelText?: string;
  variant?: 'danger' | 'warning' | 'info';
  isLoading?: boolean;
}

const VARIANTS = {
  danger: { icon: 'bg-red-100 text-red-600', button: 'bg-red-600 hover:bg-red-700' },
  warning: { icon: 'bg-amber-100 text-amber-600', button: 'bg-amber-600 hover:bg-amber-700' },
  info: { icon: 'bg-blue-100 text-blue-600', button: 'bg-blue-600 hover:bg-blue-700' }
};

export const ConfirmModal: React.FC<ConfirmModalProps> = ({
  isOpen, onClose, onConfirm, title, message,
  confirmText = 'Confirmer', cancelText = 'Annuler',
  variant = 'danger', isLoading = false
}) => {
  const confirmRef = useRef<HTMLButtonElement>(null);

  useEffect(() => {
    if (isOpen) {
      confirmRef.current?.focus();
      document.body.style.overflow = 'hidden';
    }
    return () => { document.body.style.overflow = ''; };
  }, [isOpen]);

  useEffect(() => {
    const handleEsc = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) onClose();
    };
    window.addEventListener('keydown', handleEsc);
    return () => window.removeEventListener('keydown', handleEsc);
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  const styles = VARIANTS[variant];

  return createPortal(
    <div className=""fixed inset-0 z-50 flex items-center justify-center"">
      <div className=""absolute inset-0 bg-black/50"" onClick={onClose} />
      <div className=""relative bg-white rounded-xl shadow-2xl max-w-md w-full mx-4 p-6"" role=""dialog"" aria-modal=""true"">
        <button onClick={onClose} className=""absolute top-4 right-4""><X className=""w-5 h-5"" /></button>

        <div className=""flex items-start gap-4"">
          <div className={`p-3 rounded-full ${styles.icon}`}>
            <AlertTriangle className=""w-6 h-6"" />
          </div>
          <div>
            <h2 className=""text-lg font-semibold"">{title}</h2>
            <p className=""mt-2 text-gray-600"">{message}</p>
          </div>
        </div>

        <div className=""mt-6 flex justify-end gap-3"">
          <button onClick={onClose} className=""px-4 py-2 border rounded-lg hover:bg-gray-50"">{cancelText}</button>
          <button ref={confirmRef} onClick={onConfirm} disabled={isLoading}
            className={`px-4 py-2 text-white rounded-lg ${styles.button} disabled:opacity-50`}>
            {isLoading ? 'Chargement...' : confirmText}
          </button>
        </div>
      </div>
    </div>,
    document.body
  );
};

// Hook helper
export const useConfirmModal = () => {
  const [state, setState] = React.useState<{ isOpen: boolean; props: Partial<ConfirmModalProps> }>({
    isOpen: false, props: {}
  });

  const confirm = (props: Omit<ConfirmModalProps, 'isOpen' | 'onClose' | 'onConfirm'>): Promise<boolean> => {
    return new Promise((resolve) => {
      setState({
        isOpen: true,
        props: {
          ...props,
          onConfirm: () => { setState(s => ({ ...s, isOpen: false })); resolve(true); },
          onClose: () => { setState(s => ({ ...s, isOpen: false })); resolve(false); }
        }
      });
    });
  };

  return { confirm, Modal: () => <ConfirmModal isOpen={state.isOpen} {...state.props as ConfirmModalProps} /> };
};
```

**Fichiers:**
- src/components/ui/ConfirmModal.tsx
- src/hooks/useConfirmModal.ts

**Definition of Done:**
- [ ] Modal avec overlay
- [ ] 3 variants (danger, warning, info)
- [ ] Fermeture Escape et clic overlay
- [ ] Focus trap sur boutons
- [ ] Loading state sur confirm
- [ ] Portal vers document.body
- [ ] Hook useConfirmModal
- [ ] Accessible (role dialog, aria-modal)
- [ ] Tests unitaires passes",dashboard;ui
"[TEST-01] Configurer tests unitaires Go",Task,"**Objectif:** Mettre en place l'infrastructure de tests unitaires pour le backend Go avec coverage >70%.

**Commandes:**
```bash
# Initialiser les tests
go test ./... -v
go test ./... -cover
go test ./... -coverprofile=coverage.out
go tool cover -html=coverage.out -o coverage.html

# Installer testify pour les assertions
go get github.com/stretchr/testify
```

**Structure fichiers:**
- server/internal/domain/*_test.go
- server/internal/application/services/*_test.go
- server/internal/infrastructure/repositories/*_test.go
- server/pkg/testutil/mocks.go

**Exemple code:**
```go
// server/pkg/testutil/mocks.go
package testutil

import (
    ""github.com/stretchr/testify/mock""
    ""autostrike/internal/domain""
)

type MockAgentRepository struct {
    mock.Mock
}

func (m *MockAgentRepository) FindByID(id string) (*domain.Agent, error) {
    args := m.Called(id)
    return args.Get(0).(*domain.Agent), args.Error(1)
}
```

**Definition of Done:**
[ ] go test ./... passe sans erreur
[ ] Coverage global >70%
[ ] Mocks créés pour repositories
[ ] CI intégré avec rapport coverage
[ ] Documentation tests dans README",test;backend
"[TEST-02] Tests AgentService",Task,"**Objectif:** Tester toutes les fonctions CRUD et validation du service Agent.

**Commandes:**
```bash
go test -v ./internal/application/services/agent_service_test.go
go test -cover -coverprofile=agent_coverage.out ./internal/application/services/
```

**Fichiers:**
- server/internal/application/services/agent_service.go
- server/internal/application/services/agent_service_test.go

**Exemple code:**
```go
// agent_service_test.go
package services_test

import (
    ""testing""
    ""github.com/stretchr/testify/assert""
    ""github.com/stretchr/testify/mock""
)

func TestAgentService_Register(t *testing.T) {
    mockRepo := new(MockAgentRepository)
    service := NewAgentService(mockRepo)

    agent := &domain.Agent{
        Hostname: ""test-host"",
        OS: ""windows"",
        Platform: ""x64"",
    }

    mockRepo.On(""Create"", mock.Anything).Return(nil)

    result, err := service.Register(agent)

    assert.NoError(t, err)
    assert.NotEmpty(t, result.Paw)
    assert.Equal(t, ""online"", result.Status)
    mockRepo.AssertExpectations(t)
}

func TestAgentService_Heartbeat(t *testing.T) {
    mockRepo := new(MockAgentRepository)
    service := NewAgentService(mockRepo)

    mockRepo.On(""FindByPaw"", ""agent-001"").Return(&domain.Agent{Paw: ""agent-001""}, nil)
    mockRepo.On(""Update"", mock.Anything).Return(nil)

    err := service.Heartbeat(""agent-001"")

    assert.NoError(t, err)
}

func TestAgentService_Register_InvalidHostname(t *testing.T) {
    service := NewAgentService(nil)
    agent := &domain.Agent{Hostname: """"}

    _, err := service.Register(agent)

    assert.Error(t, err)
    assert.Contains(t, err.Error(), ""hostname required"")
}
```

**Definition of Done:**
[ ] Tests Register agent (succès et erreurs)
[ ] Tests Heartbeat
[ ] Tests GetAll, GetByPaw
[ ] Tests Delete agent
[ ] Coverage AgentService >80%",test;backend
"[TEST-03] Tests TechniqueService",Task,"**Objectif:** Tester l'import YAML et la recherche de techniques MITRE.

**Commandes:**
```bash
go test -v ./internal/application/services/technique_service_test.go
```

**Fichiers:**
- server/internal/application/services/technique_service.go
- server/internal/application/services/technique_service_test.go
- server/testdata/techniques/*.yaml (fixtures)

**Exemple code:**
```go
// technique_service_test.go
func TestTechniqueService_ImportFromYAML(t *testing.T) {
    mockRepo := new(MockTechniqueRepository)
    service := NewTechniqueService(mockRepo)

    yamlContent := `
id: T1082
name: System Information Discovery
tactic: discovery
platforms:
  - windows
  - linux
`

    mockRepo.On(""Create"", mock.Anything).Return(nil)

    tech, err := service.ImportFromYAML([]byte(yamlContent))

    assert.NoError(t, err)
    assert.Equal(t, ""T1082"", tech.ID)
    assert.Contains(t, tech.Platforms, ""windows"")
}

func TestTechniqueService_Search(t *testing.T) {
    mockRepo := new(MockTechniqueRepository)
    service := NewTechniqueService(mockRepo)

    techniques := []*domain.Technique{
        {ID: ""T1082"", Name: ""System Info"", Tactic: ""discovery""},
        {ID: ""T1083"", Name: ""File Discovery"", Tactic: ""discovery""},
    }

    mockRepo.On(""FindByTactic"", ""discovery"").Return(techniques, nil)

    results, err := service.Search(TechniqueFilter{Tactic: ""discovery""})

    assert.NoError(t, err)
    assert.Len(t, results, 2)
}
```

**Definition of Done:**
[ ] Tests import YAML valide
[ ] Tests import YAML invalide (erreur parsing)
[ ] Tests recherche par tactic
[ ] Tests recherche par platform
[ ] Tests GetByID
[ ] Coverage TechniqueService >80%",test;backend
"[TEST-04] Tests ScenarioService",Task,"**Objectif:** Tester la création, modification et validation des scénarios.

**Commandes:**
```bash
go test -v ./internal/application/services/scenario_service_test.go
```

**Fichiers:**
- server/internal/application/services/scenario_service.go
- server/internal/application/services/scenario_service_test.go

**Exemple code:**
```go
// scenario_service_test.go
func TestScenarioService_Create(t *testing.T) {
    mockRepo := new(MockScenarioRepository)
    mockTechRepo := new(MockTechniqueRepository)
    service := NewScenarioService(mockRepo, mockTechRepo)

    scenario := &domain.Scenario{
        Name: ""Discovery Test"",
        Description: ""Test all discovery techniques"",
        TechniqueIDs: []string{""T1082"", ""T1083""},
    }

    mockTechRepo.On(""FindByIDs"", []string{""T1082"", ""T1083""}).Return([]*domain.Technique{
        {ID: ""T1082""}, {ID: ""T1083""},
    }, nil)
    mockRepo.On(""Create"", mock.Anything).Return(nil)

    result, err := service.Create(scenario)

    assert.NoError(t, err)
    assert.NotEmpty(t, result.ID)
}

func TestScenarioService_Create_InvalidTechnique(t *testing.T) {
    mockRepo := new(MockScenarioRepository)
    mockTechRepo := new(MockTechniqueRepository)
    service := NewScenarioService(mockRepo, mockTechRepo)

    scenario := &domain.Scenario{
        Name: ""Test"",
        TechniqueIDs: []string{""T9999""},  // N'existe pas
    }

    mockTechRepo.On(""FindByIDs"", []string{""T9999""}).Return([]*domain.Technique{}, nil)

    _, err := service.Create(scenario)

    assert.Error(t, err)
    assert.Contains(t, err.Error(), ""technique not found"")
}

func TestScenarioService_AddTechnique(t *testing.T) {
    // Test ajout technique à un scénario existant
}
```

**Definition of Done:**
[ ] Tests Create scenario
[ ] Tests Update scenario
[ ] Tests Delete scenario
[ ] Tests AddTechnique/RemoveTechnique
[ ] Tests validation (techniques valides)
[ ] Coverage ScenarioService >80%",test;backend
"[TEST-05] Tests ExecutionService",Task,"**Objectif:** Tester le cycle de vie complet d'une exécution (start, progress, stop, results).

**Commandes:**
```bash
go test -v ./internal/application/services/execution_service_test.go
```

**Fichiers:**
- server/internal/application/services/execution_service.go
- server/internal/application/services/execution_service_test.go

**Exemple code:**
```go
// execution_service_test.go
func TestExecutionService_Start(t *testing.T) {
    mockRepo := new(MockExecutionRepository)
    mockScenarioRepo := new(MockScenarioRepository)
    mockAgentRepo := new(MockAgentRepository)
    service := NewExecutionService(mockRepo, mockScenarioRepo, mockAgentRepo)

    request := &ExecuteRequest{
        ScenarioID: ""scenario-001"",
        AgentPaws: []string{""agent-001""},
        SafeMode: true,
    }

    mockScenarioRepo.On(""FindByID"", ""scenario-001"").Return(&domain.Scenario{}, nil)
    mockAgentRepo.On(""FindByPaws"", []string{""agent-001""}).Return([]*domain.Agent{
        {Paw: ""agent-001"", Status: ""online""},
    }, nil)
    mockRepo.On(""Create"", mock.Anything).Return(nil)

    exec, err := service.Start(request)

    assert.NoError(t, err)
    assert.Equal(t, ""pending"", exec.Status)
}

func TestExecutionService_Stop(t *testing.T) {
    mockRepo := new(MockExecutionRepository)
    service := NewExecutionService(mockRepo, nil, nil)

    mockRepo.On(""FindByID"", ""exec-001"").Return(&domain.Execution{
        ID: ""exec-001"",
        Status: ""running"",
    }, nil)
    mockRepo.On(""Update"", mock.Anything).Return(nil)

    err := service.Stop(""exec-001"")

    assert.NoError(t, err)
}

func TestExecutionService_RecordResult(t *testing.T) {
    // Test enregistrement résultat technique
}
```

**Definition of Done:**
[ ] Tests Start execution
[ ] Tests Stop execution
[ ] Tests RecordResult (detected/blocked/missed)
[ ] Tests calcul progress
[ ] Tests avec agents offline
[ ] Coverage ExecutionService >80%",test;backend
"[TEST-06] Tests AttackOrchestrator",Task,"**Objectif:** Tester la logique d'orchestration des attaques (planification, sélection agents).

**Commandes:**
```bash
go test -v ./internal/application/orchestrator/*_test.go
```

**Fichiers:**
- server/internal/application/orchestrator/attack_orchestrator.go
- server/internal/application/orchestrator/attack_orchestrator_test.go

**Exemple code:**
```go
// attack_orchestrator_test.go
func TestOrchestrator_PlanExecution(t *testing.T) {
    orchestrator := NewAttackOrchestrator()

    scenario := &domain.Scenario{
        Techniques: []*domain.Technique{
            {ID: ""T1082"", Platforms: []string{""windows""}},
            {ID: ""T1016"", Platforms: []string{""windows"", ""linux""}},
        },
    }

    agents := []*domain.Agent{
        {Paw: ""win-agent"", OS: ""windows""},
        {Paw: ""linux-agent"", OS: ""linux""},
    }

    plan := orchestrator.PlanExecution(scenario, agents)

    // T1082 uniquement sur win-agent
    assert.Equal(t, 1, len(plan[""T1082""]))
    assert.Equal(t, ""win-agent"", plan[""T1082""][0].Paw)

    // T1016 sur les deux
    assert.Equal(t, 2, len(plan[""T1016""]))
}

func TestOrchestrator_SelectAgentForTechnique(t *testing.T) {
    // Test sélection agent compatible
}

func TestOrchestrator_HandleAgentOffline(t *testing.T) {
    // Test gestion agent qui passe offline
}
```

**Definition of Done:**
[ ] Tests PlanExecution
[ ] Tests sélection agents par platform
[ ] Tests gestion agents offline pendant exécution
[ ] Tests ordre d'exécution techniques
[ ] Coverage Orchestrator >75%",test;backend
"[TEST-07] Tests handlers REST",Task,"**Objectif:** Tester tous les endpoints API REST avec httptest.

**Commandes:**
```bash
go test -v ./internal/infrastructure/http/handlers/*_test.go
```

**Fichiers:**
- server/internal/infrastructure/http/handlers/agent_handler_test.go
- server/internal/infrastructure/http/handlers/scenario_handler_test.go
- server/internal/infrastructure/http/handlers/execution_handler_test.go

**Exemple code:**
```go
// agent_handler_test.go
package handlers_test

import (
    ""encoding/json""
    ""net/http""
    ""net/http/httptest""
    ""testing""
    ""github.com/gin-gonic/gin""
    ""github.com/stretchr/testify/assert""
)

func TestAgentHandler_GetAll(t *testing.T) {
    gin.SetMode(gin.TestMode)

    mockService := new(MockAgentService)
    handler := NewAgentHandler(mockService)

    router := gin.New()
    router.GET(""/api/v1/agents"", handler.GetAll)

    mockService.On(""GetAll"").Return([]*domain.Agent{
        {Paw: ""agent-001"", Hostname: ""host1""},
    }, nil)

    req, _ := http.NewRequest(""GET"", ""/api/v1/agents"", nil)
    rec := httptest.NewRecorder()

    router.ServeHTTP(rec, req)

    assert.Equal(t, http.StatusOK, rec.Code)

    var response []domain.Agent
    json.Unmarshal(rec.Body.Bytes(), &response)
    assert.Len(t, response, 1)
}

func TestAgentHandler_GetByPaw_NotFound(t *testing.T) {
    // Test 404 si agent n'existe pas
}

func TestExecutionHandler_Start(t *testing.T) {
    // Test POST /scenarios/{id}/execute
}
```

**Definition of Done:**
[ ] Tests GET /api/v1/agents
[ ] Tests GET /api/v1/agents/:paw
[ ] Tests GET /api/v1/scenarios
[ ] Tests POST /api/v1/scenarios
[ ] Tests POST /api/v1/scenarios/:id/execute
[ ] Tests codes erreur (400, 401, 404)
[ ] Coverage handlers >75%",test;backend
"[TEST-08] Tests middleware auth",Task,"**Objectif:** Tester la validation JWT et le refresh token.

**Commandes:**
```bash
go test -v ./internal/infrastructure/http/middleware/*_test.go
```

**Fichiers:**
- server/internal/infrastructure/http/middleware/auth_middleware.go
- server/internal/infrastructure/http/middleware/auth_middleware_test.go

**Exemple code:**
```go
// auth_middleware_test.go
func TestAuthMiddleware_ValidToken(t *testing.T) {
    gin.SetMode(gin.TestMode)

    jwtService := NewJWTService(""test-secret"")
    middleware := NewAuthMiddleware(jwtService)

    token, _ := jwtService.GenerateToken(""user-001"", ""admin"")

    router := gin.New()
    router.Use(middleware.Authenticate())
    router.GET(""/protected"", func(c *gin.Context) {
        userID := c.GetString(""user_id"")
        c.JSON(200, gin.H{""user_id"": userID})
    })

    req, _ := http.NewRequest(""GET"", ""/protected"", nil)
    req.Header.Set(""Authorization"", ""Bearer ""+token)
    rec := httptest.NewRecorder()

    router.ServeHTTP(rec, req)

    assert.Equal(t, http.StatusOK, rec.Code)
}

func TestAuthMiddleware_ExpiredToken(t *testing.T) {
    // Test token expiré -> 401
}

func TestAuthMiddleware_InvalidSignature(t *testing.T) {
    // Test signature invalide -> 401
}

func TestAuthMiddleware_MissingHeader(t *testing.T) {
    // Test sans header Authorization -> 401
}

func TestAuthMiddleware_RefreshToken(t *testing.T) {
    // Test refresh token flow
}
```

**Definition of Done:**
[ ] Tests token valide
[ ] Tests token expiré
[ ] Tests signature invalide
[ ] Tests header manquant
[ ] Tests refresh token
[ ] Tests rôles (admin, operator, viewer)
[ ] Coverage middleware >90%",test;backend
"[TEST-09] Configurer tests Rust",Task,"**Objectif:** Mettre en place l'infrastructure de tests pour l'agent Rust avec coverage >70%.

**Commandes:**
```bash
# Exécuter les tests
cargo test
cargo test -- --nocapture  # Voir les prints

# Coverage avec cargo-tarpaulin
cargo install cargo-tarpaulin
cargo tarpaulin --out Html

# Tests spécifiques
cargo test beacon_tests
cargo test --lib  # Uniquement unit tests
```

**Fichiers:**
- agent/src/lib.rs
- agent/src/beacon/mod.rs (avec #[cfg(test)] module)
- agent/src/executor/mod.rs (avec tests)
- agent/tests/integration_tests.rs

**Exemple code:**
```rust
// src/beacon/mod.rs
#[cfg(test)]
mod tests {
    use super::*;
    use mockall::predicate::*;
    use mockall::mock;

    mock! {
        HttpClient {}
        impl HttpClient {
            fn post(&self, url: &str, body: &[u8]) -> Result<Response, Error>;
        }
    }

    #[test]
    fn test_beacon_sends_heartbeat() {
        let mut mock_client = MockHttpClient::new();
        mock_client
            .expect_post()
            .with(eq(""https://server:8443/api/v1/beacon""), always())
            .times(1)
            .returning(|_, _| Ok(Response::new(200)));

        let beacon = Beacon::new(mock_client);
        let result = beacon.send_heartbeat();

        assert!(result.is_ok());
    }
}
```

**Definition of Done:**
[ ] cargo test passe sans erreur
[ ] Coverage global >70%
[ ] Mocks configurés avec mockall
[ ] Tests unitaires et intégration séparés
[ ] CI intégré avec rapport coverage",test;agent
"[TEST-10] Tests beacon client",Task,"**Objectif:** Tester les fonctions de beacon et report_result de l'agent.

**Commandes:**
```bash
cargo test beacon:: --lib
```

**Fichiers:**
- agent/src/beacon/client.rs
- agent/src/beacon/mod.rs

**Exemple code:**
```rust
// src/beacon/client.rs
#[cfg(test)]
mod tests {
    use super::*;
    use wiremock::{MockServer, Mock, ResponseTemplate};
    use wiremock::matchers::{method, path, body_json};

    #[tokio::test]
    async fn test_beacon_receives_tasks() {
        let mock_server = MockServer::start().await;

        let response_body = json!({
            ""tasks"": [
                {""id"": ""task-001"", ""technique_id"": ""T1082""}
            ]
        });

        Mock::given(method(""POST""))
            .and(path(""/api/v1/beacon""))
            .respond_with(ResponseTemplate::new(200).set_body_json(&response_body))
            .mount(&mock_server)
            .await;

        let client = BeaconClient::new(&mock_server.uri(), ""agent-001"");
        let tasks = client.beacon().await.unwrap();

        assert_eq!(tasks.len(), 1);
        assert_eq!(tasks[0].technique_id, ""T1082"");
    }

    #[tokio::test]
    async fn test_report_result_success() {
        let mock_server = MockServer::start().await;

        Mock::given(method(""POST""))
            .and(path(""/api/v1/results""))
            .respond_with(ResponseTemplate::new(200))
            .mount(&mock_server)
            .await;

        let client = BeaconClient::new(&mock_server.uri(), ""agent-001"");
        let result = client.report_result(""task-001"", ""success"", ""output"").await;

        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_beacon_handles_server_error() {
        // Test retry logic on 500
    }
}
```

**Definition of Done:**
[ ] Tests beacon reçoit tasks
[ ] Tests report_result success/failure
[ ] Tests retry sur erreur serveur
[ ] Tests timeout handling
[ ] Tests mTLS certificate validation
[ ] Coverage beacon >80%",test;agent
"[TEST-11] Tests executors",Task,"**Objectif:** Tester les executors PowerShell, CMD et Bash.

**Commandes:**
```bash
cargo test executor:: --lib
```

**Fichiers:**
- agent/src/executor/mod.rs
- agent/src/executor/powershell.rs
- agent/src/executor/cmd.rs
- agent/src/executor/bash.rs

**Exemple code:**
```rust
// src/executor/powershell.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_powershell_executor_echo() {
        let executor = PowerShellExecutor::new();
        let result = executor.execute(""Write-Output 'Hello'"").unwrap();

        assert!(result.success);
        assert!(result.stdout.contains(""Hello""));
    }

    #[test]
    fn test_powershell_executor_error() {
        let executor = PowerShellExecutor::new();
        let result = executor.execute(""Get-NonExistentCmdlet"").unwrap();

        assert!(!result.success);
        assert!(!result.stderr.is_empty());
    }

    #[test]
    fn test_powershell_executor_timeout() {
        let executor = PowerShellExecutor::new().with_timeout(Duration::from_secs(1));
        let result = executor.execute(""Start-Sleep -Seconds 10"");

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), ExecutorError::Timeout));
    }
}

// src/executor/bash.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[cfg(target_os = ""linux"")]
    fn test_bash_executor_echo() {
        let executor = BashExecutor::new();
        let result = executor.execute(""echo 'Hello'"").unwrap();

        assert!(result.success);
        assert!(result.stdout.contains(""Hello""));
    }
}
```

**Definition of Done:**
[ ] Tests PowerShell executor (Windows)
[ ] Tests CMD executor (Windows)
[ ] Tests Bash executor (Linux)
[ ] Tests timeout handling
[ ] Tests caractères spéciaux/escape
[ ] Tests working directory
[ ] Coverage executors >75%",test;agent
"[TEST-12] Configurer Vitest React",Task,"**Objectif:** Mettre en place Vitest pour le dashboard React avec coverage >70%.

**Commandes:**
```bash
# Installation
npm install -D vitest @vitest/coverage-v8 @testing-library/react @testing-library/jest-dom jsdom

# Exécuter tests
npm run test
npm run test:coverage
npm run test:ui  # Interface visuelle
```

**Fichiers:**
- dashboard/vitest.config.ts
- dashboard/src/test/setup.ts
- dashboard/package.json (scripts)

**Exemple code:**
```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'html', 'lcov'],
      exclude: ['node_modules/', 'src/test/'],
      thresholds: {
        global: {
          branches: 70,
          functions: 70,
          lines: 70,
          statements: 70
        }
      }
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})

// src/test/setup.ts
import '@testing-library/jest-dom'
import { vi } from 'vitest'

// Mock WebSocket
vi.mock('@/hooks/useWebSocket', () => ({
  useWebSocket: () => ({
    isConnected: true,
    send: vi.fn(),
    lastMessage: null,
  }),
}))
```

**Definition of Done:**
[ ] vitest.config.ts créé et fonctionnel
[ ] Setup file avec mocks globaux
[ ] Scripts npm configurés
[ ] Coverage thresholds à 70%
[ ] CI intégré
[ ] Documentation dans README",test;dashboard
"[TEST-13] Tests composants UI",Task,"**Objectif:** Tester les composants UI de base (Button, Card, Modal).

**Commandes:**
```bash
npm run test -- src/components/ui/
```

**Fichiers:**
- dashboard/src/components/ui/Button.test.tsx
- dashboard/src/components/ui/Card.test.tsx
- dashboard/src/components/ui/Modal.test.tsx

**Exemple code:**
```tsx
// Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { describe, it, expect, vi } from 'vitest'
import { Button } from './Button'

describe('Button', () => {
  it('renders with children', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByText('Click me')).toBeInTheDocument()
  })

  it('calls onClick when clicked', () => {
    const handleClick = vi.fn()
    render(<Button onClick={handleClick}>Click</Button>)
    fireEvent.click(screen.getByText('Click'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })

  it('is disabled when disabled prop is true', () => {
    render(<Button disabled>Click</Button>)
    expect(screen.getByText('Click')).toBeDisabled()
  })

  it('shows loading spinner when loading', () => {
    render(<Button loading>Click</Button>)
    expect(screen.getByRole('status')).toBeInTheDocument()
  })

  it('applies variant styles correctly', () => {
    render(<Button variant=""destructive"">Delete</Button>)
    expect(screen.getByText('Delete')).toHaveClass('bg-destructive')
  })
})

// Modal.test.tsx
describe('Modal', () => {
  it('renders when open is true', () => {
    render(<Modal open={true} onClose={vi.fn()}>Content</Modal>)
    expect(screen.getByText('Content')).toBeInTheDocument()
  })

  it('does not render when open is false', () => {
    render(<Modal open={false} onClose={vi.fn()}>Content</Modal>)
    expect(screen.queryByText('Content')).not.toBeInTheDocument()
  })

  it('calls onClose when clicking overlay', () => {
    const onClose = vi.fn()
    render(<Modal open={true} onClose={onClose}>Content</Modal>)
    fireEvent.click(screen.getByTestId('modal-overlay'))
    expect(onClose).toHaveBeenCalled()
  })
})
```

**Definition of Done:**
[ ] Tests Button (variants, states, onClick)
[ ] Tests Card (render, children)
[ ] Tests Modal (open/close, overlay click)
[ ] Tests Input (value, onChange, validation)
[ ] Tests Select (options, selection)
[ ] Coverage composants UI >80%",test;dashboard
"[TEST-14] Tests pages",Task,"**Objectif:** Tester le rendu des pages principales.

**Commandes:**
```bash
npm run test -- src/pages/
```

**Fichiers:**
- dashboard/src/pages/Dashboard.test.tsx
- dashboard/src/pages/Agents.test.tsx
- dashboard/src/pages/Scenarios.test.tsx
- dashboard/src/pages/Executions.test.tsx

**Exemple code:**
```tsx
// Dashboard.test.tsx
import { render, screen, waitFor } from '@testing-library/react'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { MemoryRouter } from 'react-router-dom'
import Dashboard from './Dashboard'

const queryClient = new QueryClient({
  defaultOptions: { queries: { retry: false } }
})

const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>
    <MemoryRouter>{children}</MemoryRouter>
  </QueryClientProvider>
)

describe('Dashboard', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('renders security score card', async () => {
    render(<Dashboard />, { wrapper })
    await waitFor(() => {
      expect(screen.getByText(/Security Score/i)).toBeInTheDocument()
    })
  })

  it('renders MITRE matrix', async () => {
    render(<Dashboard />, { wrapper })
    await waitFor(() => {
      expect(screen.getByTestId('mitre-matrix')).toBeInTheDocument()
    })
  })

  it('displays agent count', async () => {
    render(<Dashboard />, { wrapper })
    await waitFor(() => {
      expect(screen.getByText(/Agents Online/i)).toBeInTheDocument()
    })
  })
})

// Agents.test.tsx
describe('Agents Page', () => {
  it('renders agent list', async () => {
    render(<Agents />, { wrapper })
    await waitFor(() => {
      expect(screen.getByText('agent-001')).toBeInTheDocument()
    })
  })

  it('shows deploy modal when clicking deploy button', () => {
    // Test ouverture modal déploiement
  })
})
```

**Definition of Done:**
[ ] Tests Dashboard (score, matrix, stats)
[ ] Tests Agents page (liste, détail)
[ ] Tests Scenarios page (liste, création)
[ ] Tests Executions page (historique)
[ ] Tests avec données mockées
[ ] Coverage pages >70%",test;dashboard
"[TEST-15] Tests hooks",Task,"**Objectif:** Tester les hooks custom (useAgents, useWebSocket).

**Commandes:**
```bash
npm run test -- src/hooks/
```

**Fichiers:**
- dashboard/src/hooks/useAgents.test.ts
- dashboard/src/hooks/useWebSocket.test.ts
- dashboard/src/hooks/useAuth.test.ts

**Exemple code:**
```tsx
// useAgents.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useAgents } from './useAgents'

// Mock API
vi.mock('@/lib/api', () => ({
  api: {
    get: vi.fn(() => Promise.resolve({
      data: [
        { paw: 'agent-001', hostname: 'host1', status: 'online' }
      ]
    }))
  }
}))

const queryClient = new QueryClient()
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

describe('useAgents', () => {
  it('fetches agents successfully', async () => {
    const { result } = renderHook(() => useAgents(), { wrapper })

    await waitFor(() => {
      expect(result.current.isLoading).toBe(false)
    })

    expect(result.current.agents).toHaveLength(1)
    expect(result.current.agents[0].paw).toBe('agent-001')
  })

  it('handles error state', async () => {
    // Mock erreur API
  })
})

// useWebSocket.test.ts
describe('useWebSocket', () => {
  it('connects to websocket server', () => {
    const { result } = renderHook(() => useWebSocket('/ws'))
    expect(result.current.isConnected).toBe(true)
  })

  it('receives messages', async () => {
    // Test réception message
  })

  it('reconnects on disconnect', () => {
    // Test auto-reconnect
  })
})
```

**Definition of Done:**
[ ] Tests useAgents (fetch, refresh, error)
[ ] Tests useWebSocket (connect, message, reconnect)
[ ] Tests useAuth (login, logout, token)
[ ] Tests useScenarios
[ ] Tests useExecutions
[ ] Coverage hooks >80%",test;dashboard
"[TEST-16] Tests intégration API",Task,"**Objectif:** Tests E2E de l'API avec un agent de test.

**Commandes:**
```bash
# Démarrer environnement test
docker-compose -f docker-compose.test.yml up -d

# Exécuter tests intégration
go test -tags=integration ./tests/integration/...

# Cleanup
docker-compose -f docker-compose.test.yml down
```

**Fichiers:**
- server/tests/integration/api_test.go
- server/tests/integration/agent_flow_test.go
- server/tests/integration/execution_flow_test.go
- docker-compose.test.yml

**Exemple code:**
```go
// tests/integration/api_test.go
// +build integration

package integration

import (
    ""net/http""
    ""testing""
    ""github.com/stretchr/testify/suite""
)

type APIIntegrationSuite struct {
    suite.Suite
    baseURL string
    token   string
}

func (s *APIIntegrationSuite) SetupSuite() {
    s.baseURL = ""http://localhost:8443""
    s.token = s.authenticate()
}

func (s *APIIntegrationSuite) authenticate() string {
    // Login et récupérer token
}

func (s *APIIntegrationSuite) TestAgentRegistration() {
    // 1. Simuler enregistrement agent
    // 2. Vérifier agent dans liste
    // 3. Vérifier statut online
}

func (s *APIIntegrationSuite) TestFullExecutionFlow() {
    // 1. Créer scénario
    scenario := s.createScenario()

    // 2. Lancer exécution
    execution := s.startExecution(scenario.ID)
    s.Equal(""pending"", execution.Status)

    // 3. Simuler beacon agent et récupérer tâches
    tasks := s.agentBeacon()
    s.NotEmpty(tasks)

    // 4. Simuler rapport résultat
    s.reportResult(tasks[0].ID, ""detected"")

    // 5. Vérifier exécution complétée
    execution = s.getExecution(execution.ID)
    s.Equal(""completed"", execution.Status)
}

func TestAPIIntegrationSuite(t *testing.T) {
    suite.Run(t, new(APIIntegrationSuite))
}
```

**Definition of Done:**
[ ] Tests enregistrement agent
[ ] Tests cycle complet exécution
[ ] Tests API endpoints CRUD
[ ] Tests WebSocket notifications
[ ] Tests authentication flow
[ ] docker-compose.test.yml fonctionnel
[ ] CI avec tests intégration",test;integration
"[DOCS-01] Rédiger README principal",Task,"**Objectif:** Créer le README principal avec description, installation et quickstart.

**Fichiers:**
- README.md (racine projet)

**Structure:**
```markdown
# AutoStrike

## Description
Plateforme de Breach and Attack Simulation (BAS) open-source basée sur MITRE ATT&CK.

## Features
- Matrice MITRE ATT&CK interactive
- Agent multi-plateforme (Windows/Linux)
- Dashboard temps réel
- Scénarios d'attaque personnalisables

## Quick Start

### Prérequis
- Docker & Docker Compose
- Go 1.21+ (pour dev)
- Node.js 18+ (pour dev)
- Rust 1.70+ (pour agent)

### Installation
```bash
git clone https://github.com/your-org/autostrike.git
cd autostrike
docker-compose up -d
```

### Accès Dashboard
- URL: https://localhost:8443
- Login: admin / admin (changer au premier login)

## Architecture
[Schéma simplifié]

## Documentation
- [Guide d'installation](docs/installation.md)
- [Guide utilisateur](docs/user-guide.md)
- [API Reference](docs/api.md)

## Contributing
[Guidelines]

## License
MIT
```

**Definition of Done:**
[ ] Description projet claire
[ ] Prerequisites listés
[ ] Quick start fonctionnel
[ ] Liens vers documentation détaillée
[ ] Badges (build, coverage, license)
[ ] Screenshots dashboard",docs
"[DOCS-02] Documenter API OpenAPI",Task,"**Objectif:** Créer la spécification OpenAPI 3.0 complète de l'API.

**Fichiers:**
- docs/api/openapi.yaml
- docs/api/README.md

**Contenu:**
```yaml
openapi: 3.0.3
info:
  title: AutoStrike API
  description: API REST de la plateforme BAS AutoStrike
  version: 1.0.0
  contact:
    name: AutoStrike Team
    email: contact@autostrike.io

servers:
  - url: https://localhost:8443/api/v1
    description: Local development

tags:
  - name: Authentication
    description: Login, logout, token refresh
  - name: Agents
    description: Gestion des agents
  - name: Techniques
    description: Techniques MITRE ATT&CK
  - name: Scenarios
    description: Scénarios d'attaque
  - name: Executions
    description: Exécution et résultats

paths:
  /auth/login:
    post: ...
  /agents:
    get: ...
    post: ...
  /agents/{paw}:
    get: ...
    delete: ...
  /techniques:
    get: ...
  /scenarios:
    get: ...
    post: ...
  /scenarios/{id}:
    get: ...
    put: ...
    delete: ...
  /scenarios/{id}/execute:
    post: ...
  /executions:
    get: ...
  /executions/{id}:
    get: ...

components:
  schemas: ...
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
```

**Definition of Done:**
[ ] Tous les endpoints documentés
[ ] Schemas request/response complets
[ ] Exemples pour chaque endpoint
[ ] Codes erreur documentés
[ ] Validé avec swagger-cli validate
[ ] Swagger UI intégré",docs;api
"[DOCS-03] Rédiger guide installation",Task,"**Objectif:** Documenter toutes les options d'installation.

**Fichiers:**
- docs/installation.md

**Contenu:**
```markdown
# Guide d'Installation AutoStrike

## Option 1: Docker (Recommandé)

### Prérequis
- Docker 20.10+
- Docker Compose 2.0+
- 4GB RAM minimum
- 10GB espace disque

### Installation
```bash
# Cloner le repo
git clone https://github.com/your-org/autostrike.git
cd autostrike

# Configurer l'environnement
cp .env.example .env
# Éditer .env avec vos paramètres

# Générer les certificats
./scripts/generate-certs.sh

# Démarrer
docker-compose up -d
```

## Option 2: Installation Manuelle

### Backend (Go)
```bash
cd server
go build -o autostrike-server ./cmd/server
./autostrike-server
```

### Dashboard (React)
```bash
cd dashboard
npm install
npm run build
npm run preview
```

### Agent (Rust)
```bash
cd agent
cargo build --release
./target/release/autostrike-agent --server https://server:8443
```

## Configuration

### Variables d'environnement
| Variable | Description | Défaut |
|----------|-------------|--------|
| SERVER_PORT | Port du serveur | 8443 |
| JWT_SECRET | Secret pour JWT | (généré) |
| DATABASE_PATH | Chemin SQLite | ./data/autostrike.db |

## Troubleshooting
- Port déjà utilisé
- Certificat invalide
- Agent ne se connecte pas
```

**Definition of Done:**
[ ] Installation Docker documentée
[ ] Installation manuelle documentée
[ ] Configuration expliquée
[ ] Section troubleshooting
[ ] Testé sur machine vierge",docs
"[DOCS-04] Rédiger guide utilisateur",Task,"**Objectif:** Tutoriel complet d'utilisation du dashboard.

**Fichiers:**
- docs/user-guide.md
- docs/images/ (screenshots)

**Contenu:**
```markdown
# Guide Utilisateur AutoStrike

## Premiers Pas

### Connexion
1. Accéder à https://server:8443
2. Entrer vos identifiants
3. Changer le mot de passe par défaut

### Interface Principale
[Screenshot avec annotations]

## Gestion des Agents

### Déployer un Agent
1. Aller dans Agents > Déployer
2. Sélectionner la plateforme (Windows/Linux)
3. Copier la commande générée
4. Exécuter sur la machine cible

### Vérifier le Statut
[Screenshot liste agents]

## Exécuter un Scénario

### Scénarios Prédéfinis
1. Aller dans Scénarios
2. Sélectionner un scénario
3. Cliquer sur ""Exécuter""
4. Choisir les agents cibles
5. Confirmer l'exécution

### Créer un Scénario Custom
1. Cliquer sur ""Nouveau Scénario""
2. Donner un nom et description
3. Ajouter des techniques depuis la liste
4. Sauvegarder

## Analyser les Résultats

### Matrice MITRE
[Explication des couleurs]
- Vert: Technique bloquée
- Orange: Technique détectée
- Rouge: Technique non détectée

### Rapports
[Comment exporter PDF]

## Bonnes Pratiques
- Exécuter en mode safe en production
- Planifier les tests hors heures ouvrées
- Documenter les exclusions EDR
```

**Definition of Done:**
[ ] Tutoriel pas-à-pas complet
[ ] Screenshots annotés
[ ] Sections pour chaque rôle utilisateur
[ ] Bonnes pratiques documentées
[ ] FAQ incluse",docs
"[DOCS-05] Documenter architecture",Task,"**Objectif:** Documenter l'architecture technique avec diagrammes.

**Fichiers:**
- docs/architecture.md
- docs/diagrams/ (fichiers source)

**Contenu:**
```markdown
# Architecture AutoStrike

## Vue d'Ensemble

```
┌─────────────┐     HTTPS/WSS      ┌─────────────┐
│  Dashboard  │ ◄─────────────────► │   Server    │
│   (React)   │                     │    (Go)     │
└─────────────┘                     └──────┬──────┘
                                           │
                                    mTLS   │
                                           │
                    ┌──────────────────────┼──────────────────────┐
                    │                      │                      │
                    ▼                      ▼                      ▼
             ┌─────────────┐        ┌─────────────┐        ┌─────────────┐
             │   Agent 1   │        │   Agent 2   │        │   Agent N   │
             │   (Rust)    │        │   (Rust)    │        │   (Rust)    │
             └─────────────┘        └─────────────┘        └─────────────┘
```

## Composants

### Server (Go)
- Architecture hexagonale
- API REST + WebSocket
- SQLite/PostgreSQL

### Agent (Rust)
- Beacon HTTP/S
- Executors (PowerShell, CMD, Bash)
- Techniques MITRE

### Dashboard (React)
- SPA avec React Router
- TanStack Query pour état serveur
- D3.js pour visualisations

## Flux de Données
[Diagramme séquence]

## Choix Technologiques
[Justifications Go, Rust, React]

## Sécurité
- mTLS agent-server
- JWT pour dashboard
- Chiffrement base de données
```

**Definition of Done:**
[ ] Diagramme architecture globale
[ ] Description chaque composant
[ ] Diagramme séquence exécution
[ ] Justifications choix technologiques
[ ] Considérations sécurité documentées",docs
"[DOCS-06] Rédiger guide déploiement agent",Task,"**Objectif:** Documenter le déploiement des agents Windows et Linux.

**Fichiers:**
- docs/agent-deployment.md

**Contenu:**
```markdown
# Guide Déploiement Agent AutoStrike

## Windows

### Prérequis
- Windows 10/11 ou Windows Server 2016+
- PowerShell 5.1+
- Droits administrateur local
- Port 8443 sortant vers serveur

### Installation One-Liner
```powershell
# Depuis PowerShell Admin
Invoke-Expression ((New-Object Net.WebClient).DownloadString('https://server:8443/deploy/windows'))
```

### Installation Manuelle
```powershell
# Télécharger l'agent
Invoke-WebRequest -Uri ""https://server:8443/download/agent.exe"" -OutFile ""C:\Program Files\AutoStrike\agent.exe""

# Installer le service
& ""C:\Program Files\AutoStrike\agent.exe"" install --server https://server:8443

# Démarrer
Start-Service AutoStrikeAgent
```

### Configuration EDR
Ajouter aux exclusions:
- Chemin: C:\Program Files\AutoStrike\
- Hash: [SHA256 de l'agent]

## Linux

### Prérequis
- Ubuntu 20.04+ ou RHEL 8+
- curl installé
- Accès root/sudo
- Port 8443 sortant

### Installation One-Liner
```bash
curl -sSL https://server:8443/deploy/linux | sudo bash
```

### Installation Manuelle
```bash
# Télécharger
curl -o /opt/autostrike/agent https://server:8443/download/agent-linux

# Permissions
chmod +x /opt/autostrike/agent

# Service systemd
sudo cp /opt/autostrike/autostrike.service /etc/systemd/system/
sudo systemctl enable autostrike
sudo systemctl start autostrike
```

## Options de Configuration

| Option | Description | Défaut |
|--------|-------------|--------|
| --server | URL du serveur | (requis) |
| --beacon-interval | Intervalle beacon (sec) | 30 |
| --safe-mode | Mode safe uniquement | true |

## Troubleshooting
[Problèmes courants et solutions]
```

**Definition of Done:**
[ ] Instructions Windows complètes
[ ] Instructions Linux complètes
[ ] Options de configuration documentées
[ ] Section troubleshooting
[ ] Scripts de déploiement testés",docs
"[DOCS-07] Documenter ajout technique",Task,"**Objectif:** Guide pour ajouter une nouvelle technique MITRE.

**Fichiers:**
- docs/adding-technique.md

**Contenu:**
```markdown
# Ajouter une Technique MITRE ATT&CK

## Structure d'une Technique

```yaml
# techniques/discovery/T1082.yaml
id: T1082
name: System Information Discovery
tactic: discovery
description: |
  Adversaries may attempt to get detailed information about
  the operating system and hardware.

platforms:
  - windows
  - linux
  - macos

is_safe: true  # Ne modifie pas le système

detection:
  - Sysmon Event ID 1 (Process Create)
  - EDR monitoring of systeminfo.exe

executors:
  windows:
    powershell: |
      Get-ComputerInfo | Select-Object CsName, OsName, OsVersion
    cmd: |
      systeminfo
  linux:
    bash: |
      uname -a && cat /etc/os-release
```

## Étapes

### 1. Identifier la Technique
- Consulter la matrice MITRE: https://attack.mitre.org
- Vérifier qu'elle n'existe pas déjà

### 2. Créer le Fichier YAML
```bash
cp techniques/_template.yaml techniques/[tactic]/T[ID].yaml
```

### 3. Implémenter les Executors
- Tester manuellement chaque commande
- S'assurer du mode safe si applicable

### 4. Ajouter les Critères de Détection
- Documenter les indicateurs EDR/SIEM attendus

### 5. Tester
```bash
# Importer la technique
curl -X POST https://server:8443/api/v1/techniques/import \
  -H ""Authorization: Bearer $TOKEN"" \
  -d @techniques/discovery/T1082.yaml

# Exécuter un test
# Vérifier les résultats
```

## Checklist
[ ] ID MITRE valide
[ ] Nom et description clairs
[ ] Platforms supportées listées
[ ] is_safe correctement défini
[ ] Executors testés
[ ] Détection documentée
```

**Definition of Done:**
[ ] Template YAML documenté
[ ] Processus étape par étape
[ ] Exemples concrets
[ ] Checklist validation
[ ] Testable end-to-end",docs
"[DOCS-08] Créer changelog",Task,"**Objectif:** Maintenir un CHANGELOG.md avec l'historique des versions.

**Fichiers:**
- CHANGELOG.md

**Contenu:**
```markdown
# Changelog

All notable changes to AutoStrike will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Feature en cours de développement

### Changed
- Modifications en cours

### Fixed
- Bugs corrigés

## [1.0.0] - 2026-XX-XX

### Added
- Dashboard React avec matrice MITRE ATT&CK interactive
- API REST Go avec authentification JWT
- Agent Rust multi-plateforme (Windows/Linux)
- 15 techniques MITRE Discovery implémentées
- 5 techniques MITRE Execution implémentées
- 5 techniques MITRE Persistence implémentées
- Système de scénarios personnalisables
- Exécution temps réel avec WebSocket
- Mode safe par défaut
- Communication mTLS agent-server
- Docker Compose pour déploiement

### Security
- Authentification JWT avec refresh tokens
- mTLS pour communication agent-server
- Rate limiting sur API
- Audit logging des actions sensibles

## [0.1.0] - 2025-XX-XX (Alpha)

### Added
- Preuve de concept initiale
- Architecture de base
```

**Definition of Done:**
[ ] Format Keep a Changelog respecté
[ ] Versioning sémantique utilisé
[ ] Sections Added/Changed/Fixed/Security
[ ] Entrées pour v1.0.0
[ ] Template pour futures versions",docs
"[DOCKER-01] Créer Dockerfile server",Task,"**Objectif:** Créer un Dockerfile multi-stage optimisé pour le serveur Go.

**Fichiers:**
- server/Dockerfile

**Contenu:**
```dockerfile
# server/Dockerfile

# Stage 1: Build
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Installer dépendances système
RUN apk add --no-cache git ca-certificates

# Copier go.mod et go.sum pour le cache
COPY go.mod go.sum ./
RUN go mod download

# Copier le code source
COPY . .

# Build avec optimisations
RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build \
    -ldflags=""-w -s -X main.version=$(git describe --tags --always)"" \
    -o /autostrike-server \
    ./cmd/server

# Stage 2: Runtime
FROM alpine:3.18

WORKDIR /app

# Certificats SSL et timezone
RUN apk add --no-cache ca-certificates tzdata

# Créer utilisateur non-root
RUN adduser -D -g '' autostrike
USER autostrike

# Copier le binaire
COPY --from=builder /autostrike-server /app/autostrike-server

# Copier les techniques MITRE
COPY --chown=autostrike:autostrike techniques/ /app/techniques/

# Port exposé
EXPOSE 8443

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider https://localhost:8443/health || exit 1

# Démarrage
ENTRYPOINT [""/app/autostrike-server""]
```

**Commandes:**
```bash
# Build
docker build -t autostrike-server:latest ./server

# Test
docker run -p 8443:8443 autostrike-server:latest

# Vérifier taille
docker images autostrike-server:latest
```

**Definition of Done:**
[ ] Multi-stage build fonctionnel
[ ] Image finale <50MB
[ ] Utilisateur non-root
[ ] Health check configuré
[ ] Variables d'environnement documentées
[ ] Testé localement",devops;docker
"[DOCKER-02] Créer Dockerfile dashboard",Task,"**Objectif:** Créer un Dockerfile pour le dashboard React servi par nginx.

**Fichiers:**
- dashboard/Dockerfile
- dashboard/nginx.conf

**Contenu:**
```dockerfile
# dashboard/Dockerfile

# Stage 1: Build
FROM node:18-alpine AS builder

WORKDIR /app

# Copier package.json pour le cache
COPY package*.json ./
RUN npm ci

# Copier le code source
COPY . .

# Build production
RUN npm run build

# Stage 2: Runtime
FROM nginx:alpine

# Copier la config nginx
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Copier le build
COPY --from=builder /app/dist /usr/share/nginx/html

# Port exposé
EXPOSE 80

# Health check
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost/health || exit 1
```

```nginx
# dashboard/nginx.conf
server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # Gzip
    gzip on;
    gzip_types text/plain text/css application/json application/javascript;

    # SPA routing
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Health check
    location /health {
        access_log off;
        return 200 ""OK"";
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        expires 1y;
        add_header Cache-Control ""public, immutable"";
    }

    # Security headers
    add_header X-Frame-Options ""SAMEORIGIN"";
    add_header X-Content-Type-Options ""nosniff"";
    add_header X-XSS-Protection ""1; mode=block"";
}
```

**Commandes:**
```bash
# Build
docker build -t autostrike-dashboard:latest ./dashboard

# Test
docker run -p 3000:80 autostrike-dashboard:latest
```

**Definition of Done:**
[ ] Multi-stage build fonctionnel
[ ] Image finale <30MB
[ ] nginx.conf optimisé
[ ] SPA routing correct
[ ] Headers sécurité
[ ] Testé localement",devops;docker
"[DOCKER-03] Créer docker-compose.yml",Task,"**Objectif:** Créer le docker-compose principal pour déploiement production.

**Fichiers:**
- docker-compose.yml
- .env.example

**Contenu:**
```yaml
# docker-compose.yml
version: '3.8'

services:
  server:
    build:
      context: ./server
      dockerfile: Dockerfile
    container_name: autostrike-server
    restart: unless-stopped
    ports:
      - ""8443:8443""
    environment:
      - SERVER_PORT=8443
      - DATABASE_PATH=/data/autostrike.db
      - JWT_SECRET=${JWT_SECRET}
      - TLS_CERT_PATH=/certs/server.crt
      - TLS_KEY_PATH=/certs/server.key
    volumes:
      - autostrike-data:/data
      - ./certs:/certs:ro
      - ./techniques:/app/techniques:ro
    networks:
      - autostrike-net
    healthcheck:
      test: [""CMD"", ""wget"", ""--spider"", ""--quiet"", ""https://localhost:8443/health""]
      interval: 30s
      timeout: 10s
      retries: 3

  dashboard:
    build:
      context: ./dashboard
      dockerfile: Dockerfile
    container_name: autostrike-dashboard
    restart: unless-stopped
    ports:
      - ""443:80""
    depends_on:
      - server
    networks:
      - autostrike-net
    healthcheck:
      test: [""CMD"", ""wget"", ""--spider"", ""--quiet"", ""http://localhost/health""]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  autostrike-data:
    driver: local

networks:
  autostrike-net:
    driver: bridge
```

```bash
# .env.example
JWT_SECRET=your-secret-key-here-change-in-production
SERVER_PORT=8443
```

**Commandes:**
```bash
# Démarrer
docker-compose up -d

# Voir les logs
docker-compose logs -f

# Arrêter
docker-compose down

# Rebuild
docker-compose up -d --build
```

**Definition of Done:**
[ ] Services server et dashboard configurés
[ ] Volumes pour persistence
[ ] Network isolé
[ ] Variables d'environnement externalisées
[ ] Health checks
[ ] .env.example documenté
[ ] Testé end-to-end",devops;docker
"[DOCKER-04] Créer docker-compose.dev.yml",Task,"**Objectif:** Configuration Docker pour développement avec hot reload.

**Fichiers:**
- docker-compose.dev.yml

**Contenu:**
```yaml
# docker-compose.dev.yml
version: '3.8'

services:
  server:
    build:
      context: ./server
      dockerfile: Dockerfile.dev
    container_name: autostrike-server-dev
    ports:
      - ""8443:8443""
    environment:
      - GO_ENV=development
      - DATABASE_PATH=/data/autostrike.db
      - JWT_SECRET=dev-secret-not-for-production
    volumes:
      - ./server:/app
      - autostrike-data-dev:/data
      - ./certs:/certs:ro
    networks:
      - autostrike-dev
    command: air -c .air.toml  # Hot reload Go

  dashboard:
    build:
      context: ./dashboard
      dockerfile: Dockerfile.dev
    container_name: autostrike-dashboard-dev
    ports:
      - ""3000:5173""
    environment:
      - VITE_API_URL=https://localhost:8443
    volumes:
      - ./dashboard:/app
      - /app/node_modules
    networks:
      - autostrike-dev
    command: npm run dev -- --host

  # Agent de test pour développement
  test-agent:
    build:
      context: ./agent
      dockerfile: Dockerfile.dev
    container_name: autostrike-agent-dev
    environment:
      - AUTOSTRIKE_SERVER=https://server:8443
      - RUST_LOG=debug
    volumes:
      - ./agent:/app
    networks:
      - autostrike-dev
    depends_on:
      - server

volumes:
  autostrike-data-dev:

networks:
  autostrike-dev:
    driver: bridge
```

```dockerfile
# server/Dockerfile.dev
FROM golang:1.21-alpine

WORKDIR /app

RUN go install github.com/air-verse/air@latest

COPY go.mod go.sum ./
RUN go mod download

EXPOSE 8443

CMD [""air""]
```

```dockerfile
# dashboard/Dockerfile.dev
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm install

EXPOSE 5173

CMD [""npm"", ""run"", ""dev"", ""--"", ""--host""]
```

**Commandes:**
```bash
# Démarrer env dev
docker-compose -f docker-compose.dev.yml up -d

# Voir logs
docker-compose -f docker-compose.dev.yml logs -f server

# Rebuild dashboard après npm install
docker-compose -f docker-compose.dev.yml up -d --build dashboard
```

**Definition of Done:**
[ ] Hot reload Go avec Air
[ ] Hot reload React avec Vite
[ ] Agent de test inclus
[ ] Volumes pour code source
[ ] Ports dev configurés
[ ] Documentation usage",devops;docker
"[DOCKER-05] Script génération certificats Docker",Task,"**Objectif:** Script pour générer les certificats TLS/mTLS dans un container.

**Fichiers:**
- scripts/generate-certs.sh
- scripts/Dockerfile.certs

**Contenu:**
```bash
#!/bin/bash
# scripts/generate-certs.sh

set -e

CERTS_DIR=""./certs""
VALIDITY_DAYS=365
CA_SUBJECT=""/CN=AutoStrike-CA/O=AutoStrike/C=FR""
SERVER_SUBJECT=""/CN=autostrike-server/O=AutoStrike/C=FR""

echo ""[+] Generating certificates for AutoStrike...""

# Créer le dossier
mkdir -p $CERTS_DIR

# CA (Certificate Authority)
echo ""[+] Generating CA...""
openssl genrsa -out $CERTS_DIR/ca.key 4096
openssl req -x509 -new -nodes -key $CERTS_DIR/ca.key \
    -sha256 -days $VALIDITY_DAYS \
    -out $CERTS_DIR/ca.crt \
    -subj ""$CA_SUBJECT""

# Server certificate
echo ""[+] Generating server certificate...""
openssl genrsa -out $CERTS_DIR/server.key 2048
openssl req -new -key $CERTS_DIR/server.key \
    -out $CERTS_DIR/server.csr \
    -subj ""$SERVER_SUBJECT""

# Extensions pour SAN
cat > $CERTS_DIR/server.ext << EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
DNS.2 = autostrike-server
DNS.3 = server
IP.1 = 127.0.0.1
EOF

openssl x509 -req -in $CERTS_DIR/server.csr \
    -CA $CERTS_DIR/ca.crt -CAkey $CERTS_DIR/ca.key \
    -CAcreateserial -out $CERTS_DIR/server.crt \
    -days $VALIDITY_DAYS -sha256 \
    -extfile $CERTS_DIR/server.ext

# Agent certificate template
echo ""[+] Generating agent certificate template...""
openssl genrsa -out $CERTS_DIR/agent-template.key 2048

# Cleanup
rm -f $CERTS_DIR/*.csr $CERTS_DIR/*.ext $CERTS_DIR/*.srl

# Permissions
chmod 600 $CERTS_DIR/*.key
chmod 644 $CERTS_DIR/*.crt

echo ""[+] Certificates generated successfully!""
echo ""    CA:     $CERTS_DIR/ca.crt""
echo ""    Server: $CERTS_DIR/server.crt""
echo ""    Keys:   $CERTS_DIR/*.key""
```

```dockerfile
# scripts/Dockerfile.certs
FROM alpine:3.18

RUN apk add --no-cache openssl bash

WORKDIR /certs

COPY generate-certs.sh /scripts/

ENTRYPOINT [""/bin/bash"", ""/scripts/generate-certs.sh""]
```

**Commandes:**
```bash
# Via Docker (recommandé)
docker build -t autostrike-certs -f scripts/Dockerfile.certs scripts/
docker run -v $(pwd)/certs:/certs autostrike-certs

# Ou directement
chmod +x scripts/generate-certs.sh
./scripts/generate-certs.sh
```

**Definition of Done:**
[ ] Script génère CA, server cert, agent template
[ ] SAN inclut localhost et noms Docker
[ ] Permissions restrictives sur clés
[ ] Exécutable via Docker
[ ] Documentation des certificats générés
[ ] Rotation documentée",devops;docker
"[SEC-01] Audit sécurité code Go",Task,"**Objectif:** Audit de sécurité du code Go selon OWASP et bonnes pratiques.

**Commandes:**
```bash
# Installer les outils
go install github.com/securego/gosec/v2/cmd/gosec@latest
go install golang.org/x/vuln/cmd/govulncheck@latest

# Analyse statique
gosec -fmt=json -out=gosec-report.json ./...

# Vérifier vulnérabilités dépendances
govulncheck ./...

# Linter sécurité
staticcheck ./...
```

**Fichiers à auditer:**
- server/internal/infrastructure/http/handlers/*.go
- server/internal/application/services/*.go
- server/pkg/auth/*.go
- server/cmd/server/main.go

**Checklist OWASP:**
```
[ ] A01 - Broken Access Control
    - Vérifier middleware auth sur tous les endpoints
    - Tester escalade de privilèges
    - Vérifier RBAC (admin, operator, viewer)

[ ] A02 - Cryptographic Failures
    - JWT secret suffisamment long (>256 bits)
    - Mots de passe hashés avec bcrypt
    - TLS 1.2+ obligatoire

[ ] A03 - Injection
    - Requêtes SQL préparées (pas de concaténation)
    - Validation entrées utilisateur
    - Escape output HTML

[ ] A04 - Insecure Design
    - Validation côté serveur (pas juste client)
    - Rate limiting implémenté
    - Timeouts configurés

[ ] A05 - Security Misconfiguration
    - Headers sécurité (CORS, CSP, X-Frame-Options)
    - Mode debug désactivé en prod
    - Erreurs génériques (pas de stack traces)

[ ] A07 - Authentication Failures
    - Tokens JWT avec expiration
    - Refresh tokens sécurisés
    - Logout invalide le token
```

**Exemple corrections:**
```go
// AVANT (vulnérable injection SQL)
query := fmt.Sprintf(""SELECT * FROM users WHERE id = '%s'"", userID)
db.Raw(query)

// APRÈS (sécurisé)
db.Where(""id = ?"", userID).Find(&user)

// AVANT (JWT secret faible)
jwtSecret := ""secret123""

// APRÈS (secret fort)
jwtSecret := os.Getenv(""JWT_SECRET"") // 256+ bits
```

**Definition of Done:**
[ ] gosec passe sans erreur critique
[ ] govulncheck sans vulnérabilité connue
[ ] Checklist OWASP validée
[ ] Rapport d'audit documenté
[ ] Corrections appliquées
[ ] Code review sécurité par pair",security
"[SEC-02] Audit sécurité code Rust",Task,"**Objectif:** Audit de sécurité du code Rust (memory safety, input validation).

**Commandes:**
```bash
# Audit dépendances
cargo install cargo-audit
cargo audit

# Vérifier unsafe
cargo install cargo-geiger
cargo geiger

# Linter sécurité
cargo clippy -- -W clippy::all -W clippy::pedantic

# Fuzzing (optionnel)
cargo install cargo-fuzz
cargo fuzz run input_parser
```

**Fichiers à auditer:**
- agent/src/beacon/*.rs
- agent/src/executor/*.rs
- agent/src/main.rs

**Checklist sécurité Rust:**
```
[ ] Memory Safety
    - Pas de unsafe non justifié
    - Lifetime bien gérés
    - Pas de memory leaks

[ ] Input Validation
    - Validation commandes reçues du serveur
    - Sanitization avant exécution
    - Limites de taille

[ ] Error Handling
    - Pas de unwrap() en production
    - Errors loggés mais pas exposés
    - Graceful degradation

[ ] Cryptography
    - Validation certificat serveur
    - Pas de désactivation TLS verify
    - Génération aléatoire sécurisée

[ ] Process Execution
    - Commands whitelistées
    - Arguments sanitizés
    - Timeouts sur exécution
```

**Exemple corrections:**
```rust
// AVANT (dangerous unwrap)
let response = client.get(url).send().unwrap();

// APRÈS (error handling)
let response = client.get(url).send()
    .map_err(|e| {
        error!(""Request failed: {}"", e);
        AgentError::NetworkError(e)
    })?;

// AVANT (command injection possible)
let output = Command::new(""bash"")
    .arg(""-c"")
    .arg(user_input)  // DANGER!
    .output()?;

// APRÈS (whitelist commands)
let allowed_commands = vec![""systeminfo"", ""hostname""];
if !allowed_commands.contains(&command) {
    return Err(AgentError::CommandNotAllowed);
}
```

**Definition of Done:**
[ ] cargo audit sans vulnérabilité
[ ] cargo geiger: unsafe justifié et documenté
[ ] clippy warnings résolus
[ ] Checklist validée
[ ] Rapport d'audit documenté
[ ] Tests fuzzing (bonus)",security
"[SEC-03] Audit sécurité code React",Task,"**Objectif:** Audit de sécurité du code React (XSS, CSRF, storage).

**Commandes:**
```bash
# Audit dépendances
npm audit
npm audit fix

# ESLint sécurité
npm install -D eslint-plugin-security
npx eslint --ext .tsx,.ts src/ --rule 'security/detect-object-injection: warn'

# Vérifier secrets exposés
npx secretlint ""**/*""
```

**Fichiers à auditer:**
- dashboard/src/components/**/*.tsx
- dashboard/src/pages/**/*.tsx
- dashboard/src/lib/api.ts
- dashboard/src/hooks/useAuth.ts

**Checklist sécurité React:**
```
[ ] XSS Prevention
    - Pas de dangerouslySetInnerHTML
    - Inputs sanitizés avant affichage
    - CSP headers configurés

[ ] CSRF Protection
    - Token CSRF sur mutations
    - SameSite cookies
    - Origin header vérifié

[ ] Authentication/Storage
    - Tokens dans httpOnly cookies (pas localStorage)
    - Refresh token sécurisé
    - Logout efface tous les tokens

[ ] API Security
    - HTTPS uniquement
    - Authorization header sur toutes les requêtes
    - Pas de credentials dans URL

[ ] Secrets/Config
    - Pas de secrets dans le code
    - VITE_* variables publiques uniquement
    - .env dans .gitignore
```

**Exemple corrections:**
```tsx
// AVANT (XSS vulnérable)
<div dangerouslySetInnerHTML={{__html: userContent}} />

// APRÈS (sanitized)
import DOMPurify from 'dompurify';
<div dangerouslySetInnerHTML={{__html: DOMPurify.sanitize(userContent)}} />

// AVANT (token dans localStorage)
localStorage.setItem('token', token);

// APRÈS (httpOnly cookie via server)
// Le token est géré côté serveur avec Set-Cookie httpOnly

// AVANT (credentials dans URL)
fetch(`/api/users?token=${token}`)

// APRÈS (header Authorization)
fetch('/api/users', {
  headers: { 'Authorization': `Bearer ${token}` }
})
```

**Definition of Done:**
[ ] npm audit sans vulnérabilité critique
[ ] ESLint security plugin configuré
[ ] Checklist validée
[ ] Pas de dangerouslySetInnerHTML
[ ] Tokens sécurisés
[ ] Rapport d'audit documenté",security
"[SEC-04] Configurer rate limiting",Task,"**Objectif:** Protéger l'API contre les attaques bruteforce.

**Fichiers:**
- server/internal/infrastructure/http/middleware/ratelimit.go
- server/internal/infrastructure/http/middleware/ratelimit_test.go

**Implémentation:**
```go
// middleware/ratelimit.go
package middleware

import (
    ""net/http""
    ""sync""
    ""time""
    ""github.com/gin-gonic/gin""
    ""golang.org/x/time/rate""
)

type IPRateLimiter struct {
    ips map[string]*rate.Limiter
    mu  *sync.RWMutex
    r   rate.Limit
    b   int
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
    return &IPRateLimiter{
        ips: make(map[string]*rate.Limiter),
        mu:  &sync.RWMutex{},
        r:   r,
        b:   b,
    }
}

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
    i.mu.Lock()
    defer i.mu.Unlock()

    limiter, exists := i.ips[ip]
    if !exists {
        limiter = rate.NewLimiter(i.r, i.b)
        i.ips[ip] = limiter
    }

    return limiter
}

func RateLimitMiddleware(limiter *IPRateLimiter) gin.HandlerFunc {
    return func(c *gin.Context) {
        ip := c.ClientIP()
        if !limiter.GetLimiter(ip).Allow() {
            c.JSON(http.StatusTooManyRequests, gin.H{
                ""error"": ""Too many requests"",
                ""retry_after"": ""60s"",
            })
            c.Abort()
            return
        }
        c.Next()
    }
}

// Rate limiting spécifique pour login (plus strict)
func LoginRateLimitMiddleware() gin.HandlerFunc {
    limiter := NewIPRateLimiter(rate.Every(time.Minute), 5) // 5 req/min
    return RateLimitMiddleware(limiter)
}
```

**Configuration:**
```go
// main.go ou router.go
router := gin.Default()

// Rate limit global: 100 req/sec par IP
globalLimiter := NewIPRateLimiter(100, 200)
router.Use(RateLimitMiddleware(globalLimiter))

// Rate limit strict sur login
auth := router.Group(""/api/v1/auth"")
auth.POST(""/login"", LoginRateLimitMiddleware(), authHandler.Login)
```

**Tests:**
```go
func TestRateLimiter_BlocksAfterLimit(t *testing.T) {
    limiter := NewIPRateLimiter(rate.Every(time.Second), 2)

    // 2 premières requêtes OK
    assert.True(t, limiter.GetLimiter(""1.2.3.4"").Allow())
    assert.True(t, limiter.GetLimiter(""1.2.3.4"").Allow())

    // 3ème bloquée
    assert.False(t, limiter.GetLimiter(""1.2.3.4"").Allow())
}
```

**Definition of Done:**
[ ] Rate limiting global (100 req/s)
[ ] Rate limiting login (5 req/min)
[ ] Header Retry-After dans réponse 429
[ ] Tests unitaires
[ ] Logs des IPs bloquées
[ ] Documentation configuration",security
"[SEC-05] Implémenter audit logging",Task,"**Objectif:** Logger toutes les actions sensibles de manière immuable.

**Fichiers:**
- server/internal/infrastructure/audit/logger.go
- server/internal/infrastructure/audit/logger_test.go
- server/internal/domain/audit_event.go

**Implémentation:**
```go
// domain/audit_event.go
package domain

import ""time""

type AuditEvent struct {
    ID        string    `json:""id""`
    Timestamp time.Time `json:""timestamp""`
    UserID    string    `json:""user_id""`
    Action    string    `json:""action""`
    Resource  string    `json:""resource""`
    ResourceID string   `json:""resource_id""`
    IPAddress string    `json:""ip_address""`
    UserAgent string    `json:""user_agent""`
    Status    string    `json:""status""`  // success, failure
    Details   string    `json:""details""` // JSON additionnel
}

// Actions auditées
const (
    AuditActionLogin          = ""auth.login""
    AuditActionLogout         = ""auth.logout""
    AuditActionLoginFailed    = ""auth.login_failed""
    AuditActionAgentRegister  = ""agent.register""
    AuditActionAgentDelete    = ""agent.delete""
    AuditActionScenarioCreate = ""scenario.create""
    AuditActionScenarioDelete = ""scenario.delete""
    AuditActionExecutionStart = ""execution.start""
    AuditActionExecutionStop  = ""execution.stop""
    AuditActionUserCreate     = ""user.create""
    AuditActionUserDelete     = ""user.delete""
)
```

```go
// infrastructure/audit/logger.go
package audit

import (
    ""encoding/json""
    ""os""
    ""sync""
)

type AuditLogger struct {
    file *os.File
    mu   sync.Mutex
}

func NewAuditLogger(path string) (*AuditLogger, error) {
    file, err := os.OpenFile(path, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0600)
    if err != nil {
        return nil, err
    }
    return &AuditLogger{file: file}, nil
}

func (l *AuditLogger) Log(event *domain.AuditEvent) error {
    l.mu.Lock()
    defer l.mu.Unlock()

    event.ID = uuid.New().String()
    event.Timestamp = time.Now().UTC()

    data, err := json.Marshal(event)
    if err != nil {
        return err
    }

    _, err = l.file.WriteString(string(data) + ""\n"")
    return err
}

// Middleware Gin pour audit automatique
func AuditMiddleware(logger *AuditLogger) gin.HandlerFunc {
    return func(c *gin.Context) {
        c.Next()

        // Log après la requête
        event := &domain.AuditEvent{
            UserID:    c.GetString(""user_id""),
            Action:    c.FullPath(),
            IPAddress: c.ClientIP(),
            UserAgent: c.Request.UserAgent(),
            Status:    getStatusFromCode(c.Writer.Status()),
        }
        logger.Log(event)
    }
}
```

**Format log (JSON Lines):**
```json
{""id"":""evt-001"",""timestamp"":""2025-01-15T10:30:00Z"",""user_id"":""user-001"",""action"":""execution.start"",""resource"":""scenario"",""resource_id"":""scn-001"",""ip_address"":""192.168.1.100"",""status"":""success""}
{""id"":""evt-002"",""timestamp"":""2025-01-15T10:31:00Z"",""user_id"":""user-002"",""action"":""auth.login_failed"",""ip_address"":""10.0.0.50"",""status"":""failure"",""details"":""{}\""reason\"":\""invalid_password\""}""}
```

**Definition of Done:**
[ ] AuditEvent domain model
[ ] AuditLogger avec fichier append-only
[ ] Middleware Gin intégré
[ ] Actions sensibles loguées
[ ] Format JSON Lines
[ ] Rotation logs (logrotate)
[ ] Tests unitaires",security
"[SEC-06] Review certificats mTLS",Task,"**Objectif:** Valider la configuration TLS et documenter la rotation.

**Fichiers:**
- docs/security/mtls-setup.md
- scripts/rotate-certs.sh

**Checklist validation:**
```
[ ] Configuration TLS Server
    - TLS 1.2+ uniquement
    - Cipher suites sécurisées
    - Certificate chain valide

[ ] Validation certificat client (mTLS)
    - Agent vérifie certificat serveur
    - Serveur vérifie certificat agent
    - CA commune

[ ] Génération certificats
    - Clé RSA 2048+ ou ECDSA P-256+
    - Validité max 1 an
    - SAN configurés correctement

[ ] Stockage sécurisé
    - Clés privées mode 600
    - Pas de clés dans git
    - Secrets manager en prod
```

**Configuration serveur (Go):**
```go
// config/tls.go
func LoadTLSConfig(certFile, keyFile, caFile string) (*tls.Config, error) {
    cert, err := tls.LoadX509KeyPair(certFile, keyFile)
    if err != nil {
        return nil, err
    }

    caCert, err := os.ReadFile(caFile)
    if err != nil {
        return nil, err
    }

    caCertPool := x509.NewCertPool()
    caCertPool.AppendCertsFromPEM(caCert)

    return &tls.Config{
        Certificates: []tls.Certificate{cert},
        ClientCAs:    caCertPool,
        ClientAuth:   tls.RequireAndVerifyClientCert,
        MinVersion:   tls.VersionTLS12,
        CipherSuites: []uint16{
            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
            tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
        },
    }, nil
}
```

**Script rotation:**
```bash
#!/bin/bash
# scripts/rotate-certs.sh

echo ""[+] Rotating certificates...""

# Backup anciens certs
cp -r certs/ certs.backup.$(date +%Y%m%d)

# Générer nouveaux
./scripts/generate-certs.sh

# Redémarrer services
docker-compose restart server

# Redéployer agents (nécessite nouveau cert)
echo ""[!] Agents need to be redeployed with new certificates""

echo ""[+] Certificate rotation complete""
```

**Documentation:**
```markdown
# Configuration mTLS AutoStrike

## Architecture
- CA interne signe tous les certificats
- Serveur a un certificat signé par CA
- Chaque agent a un certificat unique signé par CA

## Rotation des certificats

### Fréquence recommandée
- CA: tous les 5 ans
- Server: tous les ans
- Agents: tous les ans (avec redéploiement)

### Procédure
1. Générer nouveaux certificats
2. Déployer sur serveur (zero-downtime possible)
3. Redéployer agents progressivement
4. Révoquer anciens certificats
```

**Definition of Done:**
[ ] Config TLS validée (testssl.sh)
[ ] mTLS fonctionnel agent-server
[ ] Script rotation documenté
[ ] Procédure révocation documentée
[ ] Cipher suites sécurisées
[ ] Documentation complète",security
"[US-008] Configurer le serveur",Story,"En tant qu'administrateur, je veux configurer le serveur facilement pour adapter AutoStrike a mon environnement sans modifier le code.

**Criteres d'acceptation:**
- [ ] Fichier de configuration YAML avec toutes les options documentees
- [ ] Variables d'environnement supportees pour les secrets (JWT_SECRET, DB_URL)
- [ ] Validation de la configuration au demarrage avec messages d'erreur clairs
- [ ] Configuration du port, host, TLS, timeout agent
- [ ] Hot-reload de certains parametres sans redemarrage
- [ ] Documentation des options de configuration dans le README

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Les secrets ne doivent jamais etre en clair dans les logs
- Les valeurs par defaut doivent etre securisees (TLS active, etc.)
- Validation stricte des chemins de fichiers (certificats, base de donnees)

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires de la validation de configuration
- [ ] Documentation complete des options
- [ ] Exemple de fichier config.example.yaml",mvp;us;config
"[US-009] Stopper une execution en cours",Story,"En tant qu'operateur, je veux stopper une execution en cours pour arreter les tests si necessaire (faux positif, probleme detecte).

**Criteres d'acceptation:**
- [ ] Bouton 'Stop' visible sur la page d'execution en cours
- [ ] Confirmation demandee avant l'arret (modal)
- [ ] Les taches en attente sont annulees immediatement
- [ ] La tache en cours termine son execution proprement (cleanup)
- [ ] Le statut de l'execution passe a 'cancelled'
- [ ] Les resultats partiels sont conserves et consultables
- [ ] Notification WebSocket envoyee a tous les clients connectes

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role 'Operator' minimum requis
- RG-005: Cleanup obligatoire - Meme en cas d'arret, le cleanup doit s'executer
- RG-006: Logs immuables - L'arret est trace dans les logs d'audit

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du service d'arret
- [ ] Tests E2E du flow complet
- [ ] Documentation utilisateur",mvp;us;execution
"[US-013] Voir historique des executions",Story,"En tant qu'analyste SOC, je veux voir l'historique des executions pour analyser l'evolution de la securite dans le temps.

**Criteres d'acceptation:**
- [ ] Liste paginee des executions passees avec: date, scenario, duree, score, statut
- [ ] Filtres par periode (jour, semaine, mois, custom)
- [ ] Filtres par scenario et par statut (completed, failed, cancelled)
- [ ] Tri par date, score, duree
- [ ] Click sur une execution ouvre le detail avec tous les resultats
- [ ] Export de l'historique en CSV

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Tout utilisateur authentifie peut consulter
- RG-006: Logs immuables - L'historique ne peut pas etre modifie ou supprime

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires des filtres et pagination
- [ ] Tests E2E du parcours utilisateur
- [ ] Performance validee avec >1000 executions",should-have;us;history
"[US-014] Comparer les scores entre periodes",Story,"En tant que RSSI, je veux comparer les scores de securite entre differentes periodes pour mesurer l'evolution et l'efficacite des actions correctives.

**Criteres d'acceptation:**
- [ ] Selection de deux periodes a comparer (ex: ce mois vs mois precedent)
- [ ] Affichage cote a cote des scores globaux avec delta (+/- X%)
- [ ] Graphique d'evolution du score sur la periode selectionnee
- [ ] Detail des techniques qui se sont ameliorees ou degradees
- [ ] Identification des nouvelles techniques testees
- [ ] Export du comparatif en PDF pour reporting

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role 'RSSI' ou superieur
- RG-007: Score calculation - Meme formule appliquee aux deux periodes

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du calcul de comparaison
- [ ] Validation metier par Product Owner
- [ ] Documentation des metriques",should-have;us;reporting
"[US-015] Planifier des executions automatiques",Story,"En tant qu'operateur, je veux planifier des executions automatiques pour tester regulierement mes defenses sans intervention manuelle.

**Criteres d'acceptation:**
- [ ] Interface de planification avec selection du scenario et des agents
- [ ] Frequence configurable: quotidien, hebdomadaire, mensuel, cron expression
- [ ] Selection du jour et de l'heure d'execution
- [ ] Activation/desactivation d'un planning sans le supprimer
- [ ] Notification par email du resultat de l'execution planifiee
- [ ] Historique des executions planifiees avec leur statut

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role 'Operator' minimum
- RG-003: Agent heartbeat - Execution annulee si aucun agent online
- RG-004: Technique safe only - Mode production uniquement safe

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du scheduler
- [ ] Tests d'integration avec cron
- [ ] Documentation du format cron",should-have;us;automation
"[US-016] Gerer les utilisateurs",Story,"En tant qu'administrateur, je veux gerer les utilisateurs et leurs roles pour controler les acces a la plateforme.

**Criteres d'acceptation:**
- [ ] Liste des utilisateurs avec: email, role, date creation, derniere connexion
- [ ] Creation d'un nouvel utilisateur avec email et role
- [ ] Modification du role d'un utilisateur existant
- [ ] Desactivation d'un compte (sans suppression pour audit)
- [ ] Reinitialisation du mot de passe (envoi email)
- [ ] Roles disponibles: Admin, RSSI, Operator, Analyst, Viewer

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role 'Admin' requis
- Un admin ne peut pas se desactiver lui-meme
- Au moins un admin doit toujours exister

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires CRUD utilisateurs
- [ ] Tests E2E du parcours admin
- [ ] Documentation des roles et permissions",should-have;us;admin
"[US-017] Voir details d'une technique",Story,"En tant qu'analyste SOC, je veux voir les details d'une technique MITRE pour comprendre ce qui est teste et comment remedier.

**Criteres d'acceptation:**
- [ ] Panel de detail au click sur une technique dans la matrice
- [ ] Informations affichees: ID MITRE, nom, description, tactic
- [ ] Commandes executees par plateforme (Windows, Linux)
- [ ] Indicateurs de detection attendus
- [ ] Historique des resultats pour cette technique
- [ ] Lien vers la page MITRE ATT&CK officielle
- [ ] Recommandations de remediation

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Tout utilisateur authentifie

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du composant
- [ ] Accessibilite verifiee (WCAG AA)
- [ ] Documentation des champs affiches",should-have;us;frontend
"[US-018] Importer et exporter des scenarios",Story,"En tant que pentester, je veux importer et exporter des scenarios pour partager mes configurations entre environnements ou avec d'autres equipes.

**Criteres d'acceptation:**
- [ ] Export d'un scenario en format JSON avec toutes ses phases et techniques
- [ ] Import d'un fichier JSON pour creer un nouveau scenario
- [ ] Validation du schema JSON a l'import avec messages d'erreur clairs
- [ ] Gestion des conflits si techniques non disponibles
- [ ] Preview du scenario avant confirmation de l'import
- [ ] Support du drag-and-drop pour l'import

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role 'Pentester' ou 'Admin'
- Le scenario importe est cree comme nouveau (pas d'ecrasement)
- Les techniques non reconnues sont ignorees avec warning

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires import/export
- [ ] Documentation du format JSON
- [ ] Exemples de scenarios partageables",should-have;us;scenarios
"[US-019] Recevoir des notifications email",Story,"En tant qu'utilisateur, je veux recevoir des notifications email pour etre informe des evenements importants meme quand je ne suis pas connecte.

**Criteres d'acceptation:**
- [ ] Configuration des preferences de notification par utilisateur
- [ ] Notifications disponibles: execution terminee, agent offline, nouveau rapport
- [ ] Template email professionnel avec logo AutoStrike
- [ ] Lien direct vers la ressource concernee dans l'email
- [ ] Option de desabonnement par type de notification
- [ ] Resume quotidien optionnel (digest)

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Chaque utilisateur gere ses preferences
- Conformite RGPD: consentement explicite requis

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du service email
- [ ] Tests avec differents providers SMTP
- [ ] Templates email valides (HTML + texte)",should-have;us;notifications
"[US-021] Gerer les permissions granulaires",Story,"En tant qu'administrateur, je veux definir des permissions granulaires pour controler precisement ce que chaque role peut faire.

**Criteres d'acceptation:**
- [ ] Matrice de permissions par role (Admin, RSSI, Operator, Analyst, Viewer)
- [ ] Permissions: voir agents, executer scenarios, creer scenarios, voir rapports, exporter
- [ ] Interface d'edition des permissions par role
- [ ] Roles custom creables par l'admin
- [ ] Verification des permissions sur chaque endpoint API
- [ ] Affichage adapte dans l'UI selon les permissions

**Regles de gestion associees:**
- RG-001: Authentification obligatoire - Role 'Admin' requis pour modifier
- Les permissions Admin ne peuvent pas etre restreintes par un autre Admin
- Audit log de tous les changements de permissions

**Definition of Done:**
- [ ] Code review approuvee
- [ ] Tests unitaires du systeme de permissions
- [ ] Tests E2E des restrictions d'acces
- [ ] Documentation de la matrice de permissions",could-have;us;admin
