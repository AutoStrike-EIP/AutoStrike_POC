package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"gopkg.in/yaml.v3"
)

// AtomicTechniqueFile represents the top-level Atomic Red Team YAML structure
type AtomicTechniqueFile struct {
	AttackTechnique string       `yaml:"attack_technique"`
	DisplayName     string       `yaml:"display_name"`
	AtomicTests     []AtomicTest `yaml:"atomic_tests"`
}

// AtomicTest represents a single atomic test
type AtomicTest struct {
	Name               string                    `yaml:"name"`
	AutoGeneratedGUID  string                    `yaml:"auto_generated_guid"`
	Description        string                    `yaml:"description"`
	SupportedPlatforms []string                  `yaml:"supported_platforms"`
	Executor           AtomicExecutor            `yaml:"executor"`
	InputArguments     map[string]InputArgument   `yaml:"input_arguments"`
}

// AtomicExecutor represents the executor in an atomic test
type AtomicExecutor struct {
	Name              string `yaml:"name"`
	Command           string `yaml:"command"`
	CleanupCommand    string `yaml:"cleanup_command"`
	ElevationRequired bool   `yaml:"elevation_required"`
}

// InputArgument represents an input argument for an atomic test
type InputArgument struct {
	Description string `yaml:"description"`
	Type        string `yaml:"type"`
	Default     string `yaml:"default"`
}

// AtomicTechnique is the parsed result for a technique with its executors
type AtomicTechnique struct {
	ID        string
	Name      string
	Executors []AtomicExecutorResult
}

// AtomicExecutorResult is a single parsed executor from Atomic Red Team
type AtomicExecutorResult struct {
	Name              string
	Type              string // "cmd", "powershell", "bash", "sh"
	Platform          string // "windows", "linux", "macos"
	Command           string
	Cleanup           string
	ElevationRequired bool
}

// executorTypeMap maps Atomic Red Team executor names to AutoStrike types
var executorTypeMap = map[string]string{
	"command_prompt": "cmd",
	"powershell":    "powershell",
	"bash":          "bash",
	"sh":            "sh",
}

// templateRegex matches #{param} templates
var templateRegex = regexp.MustCompile(`#\{([^}]+)\}`)

// ParseAtomics parses all Atomic Red Team YAML files from the atomics directory
func ParseAtomics(atomicsDir string) (map[string]*AtomicTechnique, error) {
	techniques := make(map[string]*AtomicTechnique)

	// List technique directories (T####)
	entries, err := os.ReadDir(atomicsDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read atomics directory: %w", err)
	}

	for _, entry := range entries {
		if !entry.IsDir() || !strings.HasPrefix(entry.Name(), "T") {
			continue
		}

		techID := entry.Name()
		yamlPath := filepath.Join(atomicsDir, techID, techID+".yaml")

		// Also try .yml
		if _, err := os.Stat(yamlPath); os.IsNotExist(err) {
			yamlPath = filepath.Join(atomicsDir, techID, techID+".yml")
		}

		tech, err := ParseAtomicFile(yamlPath, techID)
		if err != nil {
			continue // Skip files that can't be parsed
		}
		if tech != nil && len(tech.Executors) > 0 {
			techniques[techID] = tech
		}
	}

	return techniques, nil
}

// ParseAtomicFile parses a single Atomic Red Team YAML file
func ParseAtomicFile(path string, techID string) (*AtomicTechnique, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	return ParseAtomicData(data, techID)
}

// ParseAtomicData parses Atomic Red Team YAML data
func ParseAtomicData(data []byte, techID string) (*AtomicTechnique, error) {
	var file AtomicTechniqueFile
	if err := yaml.Unmarshal(data, &file); err != nil {
		return nil, fmt.Errorf("failed to parse atomic YAML: %w", err)
	}

	tech := &AtomicTechnique{
		ID:   techID,
		Name: file.DisplayName,
	}

	// Track executor names for deduplication
	nameCount := make(map[string]int)

	for _, test := range file.AtomicTests {
		// Skip manual executors
		execType, ok := executorTypeMap[test.Executor.Name]
		if !ok {
			continue
		}

		command := resolveTemplates(test.Executor.Command, test.InputArguments)
		cleanup := resolveTemplates(test.Executor.CleanupCommand, test.InputArguments)

		// Deduplicate name once per test, not per platform
		name := test.Name
		nameCount[name]++
		if nameCount[name] > 1 {
			name = fmt.Sprintf("%s (%d)", name, nameCount[name])
		}

		// Determine platform from supported_platforms
		for _, platform := range test.SupportedPlatforms {
			platform = strings.ToLower(platform)
			if platform != "windows" && platform != "linux" && platform != "macos" {
				continue
			}

			tech.Executors = append(tech.Executors, AtomicExecutorResult{
				Name:              name,
				Type:              execType,
				Platform:          platform,
				Command:           strings.TrimSpace(command),
				Cleanup:           strings.TrimSpace(cleanup),
				ElevationRequired: test.Executor.ElevationRequired,
			})
		}
	}

	return tech, nil
}

// resolveTemplates replaces #{param} with the default value from input_arguments
func resolveTemplates(command string, args map[string]InputArgument) string {
	if command == "" {
		return ""
	}

	return templateRegex.ReplaceAllStringFunc(command, func(match string) string {
		paramName := templateRegex.FindStringSubmatch(match)[1]
		if arg, ok := args[paramName]; ok && arg.Default != "" {
			return arg.Default
		}
		return "" // Replace with empty if no default
	})
}
