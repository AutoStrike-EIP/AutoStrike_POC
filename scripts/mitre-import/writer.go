package main

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

// YAMLTechnique represents a technique in the output YAML format (matches server entity)
type YAMLTechnique struct {
	ID          string         `yaml:"id"`
	Name        string         `yaml:"name"`
	Description string         `yaml:"description"`
	Tactic      string         `yaml:"tactic"`
	Tactics     []string       `yaml:"tactics,omitempty"`
	Platforms   []string       `yaml:"platforms"`
	Executors   []YAMLExecutor `yaml:"executors"`
	References  []string       `yaml:"references,omitempty"`
	IsSafe      bool           `yaml:"is_safe"`
}

// YAMLExecutor represents an executor in the output YAML format
type YAMLExecutor struct {
	Name              string `yaml:"name,omitempty"`
	Type              string `yaml:"type"`
	Platform          string `yaml:"platform,omitempty"`
	Command           string `yaml:"command"`
	Cleanup           string `yaml:"cleanup,omitempty"`
	Timeout           int    `yaml:"timeout"`
	ElevationRequired bool   `yaml:"elevation_required,omitempty"`
}

// WriteResult holds the result of writing YAML files
type WriteResult struct {
	FilesWritten    int
	TotalTechniques int
	FileBreakdown   map[string]int
}

// WriteYAMLFiles writes merged techniques to YAML files grouped by primary tactic
func WriteYAMLFiles(techniques []*MergedTechnique, outputDir string) (*WriteResult, error) {
	// Group by primary tactic
	grouped := make(map[string][]*MergedTechnique)
	for _, tech := range techniques {
		tactic := tech.Tactic
		if tactic == "" {
			tactic = "unknown"
		}
		grouped[tactic] = append(grouped[tactic], tech)
	}

	// Ensure output directory exists
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create output directory: %w", err)
	}

	result := &WriteResult{
		FileBreakdown: make(map[string]int),
	}

	// Write one file per tactic
	for tactic, techs := range grouped {
		filename := tacticFilename(tactic)
		if err := writeTacticFile(tactic, techs, outputDir); err != nil {
			return nil, fmt.Errorf("failed to write %s: %w", filename, err)
		}
		result.FilesWritten++
		result.TotalTechniques += len(techs)
		result.FileBreakdown[filename] = len(techs)
	}

	return result, nil
}

// writeTacticFile writes a single YAML file for a tactic
func writeTacticFile(tactic string, techniques []*MergedTechnique, outputDir string) error {
	// Sort techniques by ID for deterministic output
	sort.Slice(techniques, func(i, j int) bool {
		return techniques[i].ID < techniques[j].ID
	})

	yamlTechniques := make([]YAMLTechnique, 0, len(techniques))
	for _, tech := range techniques {
		yamlTechniques = append(yamlTechniques, toYAMLTechnique(tech))
	}

	// Marshal as a flat YAML list (matches existing server format)
	data, err := yaml.Marshal(yamlTechniques)
	if err != nil {
		return fmt.Errorf("failed to marshal YAML: %w", err)
	}

	filename := tacticFilename(tactic)
	path := filepath.Join(outputDir, filename)

	header := fmt.Sprintf("# AutoStrike MITRE ATT&CK Techniques - %s\n# Auto-generated by mitre-import script\n# Source: MITRE ATT&CK STIX 2.1 + Atomic Red Team\n\n", tactic)

	if err := os.WriteFile(path, []byte(header+string(data)), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

// cleanDescription trims leading whitespace from each line to avoid
// Go yaml.v3 producing block scalar indicators like |4- which break parsers.
func cleanDescription(desc string) string {
	lines := strings.Split(desc, "\n")
	for i, line := range lines {
		lines[i] = strings.TrimLeft(line, " \t")
	}
	return strings.TrimSpace(strings.Join(lines, "\n"))
}

// toYAMLTechnique converts a MergedTechnique to the output YAML format
func toYAMLTechnique(tech *MergedTechnique) YAMLTechnique {
	executors := make([]YAMLExecutor, 0, len(tech.Executors))
	for _, exec := range tech.Executors {
		executors = append(executors, YAMLExecutor{
			Name:              exec.Name,
			Type:              exec.Type,
			Platform:          exec.Platform,
			Command:           exec.Command,
			Cleanup:           exec.Cleanup,
			Timeout:           exec.Timeout,
			ElevationRequired: exec.ElevationRequired,
		})
	}

	yt := YAMLTechnique{
		ID:          tech.ID,
		Name:        tech.Name,
		Description: cleanDescription(tech.Description),
		Tactic:      tech.Tactic,
		Platforms:   tech.Platforms,
		Executors:   executors,
		References:  tech.References,
		IsSafe:      tech.IsSafe,
	}

	// Only include tactics array if multi-tactic
	if len(tech.Tactics) > 1 {
		yt.Tactics = tech.Tactics
	}

	return yt
}

// tacticFilename converts a STIX tactic name to the YAML filename
// e.g., "initial-access" -> "initial-access.yaml"
func tacticFilename(tactic string) string {
	// Use the tactic name directly with hyphens (matches existing file naming)
	return strings.ToLower(tactic) + ".yaml"
}

// PrintDryRunStats prints the merge statistics without writing files
func PrintDryRunStats(stats MergeStats, techniques []*MergedTechnique) {
	fmt.Println("=== MITRE ATT&CK Import - Dry Run ===")
	fmt.Println()
	fmt.Printf("STIX techniques total:    %d\n", stats.STIXTotal)
	fmt.Printf("Atomic techniques total:  %d\n", stats.AtomicTotal)
	fmt.Println()
	fmt.Printf("Matched (inner join):     %d\n", stats.Matched)
	fmt.Printf("STIX only (skipped):      %d\n", stats.STIXOnly)
	fmt.Printf("Atomic only (skipped):    %d\n", stats.AtomicOnly)
	fmt.Println()
	fmt.Printf("Total executors:          %d\n", stats.ExecutorsTotal)
	fmt.Printf("Safe techniques:          %d\n", stats.SafeCount)
	fmt.Printf("Unsafe techniques:        %d\n", stats.UnsafeCount)
	fmt.Println()

	if len(stats.TacticBreakdown) > 0 {
		fmt.Println("Techniques per tactic:")
		var tactics []string
		for t := range stats.TacticBreakdown {
			tactics = append(tactics, t)
		}
		sort.Strings(tactics)
		for _, t := range tactics {
			fmt.Printf("  %-25s %d\n", t, stats.TacticBreakdown[t])
		}
	}

	// Print technique list
	fmt.Println()
	fmt.Printf("Techniques (%d):\n", len(techniques))

	// Group by tactic for display
	byTactic := make(map[string][]*MergedTechnique)
	for _, tech := range techniques {
		tactic := tech.Tactic
		if tactic == "" {
			tactic = "unknown"
		}
		byTactic[tactic] = append(byTactic[tactic], tech)
	}

	var tactics []string
	for t := range byTactic {
		tactics = append(tactics, t)
	}
	sort.Strings(tactics)

	for _, tactic := range tactics {
		techs := byTactic[tactic]
		sort.Slice(techs, func(i, j int) bool {
			return techs[i].ID < techs[j].ID
		})
		fmt.Printf("\n  --- %s (%d) ---\n", tactic, len(techs))
		for _, tech := range techs {
			safeStr := "UNSAFE"
			if tech.IsSafe {
				safeStr = "safe"
			}
			fmt.Printf("    %s  %-45s [%s] %d executors\n",
				tech.ID, tech.Name, safeStr, len(tech.Executors))
		}
	}
}
